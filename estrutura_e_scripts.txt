### ESTRUTURA DE DIRETÓRIOS ###

runebound_dccg/
    estrutura_e_scripts.txt
    index.html
    README.md
    .git/
        COMMIT_EDITMSG
        config
        description
        FETCH_HEAD
        HEAD
        index
        ORIG_HEAD
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            sendemail-validate.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    main
                remotes/
                    origin/
                        main
        objects/
            00/
                d56d7158bdefb196e5bfd9c750a2d6b6c43cf8
            01/
                2a0ea8642716e1a3273da68e90adaacb9ba16c
            02/
                03c26eb576253bed5a397f7998ccb22bab6805
                696330e36465d8960154bd5bafcf1776311454
            05/
                b7cc3e8513e6031222432ed1f3afb0bbaff21f
                c72ced70d301770803c7a0d6f3b2e08391c8b0
            06/
                20be43ec9872f1adaa326046ea588e5b46927b
            08/
                9928c461c10e03a3e12275391639dd43562be6
            0a/
                68dedcbbd7cad1f82ad27ae596c31e9982318a
            0b/
                5165fab49a805e6d3ce8084bc4eaefad521eda
                facdac434312080060df27705cda1d608f9c15
            0c/
                5b573312ebe229808df327388fa63ed47105c0
                d620c9458ced659ca6661bfb963ef02f2d7e7e
            0d/
                95b0db212f1eed3d7cd0ebb4c61358ef03f82e
            10/
                35489a3ad90fb79ddc75dcbb770fc391dc2577
                685dd3e7b02399b4ba6c1f8e4fbab8dca55bf6
            11/
                b3f2809f0de7af905452b1c9c142769153d903
                b481f5fd6cd59c836b7697e933f253683c8ff3
            12/
                329d7bf1479fd0ecaadfc06bbd2b15add733c1
            14/
                50f687f488d94e56723f704236fc06cc43638d
                f00ebdd3e3f0f36c5f9aed570355081fdee97a
            15/
                8966491f9c9f6fa8a7458039d1f9d83b9c2971
            19/
                3fc5865060ebc9bfe5face7c14da42a55eb5f3
                b5c824cb13578818a401e96d95a4ba8d4f6d31
            1b/
                16854a3eb1fdd5f1ac44d96c06eafa1e8d8476
                bb755a146c59a2faa5d5386ccce2cd0501dbdd
            1d/
                8d269f50f1392686255cd0286f3868a84b85d6
                c8610e80d8516a98db89726564e92a31918847
                dbcb278e310ed4a7270164056ed44c12c027ba
            1f/
                19eee40d5f24ff75b6325fc5e24d1cdad55b8d
            20/
                24ca2e0087857f115f138bf0f5a5772b9f7e25
                44e5c4d02e09643e58de8294867e0cb363d3a3
            23/
                f7f4e99f3c642c6a4ca2c7dcbe75b4f1c7a4e2
            25/
                6dcfb604f3a3a4848307d741c97025c1dd19f3
                7f8a57e5becf724d6117f944f32dfd2c537eb6
                a71707f2caf99d5fec3942c6a8eabf01bf6fe7
            26/
                faaf98cb7fa0b67f6c21ec05e66a1a0d58f6df
            27/
                8aa8b6e069c248a9fa8e862160df3522f72490
            28/
                490804951ca2379eef543e09d33774aaf7c03d
                b11c8ff878a49ac376ae37bf90fbdd0867f9fd
            2b/
                d1a8c4d27e698f1d4a7fb0ccf740ccba9e0bb0
                e28921a5164a7d3303f0e4b9d9f60064497312
            2c/
                84c5f0271e2b9b60d6ddb7dc3613ba1318947d
            2d/
                5969610575477854886ba9c5337b27d53e7b98
            2e/
                554aea58c0b7517381f0b791b320618fa38741
            2f/
                5c318df42ef22665e8b3883ab0995c34c9c152
            32/
                a2f1d7c3a0098648db865c8a43145734105a54
            33/
                553de290aa47b662bd10bc4c0465e49417871b
                85f327eec533ce89a7c0f9d99f3fa55b13bfc1
            34/
                acf84b943010640f4727f2a296a120a4e8a23d
                cf0b22f1773b5abb5aec08c14d3a505c16820a
            35/
                787ecce228914a7dc7853da764c6018031171f
            36/
                6aa560f2e4a214353357c4e13a62f29db06698
            3b/
                73853b61d6b9ec56fce08faf1a6b13c43de708
            3c/
                7f426e275b4e36eafbbc3ce6480803799d0627
                ca4f42939b8b55b41f474b00f80a2ac4b12e19
            3f/
                3f2cf88bb0f031b4467df6e8eb2cf28ef2c0b2
            40/
                ce9e3e92d7ec70bf4a4bcf1e226a6f8e68455e
            41/
                91e9c28efc857d9e38282504a6883b783f1edb
            42/
                5ea9a9d53773298b442e11509a2d57a741b2e1
                eb763e0ece38b1215f8be9c3bde1120443530a
            45/
                ef01722ac6703062a7dec7409a89cd9658dde0
            48/
                759a3e0a804983d196dd99c15288485529ae37
            49/
                0a4bc15ef601fd87d8053ceea0e8f4d11fef21
            4b/
                bde34bb2277e6769b0fb3a68fd8f727eeb92b0
            4c/
                0102d3a30c29a0b9783a9bc98f6cc2df22c437
            4e/
                03021c64e6a581cf69c58efbbb6aaf5ecd9150
                34de3366d221cfca740f1eec1f60e6f57aafdd
                7dbfd6d82b7bf554606cf3153f359bb90a7130
            50/
                900869b9694bdb03dea6a4ad2a0fc34236eda9
            52/
                02e14cd2b70e2e2ba806138e4276661e7fedc0
            55/
                4d3f52ed1364084a75c59908138ae3759e5390
            58/
                7c65dee4dae69dfc89a4bf8d2b1f154c20c0f4
            59/
                af3be4ce712fa53f0cd23536da909a926781cb
            5c/
                d40444b54c0d25450446c984e05b013abcaf9e
            5d/
                53c1d45811ce68b7f636847b24c265edac4aa9
                6c9de058820d614c54e95f89b6a5ef5bfa838c
                8b3975a825da20c90f5bd5716bf04a71e72137
            5f/
                f8838fb273643ec4e2ad31dbe5ce43c0d14a4d
                fd3035ffc1581b030b233d5771b411f26743a6
            60/
                48c42317e6688acaec5ad95956fa9a35f9151e
            61/
                93ec381ed83aa0a2fb1814abd822b13ff9a5e6
                e3a853918d99c47e7f4e9f9f1d42500eec2d37
            62/
                1f4ded3fad645c84a3322a673d969a65618b58
                f4d920201442a6a49ad86bfe5194f55e2ffab2
            63/
                4e69da777824f8651e8b89c37d484690a1a5a9
                dfadf8ca1ae154f6a7c2a93eb0a1727cb16ae8
            64/
                6d3b814bfed4830e6f517f74dcac49c206788f
            65/
                a11b673be700f92321f1d6a5eb882f649df6c4
            66/
                97e6f137fcc3f95cc987e8cc903ac765af1219
            68/
                d37e178889acbb8090173d119b562bd6f8f6b6
            6c/
                3544130b3e70f5236e347a6d44cd9f18c7436d
                d073f322848b3e06d6f3710f6218e541f8815e
                f4667045caefa0c04b05ff25ff55feee6ddbed
            6e/
                fb3708f02457891a132b614ecb8f942c473916
            6f/
                b4c96ab0cfb834b1509791cf3d5771efdd5ec2
            70/
                38a8cc32e05294729d0890ab8a4e00eaa9e879
                a662e5cfc04e54d03558a74fd0442787ce26c5
                f890df21d31da4c543d034dbc246d8195002c4
            71/
                583ac0a9815a0816414460f4527d6ae94cb15b
            75/
                3ee19d72990b6575e562ba0c645c9853a5e124
                98bf9648f2ab234d41ff951afc3ab234e079ba
                e33cb3eb771900de8d9566499e83acb69bde0b
            77/
                0ea89a137c7f3ea9924df2dc39d49be9e8149e
                bfa9950891ecd1422495b0663d58c36f9e5b9b
                eff917ea2bc2cb514aafef15cd3b42b562fe84
            78/
                88adfc21ff849793f7fceb30745b8a277b0dcc
            79/
                f3abfd2fdd7ecb2dcac777212f1ebfd2a458b0
            7a/
                fa18feb94cc97978c939b7af2532770793a086
            7b/
                56ddcbc3680cf906dd187fccbd4ea7b68c8652
            7d/
                2dd0f6ddeaa800bd7dbf6738bbdc7a662660d6
                374a426b785d0ec47b935603faa6c1b7393720
                707687dfdbaa902e1fc28938073412e74f8632
                c75e6f22c2bd759820d87365887d193e6945fe
            7f/
                347f57a682ca9a7052751986da86cb8943ff1f
                5558172f2953e481884f0366005967f445004b
            80/
                18109aa5e88a5193dcd8aba56e02e7e00a1b4c
            81/
                7629d9c207975f06a6d4e2e5e9ab03e44845e5
                9da2dfb6059d1014e2cb2bc14456b0f71033e7
            83/
                10313fa5e3f056ff7c79ff8e29d6b11aa63051
            84/
                73cbeb90528ff0407e7f6293e6a81024e52092
            85/
                9696149e3f86700fc43c2dcc6b4ae6eb2c0556
            86/
                bd23671daa59a2a4ad0716a8aa430afbdf3797
                dd7796e77990867efd177b297fe16144e51bc5
            8a/
                1e495e2ef6c5de879151867481a78b5bbd8074
            8c/
                53465ea535f135ad16ed75ace76db63c810f8e
            8d/
                32b33dcdfb3d1b463f4b090f8f6ae3ae673999
                50b713b9cfd8c08800bf7bce63cce012c05d54
                6c4892cb5afbf6a1e9df3c831c6c4dd2d572c8
            8e/
                2fd03b4c9f45d1352e6c3cf94dc4cf985d5cd9
            91/
                36f0f2c774390d28b8d356fa83dc0ad0f07f99
            92/
                6fd1beea74c37c037f7c04552be91d4658e291
                99b2bd3e709bf810b3577082843929da659f87
                eaf69a137ab8ea93f671733673fbeb649db39f
            93/
                1060547b6b731a92efe25ba6d93b96261f3503
            95/
                01a8884ca2ef9b2bf2b1a7c8318f9917f8705c
                3c43e78acdfbabe411bbc21b0f85b86e0cc14b
                55d238e4f00b22e2645832e479e6901a9ffafc
            96/
                4d2ef9cb4ad995abdb5e5c6d1a2040a380199f
            97/
                c950bc7b01e6feb3a66f09580d3e70b61fafdf
            98/
                883b0cb7e91d28b034fc6526491f07a587f17c
                e9b8cceab5b9ce5b556b2ba4183eb8d409ff71
            9a/
                196c3d4c697833458c8421c2e11193fb5cb6e4
            9b/
                810333862d281f78afdc06c0611ad3c5218cd1
                ebae9186dfceb7c526ab83addbaf0c26e6ebfe
            9c/
                0281da34c6b9a37cf736d893d75ed837001b09
                6df79146c9d497ead103fb9027f7499ef6e816
            a0/
                6a35a49b58d7a516d22637da1b1db7d6cfa4bc
            a2/
                2a812df8a9a85a97c0a641ef6697667f44edad
                fc75f836c7bdd29ccef66dd97ea11d9043bd38
            a3/
                a0b5c3514231b4dba53c70200af5814dba26dc
            a4/
                89f6feb98520b4ca35470356fb33fbbc96bf3e
            a5/
                7085d27ab3da7b5245c2eac210a4d0f96c610f
            a9/
                f3c2239a72b76d46dad78b2bbd573957a3cfae
            ab/
                929ede334e40f15cf6e8ffa7db830904deafa7
            ac/
                620d6b8316f0f1798c861c07e896fddeca1fd0
            ad/
                0e50a5cf308d3694dda2b80d294471363d8c9d
            af/
                a3e18d5a2c8c65227ecb73e63cad1a87ec69f3
            b0/
                eb4b1f954ba02505a8b8226c3fb0b2abbebd34
            b1/
                558bf0db1b5bcb86d876269ceb02cf211364bc
                66c058d9097513b1adb84e0d99d413e96ed230
            b2/
                1ae9e043915124ea00fc5cf19b59f3b0332a53
                3baae7d5082155fc1a762ddd7c082118b01c46
            b4/
                61ec3355a842e92d174d9a397b68eea3402da7
            b7/
                1d4d5bd986cbb8371ec53d432f181858c64448
                7886e2dc67991f6bb96626a82b276c8d1163b0
            b9/
                730865f80944017c2239aaf3651086849b11e4
                7db54e3474e18ff3d92dc2408127b2b6e5531e
            bb/
                ce376d51b3a67fae3c59e0f9d097ec50083022
            be/
                4213efed25785a73402cd4bda074b77cee96ff
            bf/
                7dadb4310ac5b8a34280a8d0dfd390dbd38ec0
            c0/
                207c9d78d9e24e6748e1fb69f69cb102f8de29
            c1/
                b6a3cf069a9d2fbc751546ae36ae38bb775ad9
                cd2c8855df81df9f834b417e3dd5e7ff39bff3
            c4/
                a52ef327332de6c060d591e21e0c33ca86558a
            c6/
                4f20c3d71e7f5be3d6beafcd44c0942ee95b60
            c8/
                0cf582d03d9b7a7c955395c2167fd57efa3ea9
            c9/
                c985606f301bf7a1f431490eb6eac9e5637336
            ca/
                1819f68eedbf5ad6af5bb6f19f48afae379837
                270bdea2536df5c7532c0eaaba741067e10a83
                2c968f574091733b025c5e353c3ee8945388e8
                4ae4e94d8eb68439657169437d241927c69ca7
            cb/
                c976ec0968176400b42254eb9899da907dcf3c
            cd/
                201dfd41304ad1cd335a50bf0786ec9d75cf64
                699b089645c967198742c6c7d4e74d67abf37e
            ce/
                6db42359cd9f05cb6336a5fb584f414604d0a2
                b9e7831cad9ca380d0b776787d8c2a8bd08576
            d1/
                12defc5f664db2e88e34d83db4f5580fb552b8
                287ab8825496d0678994eb009df60136051e84
                684ee06e4d1c467a6c9c80fc9ebc88aabd249c
            d2/
                410b2d71512bca8448471068644e388635e3f2
                f1be81e8649f0751ff7363d180cd3516e29589
            d5/
                2a294795ee55c02eda0d1bd159f17f482fe38b
                8c8de5c4d3b66d4561428436f33242325d1209
                970c1a8fda3a5e045c87a306b02d63c313cbf6
            d7/
                060f9f16f56b16f12e651993be61c445f4ae00
                f2e139e0a0ddd3b0f2f03f759acf93b3105d9b
            d9/
                1258eaa5bed9ce1e0a182326310e34a8e3cb37
                34802498cddcdd4ce7c67422790f0b678b1042
                d9a24f376419e76229ba42ce10153c646264e6
            da/
                41442fffd6c2daff3dac068cec33b29cb58de8
                8700f6d35deaa6abb61515a6caf920178cb4e2
            dc/
                2f3f356258eb4185fd056b0fba5a216b1c3c08
                3965d7ed8231c9b570092a102e4e98c10d7048
                b4c419ce0c4b6e477f8b1cd12059a7622d4295
            dd/
                d53bb57185d659577bca1af380664bc68f6337
                ea6ae40ff0f92e2eec955b46e2a70a5bbc8dd6
            de/
                99a67b77189d8d5003572afbf297e3c7b1762d
            e0/
                f24c0d705f0bfd3401560340d6717cd113a3bb
            e2/
                24a2ea54d5bc14bec2e519907e51e5e921d922
                37e34038a7b9650cf0f4dbde8be2054bd85796
            e3/
                9b4dd7e973491dec9542df96a4d23daef3777a
            e4/
                63e7687eb61b4cf5938bc29b8b1de58198d1b3
                d955c0bc16d32e0ae9ccd1a85255155ae4afff
            e6/
                9de29bb2d1d6434b8b29ae775ad8c2e48c5391
            ea/
                282ff4d9b37b7f089aa8edefeb711b44cd4e9e
            ec/
                e76b35b8836cf1420019856aa139cb3f6764d8
            ed/
                dba2a3acca50f0519331eb2a3e6606fbf336c6
            f0/
                c7b9d7cd5b86fff6c71b981fd84d056a681e8c
                d9e15ef31dbd764e8bc113106fdcdb452d374a
            f5/
                43afbe0c503d2bfcc021bc053fa053bfdf74b5
                9eff8f0fafbc9b0a295075ed2ae96019d08264
            f6/
                55da995f26f0c12507152359dcb4eb0e9c80bd
            f7/
                bb2af30778f669d161d743db1a1c803f356d60
                cbf83ad6da952d8481ff6a5de72e9127cd1f47
                de9117bfaf1038ed8a1920b2d497b56e010ac2
            fa/
                de3c3478167b9f06062f40736cee1112c13561
            fb/
                14ac1839cb832dbe6018146e7f6996ad365601
                393e0f6933894680d97eaa425932235b425943
            fe/
                0b667362b519a676db6cbf262e84f1df537b57
            ff/
                4135fba30626c0669f1d8495c27531f2b1062a
            info/
            pack/
        refs/
            heads/
                main
            remotes/
                origin/
                    main
            tags/
    assets/
        audio/
            bgm_battle.mp3
            bgm_builder.mp3
            bgm_profile.mp3
            bgm_title.mp3
            placeholder.txt
            sfx_card_discard.mp3
            sfx_card_draw.mp3
            sfx_click.mp3
            sfx_deck_save.mp3
            sfx_error.mp3
            sfx_game_over_win.mp3
            sfx_hover.mp3
        images/
            avatars/
                avatar1.png
                avatar2.png
                avatar3.png
                default.png
            cards/
                arcane_familiar.png
                bounce.png
                card_cover.png
                crystal_golem.png
                destroy.png
                destroy_binding.png
                draw.png
                draw_rune.png
                dwarf_guardian.png
                elf_ranger.png
                feral_bear.png
                fireball.png
                firebrand_zealot.png
                ghoul_devourer.png
                heal.png
                human_duelist.png
                molten_wyrm.png
                plague_rat.png
                power_boost.png
                shadowblade_assassin.png
                shield.png
                soul_revenant.png
                stonecaller.png
                storm_elemental.png
                toughness_boost.png
                volcanic_behemoth.png
                weaken.png
                wisp_of_light.png
            favicon/
                android-chrome-192x192.png
                android-chrome-512x512.png
                apple-touch-icon.png
                favicon-16x16.png
                favicon-32x32.png
                favicon.ico
            news/
                booster_news.png
                pack_sombras.png
                tournament_banner.png
            printscreens/
                01.png
                02.png
                03.png
                04.png
                05.png
                06.png
                07.png
                08.png
            ui/
                battle_background.jpg
                connect_background.jpg
                create_account_background.jpg
                cursor.png
                deck_background.jpg
                graveyard.png
                home_background.jpg
                host.png
                join.png
                login_background.jpg
                logo_placeholder.png
                logo_small_placeholder.png
                options_background.jpg
                placeholder.txt
                profile_background.jpg
                runebound_logo.png
                SplashCreenLogo.png
                title_background.jpg
    css/
        animations.css
        cards.css
        style.css
    js/
        config.js
        main.js
        utils.js
        account/
            AccountManager.js
        audio/
            AudioManager.js
        core/
            Battlefield.js
            Card.js
            CombatManager.js
            CreatureCard.js
            Deck.js
            Game.js
            Graveyard.js
            Hand.js
            InstantCard.js
            Player.js
            RunebindingCard.js
            TurnManager.js
        data/
            card-definitions.json
            news-data.json
        network/
            NetworkManager.js
        ui/
            ScreenManager.js
            templates.js
            UIManager.js
            helpers/
                CardRenderer.js
                ZoomHandler.js
            html-templates/
                battleScreenTemplate.js
                connectScreenTemplate.js
                createAccountScreenTemplate.js
                deckBuilderScreenTemplate.js
                deckManagementScreenTemplate.js
                homeScreenTemplate.js
                loginScreenTemplate.js
                optionsScreenTemplate.js
                profileScreenTemplate.js
                splashScreenTemplate.js
                titleScreenTemplate.js
                topBarTemplate.js
            screens/
                BattleScreenUI.js
                DeckBuilderUI.js
                DeckManagementScreenUI.js
                HomeScreenUI.js
                OptionsUI.js
                ProfileScreenUI.js

### CONTEÚDO DOS SCRIPTS ###

--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\config.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\config.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\main.js ---
// js/main.js - ATUALIZADO (v2.5 - AudioManager + Splash Fix)

// --- Imports ---
// Core Modules
import Game from './core/Game.js';
import UIManager from './ui/UIManager.js';
import ScreenManager from './ui/ScreenManager.js';
import AccountManager from './account/AccountManager.js';
import AudioManager from './audio/AudioManager.js'; // <<<=== Importado AudioManager
import { loadCardDefinitions } from './utils.js';

// --- HTML Template Imports ---
import { generateSplashScreenHTML } from './ui/html-templates/splashScreenTemplate.js';
import { generateTitleScreenHTML } from './ui/html-templates/titleScreenTemplate.js';
import { generateLoginScreenHTML } from './ui/html-templates/loginScreenTemplate.js';
import { generateCreateAccountScreenHTML } from './ui/html-templates/createAccountScreenTemplate.js';
import { generateHomeScreenHTML } from './ui/html-templates/homeScreenTemplate.js';
import { generateProfileScreenHTML } from './ui/html-templates/profileScreenTemplate.js';
import { generateDeckManagementScreenHTML } from './ui/html-templates/deckManagementScreenTemplate.js';
import { generateConnectScreenHTML } from './ui/html-templates/connectScreenTemplate.js';
import { generateDeckBuilderScreenHTML } from './ui/html-templates/deckBuilderScreenTemplate.js';
import { generateOptionsScreenHTML } from './ui/html-templates/optionsScreenTemplate.js';
import { generateBattleScreenHTML } from './ui/html-templates/battleScreenTemplate.js';
import { generateTopBarHTML } from './ui/html-templates/topBarTemplate.js';


// --- Document Ready ---
$(document).ready(async () => { // Marcado como async para permitir awaits internos
    console.log("Runebound Clash - Initializing (Dynamic HTML)...");

    // --- STEP 1: Build HTML Structure Dynamically ---
    console.log("MAIN: Generating HTML structure...");
    const $screensContainer = $('#screens-container'); // Container principal das telas
    const $body = $('body');                           // Body para adicionar a Top Bar

    // Verificação crítica: garante que o container existe
    if (!$screensContainer.length) {
        console.error("CRITICAL ERROR: #screens-container div not found in index.html! Cannot generate UI.");
        $body.empty().css({
            'background-color': '#333', 'color': 'red', 'display': 'flex',
            'justify-content': 'center', 'align-items': 'center', 'height': '100vh',
            'font-size': '1.5em', 'padding': '20px', 'text-align': 'center'
        }).html('<h1>Erro Crítico</h1><p>A estrutura base do HTML (index.html) parece estar faltando o elemento <code><div id="screens-container"></div></code>. A aplicação não pode iniciar.</p>');
        return; // Para a execução
    }

    try {
        // Gera e anexa o HTML de cada tela ao container
        $screensContainer.empty() // Limpa qualquer conteúdo estático
            .append(generateSplashScreenHTML())          // Splash Screen PRIMEIRO
            .append(generateTitleScreenHTML())           // Tela de Título
            .append(generateLoginScreenHTML())           // Tela de Login
            .append(generateCreateAccountScreenHTML())   // Tela de Criar Conta
            .append(generateHomeScreenHTML())            // Tela Inicial (Notícias)
            .append(generateProfileScreenHTML())         // Tela de Perfil (Simplificada)
            .append(generateDeckManagementScreenHTML()) // Adiciona Nova Tela de Decks/Coleção
            .append(generateConnectScreenHTML())         // Tela de Conexão
            .append(generateDeckBuilderScreenHTML())     // Tela do Construtor de Decks
            .append(generateOptionsScreenHTML())         // Tela de Opções
            .append(generateBattleScreenHTML());         // Tela de Batalha

        // Adiciona a Top Bar no início do body, fora do container de telas
        $body.prepend(generateTopBarHTML());

        console.log("MAIN: HTML Structure dynamically generated.");

    } catch (htmlGenError) {
         console.error("MAIN: Critical error during HTML generation from templates:", htmlGenError);
         // Tenta mostrar erro na splash screen ou no container principal
         const $splash = $('#splash-screen');
         if ($splash.length && ($splash.hasClass('active') || $screensContainer.children().length <= 1)) {
             $splash.addClass('active').html(`<p style="color:red; font-weight:bold;">Erro Crítico na Geração da UI: ${htmlGenError.message}. Recarregue.</p>`);
             $('.screen').not($splash).removeClass('active');
         } else {
             $screensContainer.html(`<p style="color:red; font-weight:bold;">Erro Crítico na Geração da UI: ${htmlGenError.message}. Recarregue.</p>`);
         }
         return; // Para a execução
    }
    // --- END STEP 1 ---


    // --- STEP 2: Initialize Modules and Logic ---
    console.log("MAIN: Initializing modules and binding events...");
    try { // Envolve a inicialização principal em try...catch
        // --- Module Initialization ---
        const cardDatabase = loadCardDefinitions(); // Carrega definições de cartas
        if (!cardDatabase) {
            // Trata erro crítico se as cartas não puderem ser carregadas
            const $splashError = $('#splash-screen');
             if ($splashError.length && ($splashError.hasClass('active') || $screensContainer.children().length <= 1)) {
                 $splashError.text('Erro Crítico: Falha ao carregar cartas. Recarregue.').css('color', 'salmon');
                 $('.screen').not($splashError).removeClass('active');
             } else {
                 console.error("CRITICAL: Failed to load card definitions AND splash screen not found/active!");
                 $screensContainer.html('<p style="color:red; font-weight:bold;">Erro Crítico: Falha ao carregar cartas.</p>');
             }
            console.error("CRITICAL: Failed to load card definitions!");
            return; // Para a execução
        }

        // Inicializa os gerenciadores APÓS o HTML ser gerado
        const screenManager = new ScreenManager();
        const accountManager = new AccountManager();
        const audioManager = new AudioManager(); // <<<=== Instancia AudioManager
        // UIManager agora recebe AudioManager
        const uiManager = new UIManager(screenManager, accountManager, cardDatabase, audioManager); // <<<=== Passado para UIManager

        // --- Initial Screen & Splash Transition ---
        console.log("MAIN: Showing splash screen...");
        setTimeout(() => $('#splash-screen').addClass('loading'), 50);

        console.log("MAIN: Setting timeout for screen transition (3000ms)...");
        setTimeout(async () => {
            console.log("MAIN: Timeout finished. Checking login state...");
            const $splashScreen = $('#splash-screen');
            let initialScreenId = 'title-screen'; // Tela padrão se não logado

            try {
                const currentUser = accountManager.getCurrentUser();
                if (currentUser) {
                    // --- Logged In Flow ---
                    console.log(`MAIN: User '${currentUser.username}' found. Showing Top Bar and Home Screen.`);
                    uiManager.showTopBar(currentUser);
                    $('#screens-container').addClass('with-top-bar');

                    // Remove 'active' da splash ANTES de mostrar a próxima
                    if ($splashScreen.hasClass('active')) {
                        $splashScreen.removeClass('active loading');
                        console.log("MAIN: Splash screen deactivated for logged-in flow.");
                    }

                    await uiManager.renderHomeScreen();
                    screenManager.showScreen('home-screen');
                    initialScreenId = 'home-screen'; // Atualiza tela inicial para tocar BGM correta

                } else {
                    // --- Logged Out Flow ---
                    console.log("MAIN: No user found. Showing title-screen.");
                    uiManager.hideTopBar();
                    $('#screens-container').removeClass('with-top-bar');

                    // Remove 'active' da splash ANTES de mostrar a próxima
                    if ($splashScreen.hasClass('active')) {
                        $splashScreen.removeClass('active loading');
                        console.log("MAIN: Splash screen deactivated for logged-out flow.");
                    }

                    screenManager.showScreen('title-screen');
                    initialScreenId = 'title-screen'; // Confirma tela inicial para tocar BGM
                }

                // <<<=== Tocar BGM inicial AQUI ===>>>
                console.log(`MAIN: Playing initial BGM for screen: ${initialScreenId}`);
                audioManager.playBGM(initialScreenId);
                // <<<==============================>>>

                console.log("MAIN: Initial screen setup complete.");
            } catch (error) {
                console.error("MAIN: Error inside setTimeout callback:", error);
                // Fallback
                console.log("MAIN: Fallback - Showing title-screen due to error.");
                 uiManager.hideTopBar();
                 $('#screens-container').removeClass('with-top-bar');

                 // Garante que splash saia no fallback também
                 if ($splashScreen.hasClass('active')) {
                    $splashScreen.removeClass('active loading');
                    console.log("MAIN: Splash screen deactivated on error fallback.");
                 }

                screenManager.showScreen('title-screen');
                // Tocar BGM da title screen no fallback
                audioManager.playBGM('title-screen');
            }
        }, 3000); // Delay


        // --- Global UI Bindings ---
        // Adiciona listeners de áudio aos botões da Title Screen
        const addTitleAudioListeners = ($element, sfxClick = 'buttonClick', sfxHover = 'buttonHover') => {
            $element.off('click.titleaudio').on('click.titleaudio', () => audioManager?.playSFX(sfxClick));
            $element.off('mouseenter.titleaudio').on('mouseenter.titleaudio', () => audioManager?.playSFX(sfxHover));
        };

        // Ações da Tela de Título
        const $btnLogin = $('#btn-goto-login');
        $btnLogin.on('click', () => screenManager.showScreen('login-screen'));
        addTitleAudioListeners($btnLogin);

        const $btnCreate = $('#btn-goto-create-account');
        $btnCreate.on('click', () => screenManager.showScreen('create-account-screen'));
        addTitleAudioListeners($btnCreate);

        const $btnOptionsIcon = $('#btn-goto-options-icon');
        $btnOptionsIcon.on('click', () => {
             uiManager.renderOptionsScreen();
             screenManager.showScreen('options-screen');
             audioManager.playBGM('options-screen'); // Toca BGM ao ir para opções
        });
        addTitleAudioListeners($btnOptionsIcon);

        // Botões "Voltar" das telas de Login/Criar Conta
        const $btnBackToTitle = $('#btn-create-back-to-title, #btn-login-back-to-title');
        $btnBackToTitle.on('click', () => {
            $('#create-account-message, #login-message').text('');
            screenManager.showScreen('title-screen');
            audioManager.playBGM('title-screen'); // Toca BGM ao voltar
        });
        $btnBackToTitle.each((i, btn) => addTitleAudioListeners($(btn)));


        // Submissão do Formulário de Criar Conta
        $('#create-account-form').on('submit', (event) => {
            event.preventDefault();
            audioManager.playSFX('buttonClick'); // Som de clique no submit
            const $form = $(event.currentTarget);
            const u = $('#create-username').val().trim();
            const p = $('#create-password').val();
            const $m = $('#create-account-message');
            const r = accountManager.createAccount(u, p);
            $m.text(r.message).css('color', r.success ? 'lightgreen' : 'salmon');

            if (r.success) {
                $form[0].reset();
                setTimeout(() => {
                    if (screenManager.getActiveScreenId() === 'create-account-screen') {
                        screenManager.showScreen('login-screen');
                        $m.text('');
                    }
                 }, 2000);
            } else {
                // Efeito de "shake"
                const $container = $form.closest('.form-container');
                if ($container.length) {
                    $container.addClass('form-shake');
                    setTimeout(() => $container.removeClass('form-shake'), 600);
                }
                audioManager.playSFX('createAccountError'); // <<<=== Toca SFX de erro
            }
        });
        // Adiciona hover aos botões do form
        $('#create-account-form button').each((i, btn) => addTitleAudioListeners($(btn)));


        // Submissão do Formulário de Login
        $('#login-form').on('submit', async (event) => {
            event.preventDefault();
            audioManager.playSFX('buttonClick'); // Som de clique no submit
            const $form = $(event.currentTarget);
            const u = $('#login-username').val().trim();
            const p = $('#login-password').val();
            const $m = $('#login-message');
            const r = accountManager.login(u, p);
            $m.text(r.message).css('color', r.success ? 'lightgreen' : 'salmon');

            if (r.success) {
                $form[0].reset();
                // --- Login Success Flow ---
                uiManager.showTopBar(r.user);
                $('#screens-container').addClass('with-top-bar');
                await uiManager.renderHomeScreen();
                screenManager.showScreen('home-screen');
                audioManager.playBGM('home-screen'); // Toca BGM da Home após login
                // --- Fim Login Success Flow ---
            } else {
                // Efeito de "shake"
                const $container = $form.closest('.form-container');
                if ($container.length) {
                    $container.addClass('form-shake');
                    setTimeout(() => $container.removeClass('form-shake'), 600);
                }
                audioManager.playSFX('loginError'); // <<<=== Toca SFX de erro
            }
        });
         // Adiciona hover aos botões do form
         $('#login-form button').each((i, btn) => addTitleAudioListeners($(btn)));


        // --- Top Bar Navigation ---
        // Tratada em UIManager._bindPermanentUIActions, que agora toca BGM/SFX

        // --- Other Screen Back Buttons ---
         const $btnOptionsBack = $('#btn-options-back-to-main');
         $btnOptionsBack.on('click', () => {
              screenManager.goBack('home-screen');
              // AudioManager tocará a BGM correta baseado na tela que for mostrada
              // É mais seguro deixar o handler de navegação (UIManager) controlar a BGM
         });
         addTitleAudioListeners($btnOptionsBack); // Adiciona sons básicos

         const $btnDeckBuilderBack = $('#btn-deck-builder-back');
         $btnDeckBuilderBack.on('click', () => {
             console.log("MAIN: Deck Builder back button clicked, going to Deck Management.");
             uiManager.renderDeckManagementScreen();
             screenManager.showScreen('deck-management-screen');
             audioManager.playBGM('deck-management-screen'); // Toca BGM dos decks
         });
         addTitleAudioListeners($btnDeckBuilderBack);

         const $btnConnectBack = $('#btn-connect-back-to-main');
         $btnConnectBack.on('click', () => {
              screenManager.showScreen('home-screen');
              audioManager.playBGM('home-screen'); // Toca BGM da Home
         });
         addTitleAudioListeners($btnConnectBack);


        // Botão Salvar Opções
         const $btnSaveOptions = $('#btn-save-options');
         $btnSaveOptions.on('click', () => {
             uiManager.saveOptions(); // UIManager agora chama save e atualiza audioManager
             // O som de clique é adicionado abaixo
         });
         addTitleAudioListeners($btnSaveOptions); // Adiciona som básico


        // --- Game Initialization Logic & Connect Screen Bindings ---
        let gameInstance = null;

        /** Função para inicializar e começar uma nova partida (Simulada/Local) */
        function initializeAndStartGame(localPlayerDeckId, opponentUsername = "Opponent_AI", opponentDeckId = 'default_deck_1') {
             console.log("MAIN: Initializing game...");
             const currentUser = accountManager.getCurrentUser();
             if (!currentUser) { /* ... (erro login) ... */ return; }

             const localDecks = accountManager.loadDecks();
             const localDeck = localDecks?.[localPlayerDeckId];

             // Valida deck local
             if (!localDeck?.cards || localDeck.cards.length < 30 || localDeck.cards.length > 40) {
                 console.error(`MAIN: Local deck '${localDeck?.name || localPlayerDeckId}' is invalid (needs 30-40 cards). Found: ${localDeck?.cards?.length}`);
                 $('#connect-message').text(`Erro: Deck '${localDeck?.name || localPlayerDeckId}' inválido (precisa de 30-40 cartas).`).css('color', 'salmon');
                 audioManager.playSFX('genericError'); // Som de erro genérico
                 return;
             }
             const localPlayerDeckIds = localDeck.cards;
             console.log(`MAIN: Local Deck '${localDeck.name}' (${localPlayerDeckIds.length} cards) found.`);

             // Simulação/Fallback de Deck do Oponente
             let opponentDeckIds = accountManager.getUserData("Opponent_AI")?.decks?.[opponentDeckId]?.cards;
             if (!opponentDeckIds || opponentDeckIds.length < 30) {
                 console.warn(`MAIN: Opponent deck '${opponentDeckId}' invalid or not found, using fallback.`);
                 const allCardIds = Object.keys(cardDatabase);
                 if (allCardIds.length >= 30) {
                     opponentDeckIds = allCardIds.sort(() => 0.5 - Math.random()).slice(0, 30);
                     console.log(`MAIN: Using fallback opponent deck with 30 random cards.`);
                 } else {
                     console.error("MAIN: Cannot create fallback opponent deck! Insufficient card definitions.");
                     $('#connect-message').text('Erro Crítico: Definições de cartas insuficientes para o oponente.').css('color', 'salmon');
                     audioManager.playSFX('genericError');
                     return;
                 }
             } else {
                 console.log(`MAIN: Using opponent deck '${opponentDeckId}'.`);
             }
             console.log(`MAIN: Preparing ${currentUser.username} vs ${opponentUsername}`);

             // Inicia a instância do Jogo
             try {
                 gameInstance = new Game(cardDatabase);
                 const player1 = gameInstance.addPlayer(currentUser.username, localPlayerDeckIds);
                 const player2 = gameInstance.addPlayer(opponentUsername, opponentDeckIds);

                 if (!player1 || !player2) {
                      throw new Error("Falha ao adicionar jogadores. Verifique os decks e logs.");
                 }

                 uiManager.setGameInstance(gameInstance);
                 uiManager.setLocalPlayer(player1.id);

                 if (gameInstance.setupGame()) {
                     gameInstance.startGame();
                     uiManager.renderInitialGameState();
                     console.log("MAIN: Game started successfully!");
                     $('#connect-message').text('');
                     screenManager.showScreen('battle-screen');
                     audioManager.playBGM('battle-screen'); // <<<=== Toca BGM da Batalha
                 } else {
                     throw new Error("Falha na configuração inicial do jogo.");
                 }
             } catch (error) {
                 console.error("MAIN: Error during game initialization:", error);
                 $('#connect-message').text(`Erro ao iniciar: ${error.message}`).css('color', 'salmon');
                 audioManager.playSFX('genericError'); // Som de erro
                 gameInstance = null;
             }
        } // Fim de initializeAndStartGame

        // Botões da Tela Connect (Simulando Início de Jogo)
         const $btnCreateServer = $('#btn-create-server');
         $btnCreateServer.on('click', () => {
            $('#join-game-section').hide(); $('#server-status-section').show(); $('#server-ip-code').text('SIMULANDO...'); $('#connect-message').text('Simulando... Iniciando Jogo Solo.');
            const decks = accountManager.loadDecks();
            const firstValidDeckId = decks ? Object.keys(decks).find(id => decks[id]?.cards?.length >= 30 && decks[id]?.cards?.length <= 40) : null;
            if (!firstValidDeckId) {
                 $('#connect-message').text('Erro: Nenhum deck válido (30-40 cartas). Crie/Edite nos Decks.').css('color', 'salmon');
                 $('#server-status-section').hide();
                 audioManager.playSFX('genericError');
                 return;
            }
            setTimeout(() => initializeAndStartGame(firstValidDeckId), 500);
        });
         addTitleAudioListeners($btnCreateServer); // Adiciona sons básicos

         const $btnShowJoin = $('#btn-show-join-options');
         $btnShowJoin.on('click', () => {
             $('#server-status-section').hide();
             $('#join-game-section').show();
             $('#connect-message').text('');
         });
         addTitleAudioListeners($btnShowJoin);

         const $btnConnectServer = $('#btn-connect-to-server');
         $btnConnectServer.on('click', () => {
            const code = $('#opponent-ip').val().trim();
            $('#connect-message').text(`Simulando conexão com ${code || 'host'}... Iniciando Jogo Solo.`);
            const decks = accountManager.loadDecks();
            const firstValidDeckId = decks ? Object.keys(decks).find(id => decks[id]?.cards?.length >= 30 && decks[id]?.cards?.length <= 40) : null;
             if (!firstValidDeckId) {
                 $('#connect-message').text('Erro: Nenhum deck válido (30-40 cartas). Crie/Edite nos Decks.').css('color', 'salmon');
                 audioManager.playSFX('genericError');
                 return;
             }
            setTimeout(() => initializeAndStartGame(firstValidDeckId), 500);
        });
         addTitleAudioListeners($btnConnectServer);

        const $btnCancelHost = $('#btn-cancel-hosting');
        $btnCancelHost.on('click', () => {
             $('#server-status-section').hide();
             $('#connect-message').text('Criação cancelada.');
         });
         addTitleAudioListeners($btnCancelHost);


        // --- Final Log ---
        console.log("Runebound Clash UI Ready (v2.5 - AudioManager).");

    } catch (initError) {
        console.error("MAIN: Critical initialization error:", initError);
         // Mostra erro crítico na splash screen ou no container
         const $splashSevereError = $('#splash-screen');
         if ($splashSevereError.length && ($splashSevereError.hasClass('active') || $screensContainer.children().length <= 1)) {
              $splashSevereError.text(`Erro Crítico: ${initError.message}. Recarregue.`).css('color', 'red');
              $('.screen').removeClass('active');
              $splashSevereError.addClass('active');
         } else {
            $screensContainer.html(`<p style="color:red; font-weight:bold;">Erro Crítico de Inicialização: ${initError.message}. Recarregue.</p>`);
         }
    }
}); // --- END Document Ready ---
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\main.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\utils.js ---
// js/utils.js

/**
 * Shuffles an array in place using the Fisher-Yates (Durstenfeld variation) algorithm.
 * @param {Array<any>} array The array to shuffle.
 * @returns {Array<any>} The shuffled array (the same instance passed in).
 */
export function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        // Generate random index from 0 to i (inclusive)
        const j = Math.floor(Math.random() * (i + 1));
        // Swap elements array[i] and array[j]
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/** Simple counter for generating unique IDs within a session. */
let uniqueInstanceCounter = 0;

/**
 * Generates a simple unique ID string. Useful for card instances/players within a game session.
 * Format: type_<timestamp>_<counter>
 * Not guaranteed to be unique across different sessions or globally.
 * @param {string} [prefix='instance'] - Optional prefix for the ID.
 * @returns {string} A unique ID string.
 */
export function generateUniqueId(prefix = 'instance') {
    uniqueInstanceCounter++;
    return `${prefix}_${Date.now()}_${uniqueInstanceCounter}`;
}

/**
 * Loads card definitions.
 * In a real app, this would likely fetch a JSON file.
 * For now, it uses the provided JSON structure.
 * IMPORTANT: Add unique 'id' fields to your card definitions JSON!
 * @returns {object | null} An object mapping card IDs to definitions, or null on error.
 */
export function loadCardDefinitions() {
    // --- PASTE YOUR CARD JSON DATA HERE ---
    // IMPORTANT: Make sure each card object has a unique "id" field (e.g., "CR001", "RB001")
    const cardDataJson = {
        "cards": [
             { "id": "CR001", "name": "Elven Ranger", "type": "Creature", "cost": 2, "attack": 2, "toughness": 2, "tribe": "Elf", "image_src": "assets/images/cards/elf_ranger.png", "description": "Quick and agile, ideal for early pressure." },
             { "id": "CR002", "name": "Dwarven Guardian", "type": "Creature", "cost": 3, "attack": 1, "toughness": 4, "tribe": "Dwarf", "image_src": "assets/images/cards/dwarf_guardian.png", "description": "A stalwart defender that protects allies." },
             { "id": "CR003", "name": "Plague Rat", "type": "Creature", "cost": 1, "attack": 1, "toughness": 1, "tribe": "Beast", "image_src": "assets/images/cards/plague_rat.png", "description": "A disposable creature." },
             { "id": "CR004", "name": "Molten Wyrm", "type": "Creature", "cost": 6, "attack": 5, "toughness": 4, "tribe": "Dragon", "image_src": "assets/images/cards/molten_wyrm.png", "description": "A powerful finisher." },
             { "id": "CR005", "name": "Soul Revenant", "type": "Creature", "cost": 4, "attack": 3, "toughness": 2, "tribe": "Undead", "image_src": "assets/images/cards/soul_revenant.png", "description": "Hard to kill." },
             { "id": "CR006", "name": "Storm Elemental", "type": "Creature", "cost": 5, "attack": 4, "toughness": 3, "tribe": "Elemental", "image_src": "assets/images/cards/storm_elemental.png", "description": "An elemental creature." },
             { "id": "CR007", "name": "Human Duelist", "type": "Creature", "cost": 2, "attack": 3, "toughness": 1, "tribe": "Human", "image_src": "assets/images/cards/human_duelist.png", "description": "Simple, fast, and deadly." },
             { "id": "CR008", "name": "Crystal Golem", "type": "Creature", "cost": 4, "attack": 2, "toughness": 5, "tribe": "Construct", "image_src": "assets/images/cards/crystal_golem.png", "description": "Solid magical defense unit." },
             { "id": "CR009", "name": "Feral Bear", "type": "Creature", "cost": 3, "attack": 3, "toughness": 3, "tribe": "Beast", "image_src": "assets/images/cards/feral_bear.png", "description": "Balanced creature." },
             { "id": "CR010", "name": "Firebrand Zealot", "type": "Creature", "cost": 2, "attack": 2, "toughness": 1, "tribe": "Human", "image_src": "assets/images/cards/firebrand_zealot.png", "description": "Fierce attacker." },
             { "id": "CR011", "name": "Wisp of Light", "type": "Creature", "cost": 1, "attack": 1, "toughness": 1, "tribe": "Spirit", "image_src": "assets/images/cards/wisp_of_light.png", "description": "Tiny, but helpful." },
             { "id": "CR012", "name": "Ghoul Devourer", "type": "Creature", "cost": 4, "attack": 4, "toughness": 2, "tribe": "Undead", "image_src": "assets/images/cards/ghoul_devourer.png", "description": "Feeds on the fallen." },
             { "id": "CR013", "name": "Stonecaller", "type": "Creature", "cost": 5, "attack": 2, "toughness": 6, "tribe": "Dwarf", "image_src": "assets/images/cards/stonecaller.png", "description": "A support tank." },
             { "id": "CR014", "name": "Shadowblade Assassin", "type": "Creature", "cost": 3, "attack": 3, "toughness": 1, "tribe": "Elf", "image_src": "assets/images/cards/shadowblade_assassin.png", "description": "Strike fast." },
             { "id": "CR015", "name": "Volcanic Behemoth", "type": "Creature", "cost": 7, "attack": 7, "toughness": 7, "tribe": "Elemental", "image_src": "assets/images/cards/volcanic_behemoth.png", "description": "Massive threat." },
             { "id": "CR016", "name": "Arcane Familiar", "type": "Creature", "cost": 2, "attack": 1, "toughness": 2, "tribe": "Spirit", "image_src": "assets/images/cards/arcane_familiar.png", "description": "Helpful spirit." },
             { "id": "RB001", "name": "Destroy", "type": "Runebinding", "cost": 2, "effect": "Destroy target creature", "image_src": "assets/images/cards/destroy.png", "description": "Eliminates a threat." },
             { "id": "RB_DRAW2", "name": "Draw Rune", "type": "Runebinding", "cost": 2, "effect": "Draw 2 cards", "image_src": "assets/images/cards/draw_rune.png", "description": "Expands your options." }, // Changed ID slightly
             { "id": "RB_SILENCE", "name": "Silence", "type": "Runebinding", "cost": 1, "effect": "Target creature can't attack next turn", "image_src": "assets/images/cards/silence.png", "description": "Temporarily disables a unit." }, // Changed ID
             { "id": "RB_POWER", "name": "Power Boost", "type": "Runebinding", "cost": 1, "effect": "Target creature gains +2 attack this turn", "image_src": "assets/images/cards/power_boost.png", "description": "Extra punch." }, // Changed ID
             { "id": "RB_TOUGH", "name": "Toughness Boost", "type": "Runebinding", "cost": 1, "effect": "Target creature gains +2 toughness this turn", "image_src": "assets/images/cards/toughness_boost.png", "description": "Extra defense." }, // Changed ID
             { "id": "IS001", "name": "Heal", "type": "Instant", "cost": 2, "effect": "Restore 4 life", "image_src": "assets/images/cards/heal.png", "description": "A burst of recovery." },
             { "id": "IS002", "name": "Fireball", "type": "Instant", "cost": 2, "effect": "Deal 3 damage to target creature", "image_src": "assets/images/cards/fireball.png", "description": "Burns a creature." },
             { "id": "IS003", "name": "Draw", "type": "Instant", "cost": 1, "effect": "Draw 2 cards", "image_src": "assets/images/cards/draw.png", "description": "Refill your hand." },
             { "id": "IS004", "name": "Shield", "type": "Instant", "cost": 1, "effect": "Prevent all damage to a creature this turn", "image_src": "assets/images/cards/shield.png", "description": "Protect a key creature." },
             { "id": "IS005", "name": "Bounce", "type": "Instant", "cost": 3, "effect": "Return target creature to its owner's hand", "image_src": "assets/images/cards/bounce.png", "description": "Reset an enemy creature." },
             { "id": "IS006", "name": "Destroy Binding", "type": "Instant", "cost": 2, "effect": "Destroy target Runebinding", "image_src": "assets/images/cards/destroy_binding.png", "description": "Dispel enchantments." },
             { "id": "IS007", "name": "Weaken", "type": "Instant", "cost": 1, "effect": "Target creature gets -2 attack this turn", "image_src": "assets/images/cards/weaken.png", "description": "Debilitate the enemy." }
        ]
    };
    // --- END OF CARD JSON DATA ---

    try {
        const cardDatabase = {};
        if (!cardDataJson || !Array.isArray(cardDataJson.cards)) {
            throw new Error("Invalid card data structure.");
        }
        cardDataJson.cards.forEach(cardDef => {
            if (!cardDef.id) {
                console.warn(`Card "${cardDef.name}" is missing a unique 'id' field. Skipping.`);
                return; // Skip cards without an ID
            }
            if (cardDatabase[cardDef.id]) {
                console.warn(`Duplicate card ID "${cardDef.id}" found for card "${cardDef.name}". Overwriting previous entry.`);
            }
            cardDatabase[cardDef.id] = cardDef;
        });

        if (Object.keys(cardDatabase).length === 0) {
             console.warn("Card database loaded, but is empty or all cards lacked IDs.");
        } else {
            console.log(`Card definitions loaded successfully: ${Object.keys(cardDatabase).length} cards.`);
        }
        return cardDatabase;

    } catch (error) {
        console.error("Error loading or parsing card definitions:", error);
        return null; // Return null to indicate failure
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\utils.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\account\AccountManager.js ---
// js/account/AccountManager.js

// Chaves usadas para armazenar os dados no localStorage/sessionStorage
const ACCOUNTS_STORAGE_KEY = 'runebound_clash_accounts';
const CURRENT_USER_SESSION_KEY = 'runebound_clash_current_user';

/**
 * Gerencia contas de usuário, login, logout e dados associados (decks, histórico, avatar).
 * Utiliza localStorage para persistência entre sessões e sessionStorage para o login atual.
 * IMPORTANTE: Este exemplo armazena senhas em texto plano no localStorage,
 * o que NÃO É SEGURO para produção. Em uma aplicação real, use hashing de senhas no servidor.
 */
export default class AccountManager {
    #accounts = {}; // Objeto para armazenar todos os dados das contas carregadas
    #currentUser = null; // Objeto do usuário atualmente logado

    constructor() {
        this.#loadAccounts();
        this.#loadCurrentUserFromSession();
        console.log("AccountManager inicializado.");
        // Alerta de segurança sobre senhas em texto plano
        console.warn("ATENÇÃO: Este AccountManager armazena senhas em texto plano no localStorage. NÃO use em produção!");
    }

    // --- Métodos Privados ---

    /** Carrega as contas do localStorage para a memória. */
    #loadAccounts() {
        const storedAccounts = localStorage.getItem(ACCOUNTS_STORAGE_KEY);
        if (storedAccounts) {
            try {
                this.#accounts = JSON.parse(storedAccounts);
                 console.log(`Contas carregadas do localStorage: ${Object.keys(this.#accounts).length}`);
            } catch (error) {
                console.error("Erro ao carregar/parsear contas do localStorage:", error);
                this.#accounts = {};
                localStorage.removeItem(ACCOUNTS_STORAGE_KEY);
            }
        } else {
            this.#accounts = {};
             console.log("Nenhuma conta encontrada no localStorage.");
        }
    }

    /** Salva o estado atual das contas de volta no localStorage. */
    #saveAccounts() {
        try {
            localStorage.setItem(ACCOUNTS_STORAGE_KEY, JSON.stringify(this.#accounts));
             console.log("Contas salvas no localStorage.");
        } catch (error) {
            console.error("Erro ao salvar contas no localStorage:", error);
        }
    }

     /** Tenta carregar o usuário logado da sessionStorage. */
     #loadCurrentUserFromSession() {
        const currentUsername = sessionStorage.getItem(CURRENT_USER_SESSION_KEY);
        if (currentUsername && this.#accounts[currentUsername]) {
            this.#currentUser = this.#accounts[currentUsername]; // Load from already parsed accounts
            console.log(`Sessão ativa encontrada para: ${currentUsername}`);
        } else {
            this.#currentUser = null;
            if (sessionStorage.getItem(CURRENT_USER_SESSION_KEY)){
                console.log("Sessão encontrada, mas usuário não existe mais nas contas. Limpando sessão.");
                sessionStorage.removeItem(CURRENT_USER_SESSION_KEY);
            } else {
                 console.log("Nenhuma sessão ativa encontrada.");
            }
        }
    }

     /** Define o usuário atual na memória e na sessionStorage. */
     #setCurrentUser(userData) {
        if(userData && userData.username) {
            this.#currentUser = userData;
            try {
                sessionStorage.setItem(CURRENT_USER_SESSION_KEY, userData.username);
                 console.log(`Sessão definida para: ${userData.username}`);
            } catch(e) {
                console.error("Erro ao salvar sessão no sessionStorage:", e);
            }
        } else {
            this.#currentUser = null;
             try {
                sessionStorage.removeItem(CURRENT_USER_SESSION_KEY);
                console.log("Sessão removida.");
             } catch(e) {
                 console.error("Erro ao remover sessão do sessionStorage:", e);
             }
        }
     }

     /** Cria a estrutura de dados padrão para um novo usuário. */
     #createDefaultUserData(username, password) {
        console.log(`Criando dados padrão para novo usuário: ${username}`);
        const startingCollection = [
            'CR001', 'CR002', 'CR003', 'CR007', 'CR009', 'CR010', 'CR011', 'CR016', // Creatures
            'RB001', 'RB_DRAW2', 'RB_POWER', 'RB_TOUGH',                          // Runebindings
            'IS001', 'IS002', 'IS003', 'IS004'                                   // Instants
        ];
        console.log("Coleção inicial definida com:", startingCollection);

        const defaultDeckCards = [
            'CR001', 'CR001', 'CR001', 'CR001', 'CR003', 'CR003', 'CR003', 'CR003',
            'CR007', 'CR007', 'CR007', 'CR011', 'CR011', 'CR011', 'CR009', 'CR009',
            'CR016', 'CR016', 'CR010', 'CR010', 'CR002', 'IS002', 'IS002', 'IS002',
            'IS002', 'IS003', 'IS003', 'IS003', 'RB_POWER','RB_POWER', 'RB_TOUGH',
            'RB_TOUGH', 'IS004', 'IS004', 'IS001', 'RB001', 'RB_DRAW2' // Total: 37 cards
        ];
         console.log("Deck inicial definido com:", defaultDeckCards.length, "cartas");

        return {
            username: username,
            password: password, // INSECURE!
            rank: 'Bronze III',
            stats: { wins: 0, losses: 0 },
            matchHistory: [],
            collection: startingCollection,
            decks: {
                'default_deck_1': {
                    id: 'default_deck_1',
                    name: 'Deck Inicial Padrão',
                    cards: defaultDeckCards
                }
            },
            // --- ADD AVATAR FIELD ---
            avatar: 'default.png', // Default avatar filename
            // -----------------------
            createdAt: Date.now()
        };
     }


    // --- Métodos Públicos ---

    createAccount(username, password) {
        if (!username || !password) { return { success: false, message: "Nome de usuário e senha são obrigatórios." }; }
        if (username.length < 3) { return { success: false, message: "Nome de usuário deve ter pelo menos 3 caracteres." }; }
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
        if (this.#accounts[username]) { return { success: false, message: "Este nome de usuário já está em uso." }; }
        const newUser = this.#createDefaultUserData(username, password);
        this.#accounts[username] = newUser;
        this.#saveAccounts();
        console.log(`Conta criada com sucesso para: ${username}`);
        return { success: true, message: "Conta criada com sucesso!", user: newUser };
    }

    login(username, password) {
        if (!username || !password) { return { success: false, message: "Nome de usuário e senha obrigatórios." }; }
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
        const userData = this.#accounts[username];
        if (!userData) { return { success: false, message: "Usuário não encontrado." }; }
        if (userData.password !== password) { return { success: false, message: "Senha incorreta." }; } // INSECURE!
        this.#setCurrentUser(userData);
        console.log(`Usuário ${username} logado com sucesso.`);
        return { success: true, message: "Login bem-sucedido!", user: this.#currentUser };
    }

    logout() {
        const username = this.#currentUser?.username;
        this.#setCurrentUser(null);
        if (username) { console.log(`Usuário ${username} desconectado.`); }
    }

    getCurrentUser() {
        if (!this.#currentUser) { this.#loadCurrentUserFromSession(); }
        // Ensure avatar exists even if loaded from old data
        if (this.#currentUser && typeof this.#currentUser.avatar === 'undefined') {
             this.#currentUser.avatar = 'default.png'; // Add default avatar if missing
             if (this.#accounts[this.#currentUser.username]) { // Ensure it exists in main map too
                this.#accounts[this.#currentUser.username] = this.#currentUser;
                this.#saveAccounts(); // Save the added default avatar
             }
        }
        return this.#currentUser ? { ...this.#currentUser } : null;
    }

    getUserData(username) {
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
         // Ensure avatar exists (similar to getCurrentUser) - might be overkill if only used internally
        const userData = this.#accounts[username];
         if (userData && typeof userData.avatar === 'undefined') {
             userData.avatar = 'default.png';
             this.#saveAccounts(); // Save if modified
         }
        return userData ? { ...userData } : null;
    }

    // --- Deck & Data Management ---

    saveDeck(deckId, deckName, cardIds) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!deckId || !deckName || !Array.isArray(cardIds)) { return { success: false, message: "Dados inválidos para salvar o deck." }; }
        if (cardIds.length < 30 || cardIds.length > 40) { return { success: false, message: "O deck deve ter entre 30 e 40 cartas." }; }
        if (!this.#currentUser.decks) { this.#currentUser.decks = {}; }
        this.#currentUser.decks[deckId] = { id: deckId, name: deckName, cards: cardIds, lastUpdated: Date.now() };
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Deck '${deckName}' (ID: ${deckId}) salvo para ${this.#currentUser.username}.`);
        return { success: true, message: "Deck salvo com sucesso!" };
    }

     deleteDeck(deckId) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!this.#currentUser.decks || !this.#currentUser.decks[deckId]) { return { success: false, message: "Deck não encontrado." }; }
        if (Object.keys(this.#currentUser.decks).length <= 1) { /* Optional: return { success: false, message: "Não pode excluir último deck." }; */ }
        delete this.#currentUser.decks[deckId];
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Deck ID '${deckId}' excluído para ${this.#currentUser.username}.`);
        return { success: true, message: "Deck excluído com sucesso!" };
     }

    loadDecks() {
        const user = this.getCurrentUser(); return user?.decks ? { ...user.decks } : null;
    }
     getCollection() {
        const user = this.getCurrentUser(); return user?.collection ? [...user.collection] : null;
     }

     /** Saves the user's chosen avatar preference */
     saveAvatarChoice(avatarFilename) {
         if (!this.#currentUser) { console.warn("Cannot save avatar choice, no user logged in."); return false; }
         if (typeof avatarFilename !== 'string') { console.warn("Invalid avatar filename provided."); return false; }
         this.#currentUser.avatar = avatarFilename;
         this.#accounts[this.#currentUser.username] = this.#currentUser;
         this.#saveAccounts();
         console.log(`Avatar choice saved for ${this.#currentUser.username}: ${avatarFilename}`);
         return true;
     }

     addMatchHistory(matchData) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!matchData?.opponent || !matchData?.result) { return { success: false, message: "Dados inválidos da partida." }; }
        const historyEntry = { ...matchData, date: Date.now() };
        if (!this.#currentUser.matchHistory) this.#currentUser.matchHistory = [];
        if (!this.#currentUser.stats) this.#currentUser.stats = { wins: 0, losses: 0 };
        this.#currentUser.matchHistory.unshift(historyEntry);
        if (this.#currentUser.matchHistory.length > 50) this.#currentUser.matchHistory.pop();
        if (matchData.result === 'win') this.#currentUser.stats.wins++;
        else if (matchData.result === 'loss') this.#currentUser.stats.losses++;
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Histórico de partida adicionado para ${this.#currentUser.username}.`);
        return { success: true, message: "Histórico salvo." };
     }

     getMatchHistory() { const user = this.getCurrentUser(); return user?.matchHistory ? [...user.matchHistory] : null; }
     getStats() { const user = this.getCurrentUser(); return user?.stats ? { ...user.stats } : null; }
     getRank() { const user = this.getCurrentUser(); return user?.rank || null; }

} // End of class AccountManager
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\account\AccountManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\audio\AudioManager.js ---
// js/audio/AudioManager.js - ATUALIZADO

const DEFAULT_BGM_VOLUME = 0.6;
const DEFAULT_SFX_VOLUME = 0.8;
const FADE_DURATION_MS = 500;
const FADE_INTERVAL_MS = 50;
const SFX_POOL_SIZE = 8;

export default class AudioManager {
    #bgmAudio;
    #sfxPool = [];
    #currentSfxIndex = 0;
    #currentBgmSrc = null;
    #targetBgmVolume = DEFAULT_BGM_VOLUME;
    #sfxVolume = DEFAULT_SFX_VOLUME;
    #isMusicMuted = false; // <<<=== Mute separado para BGM
    #isSfxMuted = false;   // <<<=== Mute separado para SFX
    #fadeInterval = null;

    #bgmTracks = { // Definir os caminhos corretos
        'title-screen': 'assets/audio/bgm_title.mp3',
        'home-screen': 'assets/audio/bgm_title.mp3', // <<< MUDADO - Usar BGM diferente para Home
        'profile-screen': 'assets/audio/bgm_profile.mp3',
        'deck-management-screen': 'assets/audio/bgm_builder.mp3',
        'deck-builder-screen': 'assets/audio/bgm_builder.mp3',
        'connect-screen': 'assets/audio/bgm_title.mp3',
        'options-screen': 'assets/audio/bgm_title.mp3', // <<< MUDADO - Usar BGM diferente para Options
        'battle-screen': 'assets/audio/bgm_battle.mp3',
    };

    #sfxTracks = { // Definir os caminhos corretos
        'buttonHover': 'assets/audio/sfx_hover.mp3',
        'buttonClick': 'assets/audio/sfx_click.mp3',
        'loginError': 'assets/audio/sfx_error.mp3',
        'createAccountError': 'assets/audio/sfx_error.mp3',
        'cardDraw': 'assets/audio/sfx_card_draw.mp3',
        'cardDiscard': 'assets/audio/sfx_card_discard.mp3',
        'playCreature': 'assets/audio/sfx_play_creature.mp3',
        'playInstant': 'assets/audio/sfx_play_instant.wav',
        'playRunebinding': 'assets/audio/sfx_play_runebinding.mp3',
        'gameOverWin': 'assets/audio/sfx_game_over_win.mp3',
        'gameOverLose': 'assets/audio/sfx_game_over_lose.mp3',
        'genericError': 'assets/audio/sfx_error.mp3',
        'deckSave': 'assets/audio/sfx_deck_save.mp3', // Exemplo, pode querer um som específico
    };

    constructor() {
        console.log("AudioManager: Initializing...");
        this._createAudioElements();
        this._loadSettings();
        this._applySfxVolume(); // Aplicar volume SFX inicial
        // BGM volume é aplicado durante fade in/out ou updateSettings
        console.log(`AudioManager: Initialized (Target BGM Vol: ${this.#targetBgmVolume}, SFX Vol: ${this.#sfxVolume}, Music Muted: ${this.#isMusicMuted}, SFX Muted: ${this.#isSfxMuted})`);
    }

    _createAudioElements() {
        this.#bgmAudio = new Audio();
        this.#bgmAudio.loop = true;
        for (let i = 0; i < SFX_POOL_SIZE; i++) {
            this.#sfxPool.push(new Audio());
        }
    }

    _loadSettings() {
        try {
            const storedOptions = localStorage.getItem('runebound_clash_options');
            if (storedOptions) {
                const options = JSON.parse(storedOptions);
                this.#targetBgmVolume = (options.musicVolume ?? DEFAULT_BGM_VOLUME * 100) / 100;
                this.#sfxVolume = (options.sfxVolume ?? DEFAULT_SFX_VOLUME * 100) / 100;
                this.#isMusicMuted = options.isMusicMuted ?? false; // <<<=== Carrega estado mute BGM
                this.#isSfxMuted = options.isSfxMuted ?? false;     // <<<=== Carrega estado mute SFX
                console.log("AudioManager: Loaded settings from localStorage.");
            } else {
                console.log("AudioManager: No saved settings found, using defaults.");
                this.#targetBgmVolume = DEFAULT_BGM_VOLUME;
                this.#sfxVolume = DEFAULT_SFX_VOLUME;
                this.#isMusicMuted = false;
                this.#isSfxMuted = false;
            }
        } catch (e) {
            console.error("AudioManager: Error loading settings:", e);
            this.#targetBgmVolume = DEFAULT_BGM_VOLUME;
            this.#sfxVolume = DEFAULT_SFX_VOLUME;
            this.#isMusicMuted = false;
            this.#isSfxMuted = false;
        }
        // Garante limites 0.0 a 1.0
        this.#targetBgmVolume = Math.max(0, Math.min(1, this.#targetBgmVolume));
        this.#sfxVolume = Math.max(0, Math.min(1, this.#sfxVolume));
    }

     _applySfxVolume() {
        const effectiveSfxVolume = this.#isSfxMuted ? 0 : this.#sfxVolume; // <<<=== Verifica mute SFX
        this.#sfxPool.forEach(sfx => {
            sfx.volume = effectiveSfxVolume;
        });
    }

     _applyBgmVolume() {
         const effectiveBgmVolume = this.#isMusicMuted ? 0 : this.#targetBgmVolume; // <<<=== Verifica mute BGM
         // Aplica diretamente se não estiver em fade, senão o fade controlará
         if (!this.#fadeInterval && !this.#bgmAudio.paused) {
             this.#bgmAudio.volume = effectiveBgmVolume;
         }
         // Se estiver mutado e tocando, pausa a música
         if(this.#isMusicMuted && !this.#bgmAudio.paused) {
            this.#bgmAudio.pause(); // Pausa se mutar
         } else if (!this.#isMusicMuted && this.#bgmAudio.paused && this.#currentBgmSrc) {
            // Se desmutar e tinha uma música definida, tenta retomar (pode precisar de interação)
            this._fadeInBGM(this.#currentBgmSrc); // Retoma com fade
         }
    }

    updateSettings() {
        console.log("AudioManager: Updating settings...");
        this._loadSettings(); // Recarrega tudo, incluindo mute states
        this._applySfxVolume(); // Aplica volume SFX (considerando mute)
        this._applyBgmVolume(); // Aplica volume BGM (considerando mute e estado atual)
        console.log(`AudioManager: Settings updated (Target BGM Vol: ${this.#targetBgmVolume}, SFX Vol: ${this.#sfxVolume}, Music Muted: ${this.#isMusicMuted}, SFX Muted: ${this.#isSfxMuted})`);
    }

    playBGM(screenId) {
        const newTrackSrc = this.#bgmTracks[screenId];
        // Se mutado, não toca nova BGM, mas para a anterior se estiver tocando
        if (this.#isMusicMuted) {
             console.log("AudioManager: Music is muted, stopping current BGM if playing.");
             this.stopBGM();
             this.#currentBgmSrc = newTrackSrc; // Guarda a faixa que *deveria* tocar
             return;
        }

        if (!newTrackSrc) {
            console.warn(`AudioManager: No BGM track for screen '${screenId}'. Stopping.`);
            this.stopBGM();
            return;
        }
        if (this.#currentBgmSrc === newTrackSrc && !this.#bgmAudio.paused) {
            return; // Já está tocando
        }

        console.log(`AudioManager: Changing BGM to track for '${screenId}': ${newTrackSrc}`);
        if (!this.#bgmAudio.paused && this.#currentBgmSrc) {
            this._fadeOutBGM(() => this._fadeInBGM(newTrackSrc));
        } else {
            this._fadeInBGM(newTrackSrc);
        }
    }

    stopBGM() {
        if (!this.#bgmAudio.paused) {
            console.log("AudioManager: Stopping BGM...");
            this._fadeOutBGM(() => {
                this.#currentBgmSrc = null;
                 console.log("AudioManager: BGM stopped.");
            });
        } else {
             this.#currentBgmSrc = null;
        }
    }

    _fadeOutBGM(onCompleteCallback) {
        if (this.#fadeInterval) clearInterval(this.#fadeInterval);
        if (this.#bgmAudio.paused || this.#bgmAudio.volume <= 0.01) {
             this.#bgmAudio.pause();
             this.#bgmAudio.volume = 0; // Zera o volume ao pausar
             if (onCompleteCallback) onCompleteCallback();
             return;
        }
        const startVolume = this.#bgmAudio.volume;
        const steps = FADE_DURATION_MS / FADE_INTERVAL_MS;
        const decrement = startVolume / steps;
        this.#fadeInterval = setInterval(() => {
            let newVolume = this.#bgmAudio.volume - decrement;
            if (newVolume <= 0) {
                newVolume = 0;
                this.#bgmAudio.pause();
                clearInterval(this.#fadeInterval);
                this.#fadeInterval = null;
                console.log("AudioManager: Fade out complete.");
                if (onCompleteCallback) onCompleteCallback();
            }
            this.#bgmAudio.volume = newVolume; // Volume real é zero se mutado
        }, FADE_INTERVAL_MS);
    }

     _fadeInBGM(src) {
         if (this.#fadeInterval) clearInterval(this.#fadeInterval);
         // Não inicia se a música estiver mutada
         if (this.#isMusicMuted) {
             console.log("AudioManager: Music muted, fade in skipped.");
             this.#currentBgmSrc = src; // Guarda a música que deveria tocar
             return;
         }

         this.#bgmAudio.src = src;
         this.#currentBgmSrc = src;
         this.#bgmAudio.volume = 0;

         this.#bgmAudio.play().then(() => {
            console.log("AudioManager: BGM playback started for fade in.");
             const targetVol = this.#targetBgmVolume; // Usa o volume alvo (não mutado)
             if (targetVol <= 0) return;
             const steps = FADE_DURATION_MS / FADE_INTERVAL_MS;
             const increment = targetVol / steps;
             this.#fadeInterval = setInterval(() => {
                 let newVolume = this.#bgmAudio.volume + increment;
                 if (newVolume >= targetVol) {
                     newVolume = targetVol;
                     clearInterval(this.#fadeInterval);
                     this.#fadeInterval = null;
                     console.log("AudioManager: Fade in complete.");
                 }
                 this.#bgmAudio.volume = newVolume;
             }, FADE_INTERVAL_MS);
         }).catch(error => {
             console.error("AudioManager: BGM play failed:", error);
             this.#currentBgmSrc = null;
         });
     }

    playSFX(sfxName) {
        if (this.#isSfxMuted) return; // <<<=== Verifica mute SFX

        const trackSrc = this.#sfxTracks[sfxName];
        if (!trackSrc) {
            console.warn(`AudioManager: SFX track not found for '${sfxName}'`);
            return;
        }
        try {
            const sfxPlayer = this._getAvailableSfxPlayer();
            sfxPlayer.volume = this.#sfxVolume; // Aplica volume SFX (já considera mute no getter/setter implícito)
            sfxPlayer.src = trackSrc;
            sfxPlayer.play().catch(error => {
                 console.log(`AudioManager: SFX play error for ${sfxName}: ${error.message}`);
            });
        } catch (error) {
            console.error(`AudioManager: Error preparing SFX '${sfxName}':`, error);
        }
    }

    _getAvailableSfxPlayer() {
        const player = this.#sfxPool[this.#currentSfxIndex];
        this.#currentSfxIndex = (this.#currentSfxIndex + 1) % SFX_POOL_SIZE;
        return player;
    }

    // <<<=== Métodos separados para mute ===>>>
    setMusicMuted(muted) {
        if (this.#isMusicMuted === muted) return;
        this.#isMusicMuted = muted;
        console.log(`AudioManager: Music Muted set to ${muted}`);
        this._applyBgmVolume(); // Aplica imediatamente (pausa ou retoma se necessário)
    }

    setSfxMuted(muted) {
        if (this.#isSfxMuted === muted) return;
        this.#isSfxMuted = muted;
        console.log(`AudioManager: SFX Muted set to ${muted}`);
        this._applySfxVolume(); // Aplica imediatamente
    }
    // <<<===================================>>>

}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\audio\AudioManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Battlefield.js ---
// js/core/Battlefield.js
/**
 * Represents the battlefield zone for a player.
 */
export class Battlefield { // Using export class
    #cards = new Map(); // Map<string, Card> (uniqueId -> CardInstance)

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        if (this.#cards.has(cardInstance.uniqueId)) return false;
        this.#cards.set(cardInstance.uniqueId, cardInstance);
        return true;
    }

    removeCard(cardUniqueId) {
        const card = this.#cards.get(cardUniqueId);
        if (card) {
            this.#cards.delete(cardUniqueId);
            return card;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.get(cardUniqueId) || null;
    }

    getAllCards() {
        return [...this.#cards.values()];
    }

    getCreatures() {
        // Assuming CreatureCard is imported if needed for instanceof
        return this.getAllCards().filter(card => card.type === 'Creature');
    }

    getSize() {
        return this.#cards.size;
    }

    untapAll() {
        this.#cards.forEach(card => {
            if (typeof card.untap === 'function') card.untap();
        });
    }

    clear() {
        this.#cards.clear();
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Battlefield.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Card.js ---
// js/core/Card.js
import { generateUniqueId } from '../utils.js';

export default class Card { // Using export default
    #id;
    #uniqueId;
    #name;
    #type;
    #cost;
    #imageSrc;
    #description;
    #ownerId;
    location = 'deck'; // deck, hand, battlefield, graveyard

    constructor(cardDefinition, ownerId) {
        if (!cardDefinition || !cardDefinition.id) throw new Error("Invalid card definition provided to Card constructor.");
        this.#id = cardDefinition.id;
        this.#uniqueId = generateUniqueId(`card_${cardDefinition.id}`); // Prefix with card type/id
        this.#name = cardDefinition.name;
        this.#type = cardDefinition.type;
        this.#cost = cardDefinition.cost;
        this.#imageSrc = cardDefinition.image_src || 'assets/images/cards/default.png';
        this.#description = cardDefinition.description || '';
        this.#ownerId = ownerId;
        this.location = 'deck';
    }

    // --- Getters ---
    get id() { return this.#id; }
    get uniqueId() { return this.#uniqueId; }
    get name() { return this.#name; }
    get type() { return this.#type; }
    get cost() { return this.#cost; }
    get imageSrc() { return this.#imageSrc; }
    get description() { return this.#description; }
    get ownerId() { return this.#ownerId; }

    // --- Basic Methods (to be overridden) ---

    canPlay(player, game) {
        if (!player || !game || !game.getCurrentPlayer) return false; // Basic safety
        const currentPlayer = game.getCurrentPlayer();
        if (!currentPlayer || player.id !== currentPlayer.id) return false; // Not player's turn
        if (player.mana < this.cost) return false; // Not enough mana
        if (this.location !== 'hand') return false; // Must be in hand
        // Add phase checks in subclasses (Instants vs others)
        return true;
    }

    /** Base play method - subclasses must implement actual logic */
    play(player, game, targetId = null) {
        // Basic checks are done before calling this usually by Player.playCard
        // This method *in the base class* just confirms mana cost is paid
        // Subclasses will handle moving the card and applying effects.
        console.log(`Card: Base play method called for ${this.name}. Mana should be spent by caller.`);
        // game.emitEvent('cardPlayed', { card: this.getRenderData(), player: player.getRenderData(), targetId }); // Emit basic event
        return true; // Return true indicating the 'play' sequence started
    }

     /** Placeholder: Does this card require a target? Subclasses override. */
     requiresTarget() {
        return false;
     }

     /** Placeholder: What kind of target? Subclasses override. */
     targetType() {
        return null;
     }

    // --- Rendering ---
    getRenderData() {
        return {
            uniqueId: this.uniqueId, id: this.id, name: this.name,
            cost: this.cost, type: this.type, imageSrc: this.imageSrc,
            description: this.description, location: this.location, ownerId: this.ownerId
        };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Card.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CombatManager.js ---
// js/core/CombatManager.js

/**
 * Manages the combat phase, including declaring attackers, blockers,
 * and resolving damage.
 */
export default class CombatManager {
    #game; // Reference to the main Game instance
    #attackers = new Map(); // Map<string, CreatureCard> - Attacking creatures by uniqueId
    #blockerAssignments = new Map(); // Map<string, string[]> - Attacker uniqueId -> [Array of blocker uniqueIds]
    #combatState = 'none'; // 'none', 'declare_attackers', 'declare_blockers', 'resolving'

    /**
     * Creates a CombatManager instance.
     * @param {Game} gameInstance - The main game instance.
     */
    constructor(gameInstance) {
        if (!gameInstance) {
            throw new Error("CombatManager requires a valid Game instance.");
        }
        this.#game = gameInstance;
        this.#combatState = 'none';
        console.log("CombatManager: Instance created.");
    }

    /** Resets the combat state for a new combat phase or turn. */
    reset() {
        this.#attackers.clear();
        this.#blockerAssignments.clear();
        this.#combatState = 'none';
        console.log("CombatManager: State reset.");
    }

    /**
     * Sets the attacking creatures for the current combat phase.
     * @param {Player} attackingPlayer - The player declaring attackers.
     * @param {string[]} attackerIds - Array of uniqueIds of the creatures declared as attackers.
     * @returns {boolean} True if attackers were successfully declared, false otherwise.
     */
    declareAttackers(attackingPlayer, attackerIds) {
        if (this.#combatState !== 'none' && this.#combatState !== 'declare_attackers') {
            console.warn(`CombatManager: Cannot declare attackers in state: ${this.#combatState}`);
            return false;
        }
        if (this.#game.getCurrentPhase() !== 'attack') {
            console.warn(`CombatManager: Cannot declare attackers outside of attack phase.`);
             this.#game.emitEvent('gameLog', { message: `Ataque só pode ser declarado na Fase de Ataque.` });
            return false;
        }
        if (this.#game.getCurrentPlayer()?.id !== attackingPlayer.id) {
             console.warn(`CombatManager: Only the current player can declare attackers.`);
             this.#game.emitEvent('gameLog', { message: `Apenas o jogador ativo pode atacar.` });
             return false;
        }

        this.#attackers.clear(); // Clear previous attackers for this combat
        const declaredAttackers = [];
        let success = true;

        for (const id of attackerIds) {
            const creature = attackingPlayer.battlefield.getCard(id);
            if (creature && creature.type === 'Creature' && creature.canAttack()) {
                this.#attackers.set(id, creature);
                declaredAttackers.push(creature.getRenderData()); // For event
            } else {
                console.warn(`CombatManager: Creature ${id} cannot attack or was not found.`);
                 this.#game.emitEvent('gameLog', { message: `Criatura inválida para atacar: ${creature?.name || id}` });
                success = false; // Allow declaring valid ones, but report failure if any invalid
            }
        }

        if (this.#attackers.size > 0) {
            console.log(`CombatManager: ${this.#attackers.size} attackers declared by ${attackingPlayer.name}.`);
            this.#combatState = 'declare_blockers'; // Move state forward
            // Tap the attacking creatures
            this.#attackers.forEach(attacker => {
                 attacker.tap(); // Creature method handles isTapped state
                 this.#game.emitEvent('creatureUpdate', { cardUniqueId: attacker.uniqueId, updates: { isTapped: true } });
            });
            // Emit event AFTER setting state and tapping
            this.#game.emitEvent('attackersDeclared', {
                attackingPlayerId: attackingPlayer.id,
                attackers: declaredAttackers // Send data about declared attackers
            });
        } else {
            console.log(`CombatManager: No valid attackers declared by ${attackingPlayer.name}. Skipping to next phase.`);
             this.#game.emitEvent('gameLog', { message: `Nenhum atacante válido declarado.` });
            // If no attackers, combat effectively ends, proceed past blocker declaration
            this.#combatState = 'resolving'; // Or directly call resolveCombat which resets?
            this.resolveCombat(); // Resolve immediately (will do nothing and reset)
        }

        return success; // Indicates if *all* requested attackers were valid
    }

    /**
     * Sets the blocker assignments for the current combat.
     * @param {Player} defendingPlayer - The player declaring blockers.
     * @param {Map<string, string[]>} assignments - Map where key is attacker uniqueId and value is array of blocker uniqueIds.
     * @returns {boolean} True if blockers were successfully declared.
     */
    declareBlockers(defendingPlayer, assignments) {
        if (this.#combatState !== 'declare_blockers') {
            console.warn(`CombatManager: Cannot declare blockers in state: ${this.#combatState}`);
            return false;
        }
        // Add check: Ensure it's the defending player's turn to declare blockers (implicitly handled by game flow)

        this.#blockerAssignments.clear();
        const declaredBlockersInfo = []; // For event
        let allValid = true;

        assignments.forEach((blockerIds, attackerId) => {
            const attacker = this.#attackers.get(attackerId);
            if (!attacker) {
                console.warn(`CombatManager: Invalid attacker ID ${attackerId} in blocker assignments.`);
                allValid = false;
                return; // Skip this assignment
            }

            const validBlockersForThisAttacker = [];
            for (const blockerId of blockerIds) {
                const blocker = defendingPlayer.battlefield.getCard(blockerId);
                // TODO: Add more complex block validation (e.g., Flying)
                if (blocker && blocker.type === 'Creature' && blocker.canBlock()) {
                    validBlockersForThisAttacker.push(blockerId);
                     // Add to event data only if valid
                     if (!declaredBlockersInfo.find(b => b.blockerId === blockerId)) {
                         declaredBlockersInfo.push({ blockerId: blockerId, blockerData: blocker.getRenderData() });
                     }
                } else {
                    console.warn(`CombatManager: Creature ${blockerId} cannot block ${attackerId} or not found.`);
                     this.#game.emitEvent('gameLog', { message: `Bloqueador inválido: ${blocker?.name || blockerId}` });
                    allValid = false;
                }
            }
            if (validBlockersForThisAttacker.length > 0) {
                this.#blockerAssignments.set(attackerId, validBlockersForThisAttacker);
                 console.log(`CombatManager: Attacker ${attacker.name} (${attackerId}) blocked by [${validBlockersForThisAttacker.join(', ')}]`);
            }
        });

        console.log(`CombatManager: Blockers declared by ${defendingPlayer.name}.`);
        this.#combatState = 'resolving'; // Move state forward

        this.#game.emitEvent('blockersDeclared', {
            defendingPlayerId: defendingPlayer.id,
            blockerAssignments: Object.fromEntries(this.#blockerAssignments), // Convert Map for event
            declaredBlockers: declaredBlockersInfo
        });

        // Immediately proceed to resolve combat after blockers are declared
        this.resolveCombat();

        return allValid; // Indicates if *all* assignments were fully valid
    }


    /** Resolves combat damage based on declared attackers and blockers. */
    resolveCombat() {
        if (this.#combatState !== 'resolving') {
            console.warn(`CombatManager: Cannot resolve combat in state: ${this.#combatState}. Assuming pre-declared or no combat.`);
            this.reset(); // Reset state if called unexpectedly
            return;
        }
        console.log("CombatManager: Resolving combat...");

        const defendingPlayer = this.#game.getOpponent(this.#game.getCurrentPlayer()?.id); // Player whose turn it ISN'T
        if (!defendingPlayer) {
             console.error("CombatManager: Could not determine defending player.");
             this.reset();
             return;
        }

        const damageEvents = []; // Store damage to apply simultaneously later (optional, simpler to apply directly)

        // Iterate through attackers
        this.#attackers.forEach((attacker, attackerId) => {
            const blockers = this.#blockerAssignments.get(attackerId);

            if (blockers && blockers.length > 0) {
                // --- Attacker is Blocked ---
                console.log(`CombatManager: Resolving blocked combat for ${attacker.name}`);
                let totalBlockerAttack = 0;
                const blockerInstances = [];

                blockers.forEach(blockerId => {
                    const blocker = defendingPlayer.battlefield.getCard(blockerId);
                    if (blocker) {
                        blockerInstances.push(blocker);
                        totalBlockerAttack += blocker.attack;
                    }
                });

                // Attacker deals damage to blocker(s)
                // Simple: Attacker deals full damage to first blocker only (adjust for multi-block rules)
                if (blockerInstances.length > 0) {
                    console.log(`CombatManager: ${attacker.name} deals ${attacker.attack} damage to ${blockerInstances[0].name}`);
                    blockerInstances[0].takeDamage(attacker.attack, attacker, this.#game);
                }

                // Blocker(s) deal damage to attacker
                console.log(`CombatManager: Blockers deal ${totalBlockerAttack} damage to ${attacker.name}`);
                attacker.takeDamage(totalBlockerAttack, blockerInstances[0], this.#game); // Source attribution might need work for multi-block

            } else {
                // --- Attacker is Unblocked ---
                console.log(`CombatManager: Unblocked attacker ${attacker.name} deals ${attacker.attack} damage to player ${defendingPlayer.name}`);
                defendingPlayer.takeDamage(attacker.attack, attacker, this.#game);
            }
        });

        console.log("CombatManager: Combat damage resolved.");
        this.#game.emitEvent('combatResolved', {
            // Include details about damage dealt, creatures died etc. if needed
        });

        // Reset state after resolution
        this.reset();
    }

    // --- Getters for state (optional) ---
    get state() { return this.#combatState; }
    getAttackers() { return [...this.#attackers.values()]; } // Return array copy
    getBlockerAssignments() { return new Map(this.#blockerAssignments); } // Return map copy
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CombatManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CreatureCard.js ---
// js/core/CreatureCard.js
import Card from './Card.js'; // Correct: Card uses export default

export default class CreatureCard extends Card { // Using export default
    #attack;
    #toughness;
    #currentToughness;
    #tribe;
    #abilities;
    #isTapped = false;
    #summoningSickness = true;
    #damageTakenThisTurn = 0; // Might not be needed

    // Buffs/Debuffs/Status Effects
    #tempBoosts = []; // Array of { boost: { attack?, toughness? }, duration: ticks }
    #statusEffects = new Map(); // Map<string, number> (effectName -> duration)

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId);
        if (cardDefinition.type !== 'Creature') throw new Error(`Definition "${cardDefinition.name}" is not type Creature.`);
        this.#attack = cardDefinition.attack ?? 0;
        this.#toughness = cardDefinition.toughness ?? 1;
        this.#currentToughness = this.#toughness; // Initialize current = max
        this.#tribe = cardDefinition.tribe || 'None';
        this.#abilities = cardDefinition.abilities || [];
        this.#tempBoosts = [];
        this.#statusEffects = new Map();
    }

    // --- Getters (applying modifiers) ---
    get baseAttack() { return this.#attack; }
    get baseToughness() { return this.#toughness; }

    get attack() { // Calculated attack
        let currentAttack = this.#attack;
        this.#tempBoosts.forEach(b => { currentAttack += (b.boost.attack || 0); });
        // TODO: Add permanent modifiers if any (e.g., from auras)
        return Math.max(0, currentAttack);
    }
    get toughness() { // Calculated max toughness
        let currentMaxToughness = this.#toughness;
         this.#tempBoosts.forEach(b => { currentMaxToughness += (b.boost.toughness || 0); });
         // TODO: Add permanent modifiers
         return Math.max(1, currentMaxToughness);
    }
     get currentToughness() { return this.#currentToughness; }

    get tribe() { return this.#tribe; }
    get abilities() { return [...this.#abilities]; } // Copy
    get isTapped() { return this.#isTapped; }
    get hasSummoningSickness() { return this.#summoningSickness; }
    hasStatusEffect(effectName) { return this.#statusEffects.has(effectName); }

    // --- Play Logic ---
    canPlay(player, game) {
        if (!super.canPlay(player, game)) return false;
        // Creatures usually played in Main Phase
        if (game.getCurrentPhase() !== 'main') return false;
        // TODO: Check battlefield limits
        return true;
    }

    play(player, game, targetId = null) {
        // Called AFTER Player spends mana
        console.log(`Creature: ${player.name} playing ${this.name}.`);
        const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'battlefield');
        if (moved) {
            this.#summoningSickness = true;
            this.#isTapped = false;
            this.onEnterBattlefield(game, player); // Trigger ETB effects
            // Emit full update after entering field
            game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: this.getRenderData() });
            return true;
        } else {
            console.error(`Creature: Failed move to battlefield for ${this.name}.`);
            return false; // Indicate failure
        }
    }

    // --- Combat and State ---
    canAttack() {
        return this.location === 'battlefield'
            && !this.#isTapped
            && !this.#summoningSickness
            && this.attack > 0
            && !this.hasStatusEffect('cant_attack')
            && !this.hasStatusEffect('silenced'); // Added silence check
    }
    canBlock() {
        // TODO: Add check for flying/reach interaction if relevant
        return this.location === 'battlefield'
            && !this.#isTapped
            && !this.hasStatusEffect('cant_block');
    }

    /** Explicitly taps the creature */
    tap() {
        if (!this.#isTapped) {
            this.#isTapped = true;
            console.log(`Creature: ${this.name} tapped.`);
            // Game should emit event AFTER calling this
        }
    }
    /** Explicitly untaps the creature */
    untap() {
        if (this.#isTapped) {
            this.#isTapped = false;
            console.log(`Creature: ${this.name} untapped.`);
            // Game should emit event AFTER calling this
        }
    }

    takeDamage(amount, source, game) {
        if (amount <= 0 || this.location !== 'battlefield') return;
        if (this.hasStatusEffect('shielded') || this.hasStatusEffect('prevent_damage')) {
            console.log(`Creature: ${this.name} damage prevented.`);
            if(this.hasStatusEffect('shielded')) this.removeStatusEffect('shielded'); // Shield is usually one-time
            game.emitEvent('damagePrevented', { target: this.getRenderData(), amount, source: source?.getRenderData() });
            return;
        }

        this.#currentToughness -= amount;
        console.log(`Creature: ${this.name} took ${amount} damage. Toughness: ${this.#currentToughness}/${this.toughness}`);
        // Emit individual update for toughness
        game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: { currentToughness: this.#currentToughness } });
        // Emit specific damage event
        game.emitEvent('creatureTookDamage', { creature: this.getRenderData(), amount, source: source?.getRenderData() });

        if (this.#currentToughness <= 0) {
            this.die(game);
        }
    }

    heal(amount, game) {
        if(amount <= 0 || this.location !== 'battlefield') return;
        const maxToughness = this.toughness; // Use calculated max toughness
        if (this.#currentToughness >= maxToughness) return; // Already full

        const actualHeal = Math.min(amount, maxToughness - this.#currentToughness);
        this.#currentToughness += actualHeal;
        console.log(`Creature: ${this.name} healed ${actualHeal}. Toughness: ${this.#currentToughness}/${maxToughness}`);
        game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: { currentToughness: this.#currentToughness } });
        game.emitEvent('creatureHealed', { creature: this.getRenderData(), amount: actualHeal });
    }

    die(game) {
        if (this.location !== 'battlefield') return; // Already dead/gone
        console.log(`Creature: ${this.name} is dying.`);
        const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'battlefield', 'graveyard');
        if (moved) {
             this.onDeath(game); // Trigger death effects AFTER moving
        } else {
            console.error(`Creature: Failed to move ${this.name} to graveyard.`);
        }
    }

    endTurnCleanup(isOwnTurn) {
        if (isOwnTurn) {
            this.#summoningSickness = false; // Wears off after controller's turn ends
        }
        const changed = this.#tickDownEffects(); // Tick down effects
        // TODO: If changed is true, trigger a 'creatureUpdate' event from Game?
        // Game's endTurnCleanup loop should probably do this.
    }

    // --- Status Effects & Boosts ---
    applyStatusEffect(effectName, duration) { // duration -1 for permanent
        this.#statusEffects.set(effectName, duration);
        console.log(`Creature: ${this.name} gained '${effectName}' (${duration < 0 ? 'Permanent' : duration + ' ticks'})`);
        // Game should emit update
    }
    removeStatusEffect(effectName) {
        const existed = this.#statusEffects.delete(effectName);
        if (existed) console.log(`Creature: ${this.name} lost '${effectName}'.`);
        // Game should emit update
        return existed;
    }
    applyTemporaryBoost(boost, duration) {
        this.#tempBoosts.push({ boost: { ...boost }, duration });
        if (boost.toughness && boost.toughness > 0) this.#currentToughness += boost.toughness;
        console.log(`Creature: ${this.name} gained boost ${JSON.stringify(boost)} (${duration} ticks)`);
        // Game should emit update
    }

    #tickDownEffects() {
        let changed = false;
        // Boosts
        const previousMaxToughness = this.toughness;
        this.#tempBoosts = this.#tempBoosts.filter(b => {
            b.duration--;
            if (b.duration <= 0) { changed = true; return false; } // Remove expired
            return true;
        });
        // Adjust current toughness if max toughness decreased
        const newMaxToughness = this.toughness;
        if (newMaxToughness < previousMaxToughness) {
            this.#currentToughness = Math.min(this.#currentToughness, newMaxToughness);
        }

        // Status Effects
        for (const [effect, duration] of this.#statusEffects.entries()) {
            if (duration > 0) { // Only tick down timed effects
                 const newDuration = duration - 1;
                 if (newDuration <= 0) { this.#statusEffects.delete(effect); changed = true; }
                 else { this.#statusEffects.set(effect, newDuration); }
            }
        }
        // TODO: Need a way for Game to know 'changed' happened to emit update
        return changed;
    }

    // --- Triggered Abilities (Placeholders) ---
    onEnterBattlefield(game, player) {
        if (this.abilities.includes('ETB: Draw a card')) { player.drawCards(1, game); }
    }
    onDeath(game) {
         if (this.abilities.includes('Deathrattle: Deal 1 damage to opponent')) {
             const opp = game.getOpponent(this.ownerId);
             if(opp) opp.takeDamage(1, this, game);
         }
    }

    // --- Rendering ---
    getRenderData() {
        // Ensure all relevant calculated properties are included
        return {
            ...super.getRenderData(),
            baseAttack: this.baseAttack, baseToughness: this.baseToughness,
            attack: this.attack, toughness: this.toughness, // Calculated max toughness
            currentToughness: this.currentToughness,
            tribe: this.tribe, isTapped: this.isTapped, hasSummoningSickness: this.hasSummoningSickness,
            canAttack: this.canAttack(), canBlock: this.canBlock(),
            statusEffects: Object.fromEntries(this.#statusEffects)
        };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CreatureCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Deck.js ---
// js/core/Deck.js
import Card from './Card.js'; // Default import
import CreatureCard from './CreatureCard.js'; // Default import
import { RunebindingCard } from './RunebindingCard.js'; // Named import
import { InstantCard } from './InstantCard.js'; // Named import
import { shuffleArray } from '../utils.js';

/**
 * Represents a player's deck of cards.
 */
export class Deck { // Using export class
    #cards = [];
    #ownerId;

    constructor(deckCardIds, cardDatabase, ownerId) {
        this.#cards = [];
        this.#ownerId = ownerId;
        if (!Array.isArray(deckCardIds) || !cardDatabase || !ownerId) throw new Error("Deck constructor requires deckCardIds, cardDatabase, and ownerId.");

        console.log(`Deck: Initializing for owner ${ownerId} with ${deckCardIds.length} IDs.`);
        deckCardIds.forEach(cardId => {
            const cardDefinition = cardDatabase[cardId];
            if (cardDefinition) {
                let cardInstance = null;
                try { // Add try-catch for safer instantiation
                    switch (cardDefinition.type) {
                        case 'Creature': cardInstance = new CreatureCard(cardDefinition, this.#ownerId); break;
                        case 'Runebinding': cardInstance = new RunebindingCard(cardDefinition, this.#ownerId); break;
                        case 'Instant': cardInstance = new InstantCard(cardDefinition, this.#ownerId); break;
                        default: console.warn(`Deck: Unknown type "${cardDefinition.type}" for ${cardId}. Using base Card.`); cardInstance = new Card(cardDefinition, this.#ownerId); break;
                    }
                    if (cardInstance) { cardInstance.location = 'deck'; this.#cards.push(cardInstance); }
                } catch (error) {
                     console.error(`Deck: Failed to instantiate card ${cardId} (${cardDefinition.name}):`, error);
                }
            } else { console.warn(`Deck: Card ID "${cardId}" not found in DB.`); }
        });
        console.log(`Deck: Created ${this.#cards.length} instances for ${ownerId}.`);
    }

    shuffle() { shuffleArray(this.#cards); console.log(`Deck (${this.#ownerId}): Shuffled.`); }
    draw() { if (this.isEmpty()) return null; return this.#cards.pop(); }
    addCard(cardInstance, toBottom = false) { if (!cardInstance?.uniqueId) return; cardInstance.location = 'deck'; if (toBottom) this.#cards.unshift(cardInstance); else this.#cards.push(cardInstance); }
    getSize() { return this.#cards.length; }
    isEmpty() { return this.#cards.length === 0; }
    clear() { this.#cards = []; }
    getCardsForDebug() { return [...this.#cards]; }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Deck.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Game.js ---
// js/core/Game.js
import Player from './Player.js';
import TurnManager from './TurnManager.js';
import CombatManager from './CombatManager.js';
// Import Card classes if needed for instanceof checks or specific game logic
import Card from './Card.js';
import CreatureCard from './CreatureCard.js';
import { RunebindingCard } from './RunebindingCard.js';
import { InstantCard } from './InstantCard.js';


export default class Game {
    #players = [];
    #currentPlayerIndex = -1;
    #turnManager;
    #combatManager;
    #state = 'setup'; // 'setup', 'starting', 'playing', 'discarding', 'game_over'
    #eventDispatcher;
    #cardDatabase;
    #pendingDiscard = null; // { playerId, count }

    constructor(cardDatabase) {
        if (!cardDatabase || Object.keys(cardDatabase).length === 0) { // Check if DB is valid
            throw new Error("Game requires a valid, non-empty cardDatabase.");
        }
        this.#players = [];
        this.#turnManager = new TurnManager();
        this.#combatManager = new CombatManager(this);
        this.#state = 'setup';
        this.#eventDispatcher = new EventTarget();
        this.#cardDatabase = cardDatabase;
        console.log("Game: Instance created with CombatManager.");
    }

    // --- Player Management (Added validation in addPlayer) ---

    /**
     * Adds a player to the game. Validates deck IDs.
     * @param {string} name Nome do jogador.
     * @param {string[]} deckCardIds Array de IDs das cartas no deck.
     * @returns {Player | null} The Player instance or null if adding failed.
     */
    addPlayer(name, deckCardIds) {
        if (this.#players.length >= 2) {
            console.error("Game Error: Cannot add more than 2 players.");
            return null;
        }
        if (!this.#cardDatabase) { // Should have been caught in constructor, but safety check
             console.error("Game Error: CardDatabase missing.");
             return null;
        }
        // --- FIX: Validate deckCardIds ---
        if (!Array.isArray(deckCardIds) || deckCardIds.length < 30 || deckCardIds.length > 40) {
             console.error(`Game Error: Invalid deckCardIds for player ${name}. Length: ${deckCardIds?.length}. Must be array [30-40].`);
             this.emitEvent('gameLog', { message: `Erro: Deck inválido para ${name}.` }); // Inform UI potentially
             return null; // Return null if deck IDs are invalid
        }
        // --- End Fix ---

        try {
            // Player constructor might throw if Deck fails (e.g., card ID not in DB)
            const player = new Player(name, deckCardIds, this.#cardDatabase);
            this.#players.push(player);
            console.log(`Game: Player ${name} (ID: ${player.id}) added with deck size ${deckCardIds.length}.`);
            return player;
        } catch (error) {
             console.error(`Game Error: Error creating Player '${name}':`, error);
             // Optionally emit a more specific error event
             return null; // Return null if Player/Deck constructor fails
        }
    }

    getPlayer(playerId) { return this.#players.find(p => p.id === playerId); }
    getOpponent(playerId) { return this.#players.find(p => p.id !== playerId); }
    getCurrentPlayer() { return this.#players[this.#currentPlayerIndex]; }
    /** Finds a card instance by its unique ID across all players and zones */
    findCardInstance(cardUniqueId) { /* ... (previous code) ... */ }
    /** Getter for Combat Manager */
    getCombatManager() { return this.#combatManager; } // <<< Added Getter


    // --- Game Flow ---
    setupGame() {
        if (this.#players.length !== 2) { console.error("Game: Need 2 players to setup."); return false; }
        this.#state = 'starting'; console.log("Game: Setting up...");
        this.#players.forEach(player => { player.resetStats(); player.shuffleDeck(); });
        this.#currentPlayerIndex = Math.floor(Math.random() * 2);
        console.log(`Game: ${this.getCurrentPlayer()?.name} will start.`);
        return true;
    }
    startGame() {
        if (this.#state !== 'starting') { console.error("Game: Not ready to start."); return; }
        if (!this.getCurrentPlayer()) { console.error("Game: Starting player not set."); return; }
        console.log("Game: Starting match!"); this.#state = 'playing';
        const initialHandSize = 5;
        this.#players.forEach(player => { for (let i = 0; i < initialHandSize; i++) this._drawCard(player); });
        this._startTurn(this.getCurrentPlayer()); // Start the first turn
        this.emitEvent('gameStarted', { startingPlayerId: this.getCurrentPlayer().id });
    }

    passPhase() {
        if (!['playing', 'discarding'].includes(this.#state)) { console.warn(`Game: Can't pass phase in state ${this.#state}`); return; }
        // Allow passing phase even if discarding to let the turn proceed if player is stuck? Or force discard first?
        // Let's assume discard must be resolved first.
        if (this.#state === 'discarding') {
             this.emitEvent('gameLog', { message: `Você precisa descartar ${this.#pendingDiscard.count} carta(s) primeiro.` });
             return;
        }

        const player = this.getCurrentPlayer(); if (!player) return;
        const oldPhase = this.getCurrentPhase();

        // Resolve combat if passing priority during specific combat substates
        if (oldPhase === 'attack') {
            if (this.#combatManager.state === 'declare_blockers') {
                 console.log("Game: Defending player passed blocker declaration. Resolving combat.");
                 this.#combatManager.resolveCombat(); // Resolve with no blockers
            } else if (this.#combatManager.state === 'declare_attackers') {
                 console.log("Game: Attacking player passed after declaring. Waiting for blockers.");
                 // Don't resolve yet, just let phase logic proceed (which should be handled by UI/opponent action)
            }
        }

        const { newPhase, turnEnded } = this.#turnManager.nextPhase();
        this.emitEvent('phaseChange', { playerId: player.id, oldPhase: oldPhase, newPhase: newPhase });
        if (turnEnded) { this.nextTurn(); }
        else { this._onPhaseEnter(newPhase, player); }
    }

    _onPhaseEnter(phase, player) {
        console.log(`Game: Entering ${phase} phase for ${player.name}.`);
        // Only reset combat state at the VERY START of the attack phase
        if (phase === 'attack') { this.#combatManager.reset(); this.emitEvent('attackPhaseStart', { playerId: player.id }); }
        else if (phase === 'end') { player.endTurnCleanup(this); } // Cleanup & Hand size check happens here
        else if (phase === 'draw') { this._drawCard(player); }
        // Set state to 'playing' unless a specific state like 'discarding' was triggered
        if (this.#state !== 'discarding') this.#state = 'playing';
    }

    endTurn() {
        if (this.#state !== 'playing') { console.warn(`Game: Can't end turn in state ${this.#state}`); return; }
        const player = this.getCurrentPlayer(); if (!player) return;
        console.log(`Game: ${player.name} ending turn from phase ${this.getCurrentPhase()}.`);
        let safety = 0;
        while(this.#state === 'playing' && safety < 10) { // Only loop if playing
             const currentPhase = this.getCurrentPhase();
             // If in attack phase, ensure combat resolves before proceeding fully
             if (currentPhase === 'attack' && this.#combatManager.state !== 'none') {
                 if (this.#combatManager.state === 'declare_blockers') { this.#combatManager.resolveCombat(); } // Assume no blocks if ending turn here
                 else if (this.#combatManager.state === 'resolving') { /* let it finish if already resolving */ }
                 else { this.#combatManager.reset(); } // Reset if only attackers declared
             }

             const { newPhase, turnEnded } = this.#turnManager.nextPhase();
             this.emitEvent('phaseChange', { playerId: player.id, oldPhase: currentPhase, newPhase: newPhase });
             if (newPhase === 'end') { player.endTurnCleanup(this); if(this.#state === 'discarding') break; } // Stop loop if discard starts
             if (turnEnded) { this.nextTurn(); break; }
             safety++;
        }
         if(safety >= 10) console.error("Game: Potential infinite loop in endTurn!");
         // If loop ended due to 'discarding' state, don't proceed to next turn yet
         if (this.#state === 'discarding') { console.log("Game: Turn end paused for discarding."); }
    }

    nextTurn() {
        if (!['playing', 'discarding'].includes(this.#state)) { console.warn("Game: Cannot start next turn in state", this.#state); return; }
        this.#combatManager.reset(); // Ensure combat is reset
        const previousPlayer = this.getCurrentPlayer();
        this.#currentPlayerIndex = (this.#currentPlayerIndex + 1) % this.#players.length;
        const newPlayer = this.getCurrentPlayer();
        console.log(`Game: Starting Turn ${this.#turnManager.turnNumber + 1} for ${newPlayer.name}.`);
        this.emitEvent('turnChange', { previousPlayerId: previousPlayer?.id, currentPlayerId: newPlayer.id, playerName: newPlayer.name, turnNumber: this.#turnManager.turnNumber + 1 });
        this._startTurn(newPlayer); // Sets state back to playing
    }

    _startTurn(player) {
        if (!player) return;
        this.#state = 'playing'; this.#pendingDiscard = null; // Reset state/discard
        const startingPhase = this.#turnManager.startNewTurn();
        player.prepareForTurn();
        this.emitEvent('playerStatsChanged', { playerId: player.id, updates: { mana: player.mana, maxMana: player.maxMana } });
        player.battlefield.getAllCards().forEach(c => { // Emit untap events
            if (c.type === 'Creature' && !c.isTapped) this.emitEvent('creatureUpdate', { cardUniqueId: c.uniqueId, updates: { isTapped: false } });
        });
        console.log(`Game: Turn ${this.#turnManager.turnNumber} started for ${player.name}.`);
        this._onPhaseEnter(startingPhase, player);
    }

    _drawCard(player) { if(!player||this.#state!=='playing')return null; const c=player.drawCard(); if(c){this.emitEvent('cardDrawn',{playerId:player.id,card:c.getRenderData()});return c;}else{console.log(`Game:${player.name} deck empty!`);this.emitEvent('deckEmpty',{playerId:player.id});this.gameOver(this.getOpponent(player.id));return null;} }
    moveCardToZone(cardUniqueId, playerId, fromZone, toZone) { const p=this.getPlayer(playerId); if(!p){console.error(`Game:P${playerId} not found`);return false;} const c=p.moveCardBetweenZones(cardUniqueId,fromZone,toZone); if(c){this.emitEvent('cardMoved',{cardUniqueId,cardData:c.getRenderData(),fromZone,toZone,ownerId:playerId}); return true;} return false; }
    requestPlayerDiscard(playerId, count) { if(this.#state==='playing'){this.#state='discarding'; this.#pendingDiscard={playerId,count}; console.log(`Game: State->discarding for ${playerId}, count ${count}`); this.emitEvent('discardRequired',{playerId,count}); this.emitEvent('gameLog',{message:`${this.getPlayer(playerId)?.name} precisa descartar ${count} carta(s).`});} }
    resolvePlayerDiscard(playerId, cardUniqueId) { if(this.#state!=='discarding'||!this.#pendingDiscard||this.#pendingDiscard.playerId!==playerId){console.warn(`Game: Invalid resolve discard`);return false;} const p=this.getPlayer(playerId); const c=p?.hand.getCard(cardUniqueId); if(!c){console.warn(`Game: Card ${cardUniqueId} not in hand`);return false;} const m=this.moveCardToZone(cardUniqueId,playerId,'hand','graveyard'); if(m){this.#pendingDiscard.count--; this.emitEvent('gameLog',{message:`${p.name} descartou ${c.name}.`}); if(this.#pendingDiscard.count<=0){console.log(`Game: Discard req met for ${playerId}.`); this.#pendingDiscard=null; this.#state='playing'; this.nextTurn();} else {this.emitEvent('discardRequired',{playerId,count:this.#pendingDiscard.count});}} return m; }

    // --- Combat Actions ---
    confirmAttackDeclaration(playerId, attackerIds) {
        const p=this.getPlayer(playerId); if(!p||this.#state!=='playing'||this.getCurrentPhase()!=='attack'||this.getCurrentPlayer()?.id!==playerId){this.emitEvent('gameLog',{message:"Não pode declarar ataque agora."}); return;}
        const success = this.#combatManager.declareAttackers(p, attackerIds);
        if(this.#combatManager.state==='declare_blockers'){this.emitEvent('gameLog',{message:`${this.getOpponent(playerId)?.name}, declare bloqueadores.`});}
        // State implicitly changes via CombatManager events
    }
    confirmBlockDeclaration(playerId, rawAssignments) {
        const p=this.getPlayer(playerId), ap=this.getCurrentPlayer();
        if(!p||this.#combatManager.state!=='declare_blockers'||this.getCurrentPhase()!=='attack'||ap?.id===playerId){this.emitEvent('gameLog',{message:"Não pode declarar bloqueadores agora."}); return;}
        const assignmentsMap = new Map(Object.entries(rawAssignments));
        const success = this.#combatManager.declareBlockers(p, assignmentsMap); // This now resolves and resets combat state
        this.#state = 'playing'; // Return game state to normal playing after combat resolves
        this.emitEvent('gameLog',{message:`Bloqueadores declarados. Resolvendo...`});
        // combatResolved event signals end
    }

    // --- Game Over / Events ---
    gameOver(winner) { if(this.#state==='game_over')return; this.#state='game_over'; const l=this.getOpponent(winner?.id); console.log(`Game Over! Winner:${winner?.name||'N/A'}`); this.emitEvent('gameOver',{winnerId:winner?.id,winnerName:winner?.name,loserId:l?.id,loserName:l?.name}); }
    get state() { return this.#state; }
    getCurrentPhase() { return this.#turnManager.currentPhase; }
    addEventListener(eventName, callback) { this.#eventDispatcher.addEventListener(eventName, callback); }
    removeEventListener(eventName, callback) { this.#eventDispatcher.removeEventListener(eventName, callback); }
    emitEvent(eventName, detail) { console.log(`Game Event: ${eventName}`, detail); this.#eventDispatcher.dispatchEvent(new CustomEvent(eventName, { detail })); }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Game.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Graveyard.js ---
// js/core/Graveyard.js
/**
 * Represents the player's graveyard (discard pile).
 * Stores cards in an array, maintaining order might be relevant.
 */
export class Graveyard { // Using export class
    #cards = []; // Array<Card> - Order might matter

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        // Optional: Check if already in graveyard? Unlikely needed.
        this.#cards.push(cardInstance);
        return true;
    }

    // Remove is less common, but could be needed for "return from graveyard" effects
    removeCard(cardUniqueId) {
        const index = this.#cards.findIndex(card => card.uniqueId === cardUniqueId);
        if (index !== -1) {
            const [removedCard] = this.#cards.splice(index, 1);
            return removedCard;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.find(card => card.uniqueId === cardUniqueId) || null;
    }

    getCards() {
        return [...this.#cards]; // Return copy
    }

    getSize() {
        return this.#cards.length;
    }

    clear() {
        this.#cards = [];
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Graveyard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Hand.js ---
// js/core/Hand.js
/**
 * Represents the player's hand of cards.
 */
export class Hand { // Using export class
    #cards = new Map(); // Map<string, Card> (uniqueId -> CardInstance)
    #maxSize = 7; // As per GDD End Phase rule

    constructor(maxSize = 7) {
        this.#cards = new Map();
        this.#maxSize = maxSize;
    }

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        if (this.#cards.has(cardInstance.uniqueId)) return false; // Avoid duplicates
        this.#cards.set(cardInstance.uniqueId, cardInstance);
        return true;
    }

    removeCard(cardUniqueId) {
        const card = this.#cards.get(cardUniqueId);
        if (card) {
            this.#cards.delete(cardUniqueId);
            return card;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.get(cardUniqueId) || null;
    }

    getCards() {
        return [...this.#cards.values()];
    }

    getSize() {
        return this.#cards.size;
    }

    getMaxSize() {
        return this.#maxSize;
    }

    isOverLimit() {
        return this.getSize() > this.#maxSize;
    }

    clear() {
        this.#cards.clear();
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Hand.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\InstantCard.js ---
// js/core/InstantCard.js

import Card from './Card.js';

/**
 * Represents an Instant Spell card, which has an immediate effect
 * and then typically goes to the graveyard.
 */
export class InstantCard extends Card {
    #effectText;
    #targetType;

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId); // Call base class constructor

        if (cardDefinition.type !== 'Instant') {
            throw new Error(`Card definition "${cardDefinition.name}" is not of type Instant.`);
        }

        this.#effectText = cardDefinition.effect || 'No effect description.';
        // Determine target type (similar logic as Runebinding)
        this.#targetType = this.#determineTargetType(cardDefinition.effect);

        // Instants don't usually have duration
    }

    // --- Getters ---
    get effectText() { return this.#effectText; }
    get targetType() { return this.#targetType; }

    // --- Card Specific Methods ---

     /** Basic heuristic for target type */
    #determineTargetType(effectText = "") {
        const text = effectText.toLowerCase();
        if (text.includes('target creature')) return 'creature';
        if (text.includes('target player')) return 'player';
        if (text.includes('target runebinding')) return 'runebinding';
        if (text.includes('draw') && !text.includes('target')) return 'player_self';
        if (text.includes('restore') && !text.includes('target')) return 'player_self'; // Heal self
        // Add more rules
        return 'none'; // No target needed
    }

    /** Checks if this card requires a target. */
    requiresTarget() {
        return this.#targetType !== 'none' && this.#targetType !== 'player_self';
    }

    /**
     * Overrides base canPlay for Instants.
     * Instants might be playable during more phases (e.g., opponent's turn, attack phase).
     * This depends heavily on your game rules - adjust accordingly!
     * @param {Player} player
     * @param {Game} game
     * @returns {boolean}
     */
    canPlay(player, game) {
        // Base checks (mana, hand)
        if (!super.canPlay(player, game)) return false;

        // --- Timing Restrictions (EXAMPLE - NEEDS YOUR RULES) ---
        const currentPhase = game.getCurrentPhase();
        const isActivePlayer = game.getCurrentPlayer()?.id === player.id;

        // Simple rule: Allow anytime if it's your turn, or during opponent's attack phase?
        // if (isActivePlayer) return true; // Allow anytime on your turn
        // if (!isActivePlayer && currentPhase === 'attack') return true; // Allow during opponent's attack

        // More restrictive rule (like Sorcery speed): Only on your main phase
        if (!isActivePlayer || currentPhase !== 'main') {
             console.log(`Instant ${this.name}: Cannot play during phase ${currentPhase}.`);
             // return false; // Uncomment for Sorcery speed
        }
         // For now, let's allow on player's main phase only for simplicity
         if (!isActivePlayer || currentPhase !== 'main') return false;


        // TODO: Check if target is required and available (similar to Runebinding)
        // if (this.requiresTarget() && !game.hasValidTargets(this.#targetType, player)) return false;

        return true;
    }

    /**
     * Overrides base play method for Instants.
     * Resolves the effect and moves the card to the graveyard.
     * @param {Player} player
     * @param {Game} game
     * @param {string | null} targetId - The uniqueId of the target or null.
     */
    play(player, game, targetId = null) {
        if (!super.play(player, game, targetId)) { // Handles cost, base checks
            return false;
        }

        console.log(`Instant: ${player.name} playing ${this.name} ${targetId ? `on target ${targetId}` : ''}`);

        // Resolve the effect immediately
        const success = this.resolveEffect(targetId, game, player);

        // Regardless of success (usually), move Instant to graveyard after resolving/attempting
        console.log(`Instant: ${this.name} moving to graveyard.`);
        game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'graveyard');

        // If effect failed, maybe log it, but card is usually still spent
        if (!success) {
            console.warn(`Instant: Effect of ${this.name} may have failed to resolve fully.`);
            // Don't refund mana here, it was spent on the attempt
        }

        return success; // Return success status of the *effect*
    }

    /**
     * Executes the instant spell's effect.
     * Needs specific logic for each Instant card.
     * @param {string | null} targetId
     * @param {Game} game
     * @param {Player} castingPlayer
     * @returns {boolean} True if the effect resolved successfully.
     */
    resolveEffect(targetId, game, castingPlayer) {
        console.log(`Instant: Resolving effect of ${this.name} (Target: ${targetId || 'N/A'})`);

        // --- !!! Requires specific logic for EACH Instant card !!! ---
        try {
            let target = null;
            if (targetId) {
                target = game.getPlayer(targetId) || game.findCardInstance(targetId);
                if (!target) {
                     console.warn(`Instant ResolveEffect: Target ${targetId} not found.`);
                     return false; // Target disappeared
                }
            }

            // Example effects based on provided JSON
            switch (this.id) {
                case 'IS001': // Heal
                    castingPlayer.gainLife(4, game); // Assumes Player has gainLife(amount, game)
                    break;
                case 'IS002': // Fireball
                     if (target && target.type === 'Creature') { // Or target instanceof CreatureCard
                         target.takeDamage(3, this, game); // Assumes CreatureCard has takeDamage(amount, source, game)
                     } else return false; // Invalid target
                     break;
                case 'IS003': // Draw (Assuming ID, effect "Draw 2 cards")
                     castingPlayer.drawCards(2, game);
                     break;
                 case 'IS004': // Shield
                     if (target && target.type === 'Creature') {
                         // TODO: Implement damage prevention effect
                         target.applyStatusEffect('shielded', 1); // Prevent damage for 1 tick (this turn)
                         console.log(`${target.name} is shielded from damage this turn.`);
                     } else return false;
                     break;
                 case 'IS005': // Bounce
                      if (target && target.type === 'Creature') {
                           const owner = game.getPlayer(target.ownerId); // Find the owner
                           if (owner) {
                                game.moveCardToZone(target.uniqueId, target.ownerId, 'battlefield', 'hand');
                                console.log(`${target.name} returned to ${owner.name}'s hand.`);
                           } else return false; // Owner not found?
                      } else return false;
                      break;
                 case 'IS006': // Destroy Binding
                      if (target && target.type === 'Runebinding') { // Check if target is a Runebinding instance
                           // How to destroy? If it's on battlefield, move to graveyard
                           if (target.location === 'battlefield') {
                               target.removeEffect(game); // Let the Runebinding clean itself up
                           } else {
                               // If it's somehow targeted elsewhere? Maybe just log error.
                               console.warn(`Cannot destroy Runebinding ${target.name} not on battlefield.`);
                               return false;
                           }
                      } else return false;
                      break;
                 case 'IS007': // Weaken
                      if (target && target.type === 'Creature') {
                          target.applyTemporaryBoost({ attack: -2 }, 1); // Apply negative boost
                          console.log(`${target.name} gets -2 attack this turn.`);
                      } else return false;
                      break;

                // Add cases for all other Instant cards...

                default:
                    console.warn(`Instant ResolveEffect: No specific effect logic for ${this.name} (ID: ${this.id})`);
                    break;
            }
            return true;
        } catch (error) {
            console.error(`Instant ResolveEffect: Error resolving effect for ${this.name}:`, error);
            return false;
        }
    }

    // Override getRenderData if needed
     getRenderData() {
        return {
            ...super.getRenderData(),
            effectText: this.effectText,
            // Instants usually don't have much other state to show
        };
    }
}

// Ensure Player.js has: gainLife(amount, game), drawCards(count, game)
// Ensure CreatureCard.js has: takeDamage(amount, source, game), applyStatusEffect(name, duration), applyTemporaryBoost(boost, duration)
// Ensure RunebindingCard.js has: removeEffect(game)
// Ensure Game.js has: findCardInstance(uniqueId)
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\InstantCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Player.js ---
// js/core/Player.js
import { Deck } from './Deck.js'; // Named import
import { Hand } from './Hand.js'; // Named import
import { Battlefield } from './Battlefield.js'; // Named import
import { Graveyard } from './Graveyard.js'; // Named import
import { generateUniqueId } from '../utils.js'; // Named import
// Card base/subclasses might be needed for instanceof checks later
import Card from './Card.js';
import CreatureCard from './CreatureCard.js';
import { RunebindingCard } from './RunebindingCard.js';
import { InstantCard } from './InstantCard.js';


export default class Player { // Using export default
    #id;
    #name;
    #life = 20;
    #mana = 0;
    #maxMana = 0;
    #deck;
    #hand;
    #battlefield;
    #graveyard;
    #hasDiscardedForMana = false;
    isActivePlayer = false; // Track if it's currently this player's turn (managed by Game)

    constructor(name, deckCardIds, cardDatabase) {
        this.#id = generateUniqueId('player');
        this.#name = name;
        // Instantiate zones with error handling
        try { this.#deck = new Deck(deckCardIds, cardDatabase, this.#id); } catch (e) { throw new Error(`Player ${name} deck init failed: ${e.message}`); }
        this.#hand = new Hand();
        this.#battlefield = new Battlefield();
        this.#graveyard = new Graveyard();
        this.resetStats();
        console.log(`Player: ${this.#name} (ID: ${this.#id}) created.`);
    }

    // --- Getters ---
    get id() { return this.#id; }
    get name() { return this.#name; }
    get life() { return this.#life; }
    get mana() { return this.#mana; }
    get maxMana() { return this.#maxMana; }
    get deck() { return this.#deck; }
    get hand() { return this.#hand; }
    get battlefield() { return this.#battlefield; }
    get graveyard() { return this.#graveyard; }
    get hasDiscardedForMana() { return this.#hasDiscardedForMana; }


    // --- Methods Called by Game ---
    shuffleDeck() { this.#deck.shuffle(); }
    drawCard() { const c = this.#deck.draw(); if(c) { this.#hand.addCard(c); } return c; }
    drawCards(count, game) { let d=[]; for(let i=0;i<count;i++){const c=game?._drawCard(this); if(c)d.push(c); else break;} return d; } // Game handles events
    prepareForTurn() { this.isActivePlayer = true; this.#mana = this.#maxMana; this.#battlefield.untapAll(); this.#hasDiscardedForMana = false; console.log(`Player ${this.#name}: Prepared. Mana: ${this.#mana}/${this.#maxMana}.`); }
    endTurnCleanup(game) { this.isActivePlayer = false; this.#battlefield.getAllCards().forEach(c => { if (typeof c.tickDown === 'function') c.tickDown(game); if (typeof c.endTurnCleanup === 'function') c.endTurnCleanup(true); }); console.log(`Player ${this.#name}: End cleanup.`); this.checkHandSize(game); }
    moveCardBetweenZones(cardUniqueId, fromZone, toZone) { let c=null, o=this.#getZoneObject(fromZone), d=this.#getZoneObject(toZone); if(!o||!d) return null; c=o.removeCard(cardUniqueId); if(c){d.addCard(c); c.location=toZone; return c;} return null; }
    #getZoneObject(zoneName) { switch(zoneName?.toLowerCase()){ case 'deck': return this.#deck; case 'hand': return this.#hand; case 'battlefield': return this.#battlefield; case 'graveyard': return this.#graveyard; default: console.error(`Player ${this.#name}: Invalid zone: ${zoneName}`); return null; } }

    // --- Player Actions ---
    playCard(cardUniqueId, targetId = null, game) {
        if (!game) { console.error("Player.playCard needs game!"); return false; }
        const card = this.#hand.getCard(cardUniqueId);
        if (!card) { console.warn(`${this.name}: Card ${cardUniqueId} not in hand.`); return false; }

        // Use the card's specific canPlay method
        if (!card.canPlay(this, game)) {
             console.log(`Player ${this.name}: Cannot play ${card.name} now.`);
             game.emitEvent('gameLog', { message: `Não pode jogar ${card.name} agora.` });
             return false;
        }
        // TODO: Validate targetId if provided, BEFORE spending mana
        // if(targetId && card.requiresTarget() && !game.isValidTarget(targetId, card.targetType(), this)) {
        //      game.emitEvent('gameLog', { message: `Alvo inválido para ${card.name}.` });
        //      return false;
        // }


        // Spend Mana FIRST
        if (!this.spendMana(card.cost)) { console.error(`${this.name}: Mana spend failed?`); return false; } // Should not fail if canPlay passed
        game.emitEvent('playerStatsChanged', { playerId: this.id, updates: { mana: this.mana }}); // Notify UI mana changed


        // --- Let the CARD instance handle its play logic ---
        // The card's play method should call game.moveCardToZone and apply effects
        const playSuccess = card.play(this, game, targetId);

        if (!playSuccess) {
            // If card.play itself failed AFTER mana was spent (e.g., target invalid at resolution)
            console.warn(`Player ${this.name}: Card ${card.name}'s play method reported failure.`);
            // Card should have moved itself to graveyard in its play() method on failure.
        } else {
             // Emit base cardPlayed event from Player/Game AFTER card.play tries to resolve
             // Card.play can emit more specific events (e.g., 'creatureEntered', 'spellResolved')
             game.emitEvent('cardPlayed', { player: this.getRenderData(), card: card.getRenderData(), targetId });
        }

        return playSuccess;
    }

    discardCardForMana(cardUniqueId, game) {
        if (!game) { console.error("Player.discardCardForMana needs game!"); return false; }
        if (this.#hasDiscardedForMana) { game.emitEvent('gameLog', { message: `Já descartou por mana.` }); return false; }
        if (this.#maxMana >= 10) { game.emitEvent('gameLog', { message: `Mana máxima (10) atingida.` }); return false; }
        const card = this.#hand.getCard(cardUniqueId); if(!card) return false; // Get name before move
        const moved = game.moveCardToZone(cardUniqueId, this.id, 'hand', 'graveyard'); // Game handles event
        if (moved) { this.#maxMana++; this.#mana++; this.#hasDiscardedForMana = true; game.emitEvent('playerStatsChanged', { playerId: this.id, updates: { mana: this.mana, maxMana: this.maxMana }}); console.log(`${this.name} discarded ${card.name}. Mana: ${this.#mana}/${this.#maxMana}.`); return true; }
        return false;
    }
    checkHandSize(game) { // Called during end phase cleanup
        const excess = this.#hand.getSize() - this.#hand.getMaxSize();
        if (excess > 0) {
             console.log(`Player ${this.name}: Must discard ${excess} cards.`);
             game.requestPlayerDiscard(this.id, excess); // Game changes state and emits event
        }
    }

    spendMana(amount) { if(amount<0)return false; if(amount<=this.#mana){this.#mana-=amount; return true;} return false; }
    gainLife(amount, game) { if(amount<=0)return; this.#life+=amount; game?.emitEvent('playerStatsChanged', { playerId: this.id, updates: { life: this.#life }}); game?.emitEvent('gameLog', { message: `${this.name} ganhou ${amount} vida.` }); }
    takeDamage(amount, source, game) { if(amount<=0)return; this.#life-=amount; game?.emitEvent('playerStatsChanged', { playerId: this.id, updates: { life: this.#life }}); game?.emitEvent('gameLog', { message: `${this.name} levou ${amount} dano.` }); if(this.#life<=0){ game?.gameOver(game.getOpponent(this.id)); } }
    resetStats() { this.#life=20; this.#mana=0; this.#maxMana=0; this.#hasDiscardedForMana=false; this.isActivePlayer=false; }

    // --- Combat Related Helpers ---
    canDeclareAttackers() { return this.battlefield.getCreatures().some(c => c.canAttack()); }
    canDeclareBlockers(attacker) { return this.battlefield.getCreatures().some(c => c.canBlock()); } // Basic check

     // --- Rendering Helper ---
     getRenderData() {
        // Provides a safe snapshot for UI/Events, excluding sensitive info or complex objects
        return {
            id: this.id,
            name: this.name,
            life: this.life,
            mana: this.mana,
            maxMana: this.maxMana,
            handSize: this.hand.getSize(),
            deckSize: this.deck.getSize(),
            graveyardSize: this.graveyard.getSize()
        };
     }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Player.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\RunebindingCard.js ---
// js/core/RunebindingCard.js
import Card from './Card.js'; // Correct: Card uses export default

/**
 * Represents a Runebinding card, which can be an enchantment
 * (permanent or temporary) applied to targets or the field.
 */
export class RunebindingCard extends Card { // Using export class
    #effectText;
    #targetType;
    #isTemporary;
    #durationCounters;
    #appliedTo = null; // uniqueId of target or 'field'/'player'

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId);
        if (cardDefinition.type !== 'Runebinding') throw new Error(`Definition "${cardDefinition.name}" is not type Runebinding.`);
        this.#effectText = cardDefinition.effect || 'No effect description.';
        this.#targetType = this.#determineTargetType(cardDefinition.effect);
        this.#isTemporary = cardDefinition.isTemporary || this.#effectText.toLowerCase().includes('this turn') || this.#effectText.toLowerCase().includes('next turn');
        this.#durationCounters = this.#isTemporary ? (cardDefinition.duration || 1) : -1;
    }

    // --- Getters ---
    get effectText() { return this.#effectText; }
    get targetType() { return this.#targetType; }
    get isTemporary() { return this.#isTemporary; }
    get durationCounters() { return this.#durationCounters; }
    get appliedTo() { return this.#appliedTo; }

    // --- Card Specific Methods ---
    #determineTargetType(effectText = "") {
        const text = effectText.toLowerCase();
        if (text.includes('target creature')) return 'creature';
        if (text.includes('target player')) return 'player';
        if (text.includes('draw 2 cards')) return 'player_self'; // Specific case for RB_DRAW2
        if (text.includes('destroy target runebinding')) return 'runebinding';
        // Add more rules
        return 'field'; // Default
    }
    requiresTarget() { return this.#targetType !== 'field' && this.#targetType !== 'player_self'; }

    canPlay(player, game) {
        if (!super.canPlay(player, game)) return false;
        if (game.getCurrentPhase() !== 'main') return false; // Usually main phase
        // TODO: Check if valid target exists (requires Game method)
        // if (this.requiresTarget() && !game.hasValidTargets(this.#targetType, player)) return false;
        return true;
    }

    play(player, game, targetId = null) {
        // Called after Player verifies canPlay and spends mana
        console.log(`Runebinding: ${player.name} playing ${this.name} ${targetId ? `on target ${targetId}` : ''}`);
        const success = this.applyEffect(targetId, game, player);

        if (success) {
            // Determine where it goes (battlefield or graveyard)
            const goesToGraveyard = this.#isTemporary && this.#durationCounters <= 0;
            const destination = goesToGraveyard ? 'graveyard' : 'battlefield';
            const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', destination);

            if (moved && destination === 'battlefield') {
                // Track attachment if it went to field
                if (this.#targetType === 'creature' || this.#targetType === 'player') this.#appliedTo = targetId;
                else if (this.#targetType === 'field') this.#appliedTo = 'field';
                console.log(`Runebinding: ${this.name} now on ${destination} ${this.#appliedTo ? `(applied to ${this.#appliedTo})` : ''}.`);
                // TODO: If attached to creature, update creature state/visuals
            } else if (moved && destination === 'graveyard'){
                console.log(`Runebinding: ${this.name} went directly to graveyard.`);
            } else if (!moved) {
                 console.error(`Runebinding: Failed to move ${this.name} from hand to ${destination}.`);
                 return false; // Movement failed, major issue
            }
        } else {
            // Effect failed (e.g., target invalid), move to graveyard
            console.log(`Runebinding: Effect failed for ${this.name}, moving to graveyard.`);
            game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'graveyard');
        }
        return success; // Return success of the effect application
    }

    applyEffect(targetId, game, castingPlayer) {
        console.log(`Runebinding: Applying effect of ${this.name}`);
        try {
            let target = null;
            if (targetId) {
                target = game.getPlayer(targetId) || game.findCardInstance(targetId);
                if (!target) { console.warn(`ApplyEffect: Target ${targetId} not found.`); return false; }
            }

            switch (this.id) {
                case 'RB001': // Destroy
                    if (target && target instanceof CreatureCard) { target.die(game); this.#durationCounters = 0; } else return false; break;
                case 'RB_DRAW2': // Draw Rune
                    castingPlayer.drawCards(2, game); this.#durationCounters = 0; break;
                case 'RB_SILENCE': // Silence
                    if (target && target instanceof CreatureCard) { target.applyStatusEffect('cant_attack', 2); console.log(`${target.name} silenced.`); } else return false; break; // Duration 2 ticks (opponent's turn + your next)
                case 'RB_POWER': // Power Boost
                    if (target && target instanceof CreatureCard) { target.applyTemporaryBoost({ attack: 2 }, 1); console.log(`${target.name} +2 Atk.`); } else return false; break;
                case 'RB_TOUGH': // Toughness Boost
                    if (target && target instanceof CreatureCard) { target.applyTemporaryBoost({ toughness: 2 }, 1); console.log(`${target.name} +2 Tough.`); } else return false; break;
                default: console.warn(`ApplyEffect: No logic for Runebinding ${this.name}`); break;
            }
            return true;
        } catch (error) { console.error(`ApplyEffect Error for ${this.name}:`, error); return false; }
    }

    removeEffect(game) {
        console.log(`Runebinding: Removing effect of ${this.name}`);
        // TODO: Revert specific effects based on this.id if needed
        // e.g., if it was a static +1/+1 aura, find target and remove boost

        // If the card is still marked as on the battlefield, move it to graveyard
        if (this.location === 'battlefield') {
            game.moveCardToZone(this.uniqueId, this.ownerId, 'battlefield', 'graveyard');
        }
        this.#appliedTo = null;
    }

    tickDown(game) {
        if (!this.#isTemporary || this.#durationCounters <= 0) return false;
        this.#durationCounters--;
        console.log(`Runebinding: ${this.name} ticks left: ${this.#durationCounters}`);
        if (this.#durationCounters <= 0) {
            this.removeEffect(game);
            return true; // Expired
        }
        return false; // Still active
    }

    getRenderData() {
        return { ...super.getRenderData(), effectText: this.effectText, isTemporary: this.isTemporary, duration: this.durationCounters, appliedTo: this.appliedTo };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\RunebindingCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\TurnManager.js ---
// js/core/TurnManager.js
const TURN_PHASES = ['mana', 'draw', 'main', 'attack', 'end'];

export default class TurnManager { // Using export default
    #currentPhaseIndex = 0;
    #turnNumber = 0;

    constructor() { this.#currentPhaseIndex = 0; this.#turnNumber = 0; }
    get currentPhase() { return TURN_PHASES[this.#currentPhaseIndex]; }
    get turnNumber() { return this.#turnNumber; }

    nextPhase() {
        this.#currentPhaseIndex++;
        if (this.#currentPhaseIndex >= TURN_PHASES.length) {
            this.#currentPhaseIndex = 0;
            return { newPhase: this.currentPhase, turnEnded: true };
        }
        return { newPhase: this.currentPhase, turnEnded: false };
    }
    startNewTurn() {
        this.#turnNumber++;
        this.#currentPhaseIndex = 0; // Start at Mana phase
        return this.currentPhase;
    }
    setPhase(phaseName) { const i = TURN_PHASES.indexOf(phaseName); if (i !== -1) this.#currentPhaseIndex = i; }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\TurnManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\network\NetworkManager.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\network\NetworkManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\ScreenManager.js ---
// js/ui/ScreenManager.js

/**
 * Manages the visibility and transitions of different application screens
 * represented by divs with the '.screen' class.
 */
export default class ScreenManager {
    #activeScreenId = null;
    #previousScreenId = null; // Track the previously active screen
    #isTransitioning = false; // Flag to prevent rapid transitions
    #transitionDuration = 300; // Duration of the fade transition in ms

    constructor(transitionDuration = 300) {
        this.#transitionDuration = transitionDuration;
        // Ensure initial state on load (hide all except potentially pre-marked active one)
        // This might conflict if HTML has 'active' pre-set, adjust as needed.
        // $('.screen').not('.active').hide(); // Alternative initial setup
        console.log("ScreenManager initialized.");
    }

    /**
     * Shows the screen with the specified ID, hiding the previously active one.
     * Includes basic fade transitions.
     * @param {string} screenId The ID of the HTML element (div) for the screen to show.
     * @param {boolean} [force=false] - If true, bypass the 'already active' check.
     */
    showScreen(screenId, force = false) {
        if (!force && screenId === this.#activeScreenId) {
            // console.log(`ScreenManager: Screen '${screenId}' is already active.`);
            return; // Don't transition if already the active screen
        }
        if (this.#isTransitioning) {
             console.warn(`ScreenManager: Transition already in progress. Request for '${screenId}' ignored.`);
             return; // Prevent overlapping transitions
        }

        const $currentScreen = this.#activeScreenId ? $(`#${this.#activeScreenId}`) : null;
        const $nextScreen = $(`#${screenId}`);

        if (!$nextScreen.length) {
            console.error(`ScreenManager Error: Screen with ID '${screenId}' not found!`);
            // Fallback: Maybe show the title screen?
            if (this.#activeScreenId !== 'title-screen') {
                console.warn("ScreenManager Fallback: Showing 'title-screen'.");
                this.showScreen('title-screen', true); // Force show title
            }
            return;
        }

        console.log(`ScreenManager: Transitioning from '${this.#activeScreenId || 'none'}' to '${screenId}'`);
        this.#isTransitioning = true;

        // --- Transition Logic ---

        // 1. Fade out the current screen (if one exists)
        if ($currentScreen && $currentScreen.length) {
            $currentScreen.addClass('screen-fade-out'); // Add fade-out class
            setTimeout(() => {
                $currentScreen.removeClass('active screen-fade-out'); // Hide after fade
            }, this.#transitionDuration);
        }

        // 2. Prepare and fade in the next screen
        // Ensure it's ready but invisible initially for the fade-in effect
        $nextScreen.addClass('active screen-prepare-fade-in');

        // Use a tiny delay before starting fade-in to allow browser to apply initial styles
        setTimeout(() => {
            $nextScreen.removeClass('screen-prepare-fade-in').addClass('screen-fade-in'); // Start fade-in
        }, 20); // Small delay (adjust if needed)


        // 3. Clean up after the transition
        setTimeout(() => {
            $nextScreen.removeClass('screen-fade-in'); // Remove fade-in class after duration
            this.#previousScreenId = this.#activeScreenId; // Update previous screen tracker
            this.#activeScreenId = screenId; // Set the new active screen ID
            this.#isTransitioning = false; // Allow new transitions
            console.log(`ScreenManager: Screen '${screenId}' is now active.`);
        }, this.#transitionDuration + 50); // Add a small buffer after duration
    }

    /**
     * Returns the ID of the currently active screen.
     * @returns {string | null}
     */
    getActiveScreenId() {
        return this.#activeScreenId;
    }

    /**
     * Returns the ID of the previously shown screen.
     * Useful for implementing a generic "Back" button.
     * @returns {string | null}
     */
    getPreviousScreenId() {
        return this.#previousScreenId;
    }

    /**
     * Navigates back to the previously shown screen.
     * Optional: Provide a fallback screen ID if no previous screen is recorded.
     * @param {string} [fallbackScreenId='title-screen'] - Screen to go to if no previous screen exists.
     */
    goBack(fallbackScreenId = 'title-screen') {
        if (this.#previousScreenId && this.#previousScreenId !== this.#activeScreenId) {
            console.log(`ScreenManager: Going back to '${this.#previousScreenId}'`);
            this.showScreen(this.#previousScreenId);
        } else {
            console.log(`ScreenManager: No previous screen or cannot go back, going to fallback '${fallbackScreenId}'`);
            this.showScreen(fallbackScreenId);
        }
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\ScreenManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\templates.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\templates.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\UIManager.js ---
// js/ui/UIManager.js - ATUALIZADO (v2.5 - AudioManager Integration)

// Importar os módulos de UI específicos e helpers
import ProfileScreenUI from './screens/ProfileScreenUI.js';       // Tela de Perfil (Simplificada)
import DeckBuilderUI from './screens/DeckBuilderUI.js';         // Construtor de Decks
import BattleScreenUI from './screens/BattleScreenUI.js';        // Tela de Batalha
import OptionsUI from './screens/OptionsUI.js';             // Tela de Opções
import HomeScreenUI from './screens/HomeScreenUI.js';          // Tela Inicial (Notícias)
import DeckManagementScreenUI from './screens/DeckManagementScreenUI.js'; // Nova Tela de Decks
import CardRenderer from './helpers/CardRenderer.js';       // Helper para renderizar cartas
import ZoomHandler from './helpers/ZoomHandler.js';        // Helper para zoom de cartas
// AudioManager não precisa ser importado aqui, ele é injetado

export default class UIManager {
    // --- Core References ---
    #screenManager;
    #accountManager;
    #cardDatabase;
    #audioManager;     // <<<=== Referência para o AudioManager
    #gameInstance = null; // Instância do jogo atual (se houver)
    #localPlayerId = null; // ID do jogador local na partida atual

    // --- UI Module Instances ---
    #profileUI;
    #deckBuilderUI;
    #battleUI;
    #optionsUI;
    #homeUI;
    #deckManagementUI;
    #cardRenderer;
    #zoomHandler;

    constructor(screenManager, accountManager, cardDatabase, audioManager) { // <<<=== Parâmetro audioManager adicionado
        // Armazena as dependências principais
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#audioManager = audioManager; // <<<=== Armazena a instância do AudioManager

        // Instancia helpers
        this.#cardRenderer = new CardRenderer();
        this.#zoomHandler = new ZoomHandler(this.#cardDatabase);

        // --- Instancia os módulos de UI específicos ---
        this.#homeUI = new HomeScreenUI(this.#screenManager, this);
        // Passa AudioManager para OptionsUI
        this.#optionsUI = new OptionsUI(this.#audioManager); // <<<=== Passa AudioManager para OptionsUI
        this.#profileUI = new ProfileScreenUI(
            this.#screenManager, this.#accountManager, this.#cardDatabase,
            this.#cardRenderer, this.#zoomHandler, this
        );
        this.#deckManagementUI = new DeckManagementScreenUI(
            this.#screenManager, this.#accountManager, this.#cardDatabase,
            this.#cardRenderer, this.#zoomHandler, this
        );
        this.#deckBuilderUI = new DeckBuilderUI(
            this.#screenManager, this.#accountManager, this.#cardDatabase,
            this.#cardRenderer, this.#zoomHandler
        );
        // Passa AudioManager para BattleScreenUI
        this.#battleUI = new BattleScreenUI(
             this.#screenManager, this.#accountManager, this.#cardDatabase,
             this.#cardRenderer, this.#zoomHandler, this.#audioManager // Passado para BattleUI
         );

        // Vincula ações permanentes (Top Bar)
        this._bindPermanentUIActions();
        console.log("UIManager (Coordinator) inicializado com AudioManager.");
    }

    // --- Setup para o Jogo ---
    setGameInstance(gameInstance) {
        this.#gameInstance = gameInstance;
        console.log("UI Coordinator: Game instance set.");
        this.#battleUI.setGameInstance(gameInstance); // Informa BattleUI
    }
    setLocalPlayer(playerId) {
        this.#localPlayerId = playerId;
        console.log(`UI Coordinator: Local player set: ${playerId}`);
        this.#battleUI.setLocalPlayer(playerId); // Informa BattleUI
    }

    // --- Controle da Barra Superior (Top Bar) ---
    showTopBar(userData) {
        const $topBar = $('#top-bar');
        if (userData) {
            $topBar.find('#top-bar-username').text(userData.username);
            // TODO: Atualizar o avatar na top bar se o elemento existir
            // const avatarFile = userData.avatar || 'default.png';
            // $topBar.find('#top-bar-avatar-img').attr('src', `assets/images/avatars/${avatarFile}`);
            $topBar.addClass('active');
            console.log("UIManager: Top Bar shown for", userData.username);
        } else {
            console.warn("UIManager: showTopBar called without user data.");
        }
    }
    hideTopBar() {
        $('#top-bar').removeClass('active');
        console.log("UIManager: Top Bar hidden.");
    }

    // --- Delegação de Renderização ---
    async renderHomeScreen() {
        console.log("UI Coordinator: Delegating home screen rendering.");
        await this.#homeUI.render();
    }
    renderProfileScreen() {
        console.log("UI Coordinator: Delegating profile screen rendering.");
        this.#profileUI.render();
    }
    renderDeckManagementScreen() {
        console.log("UI Coordinator: Delegating deck management screen rendering.");
        this.#deckManagementUI.render();
    }
    renderDeckBuilderScreen(deckIdToEdit = null) {
        console.log("UI Coordinator: Delegating deck builder rendering.");
        this.#deckBuilderUI.render(deckIdToEdit);
    }
    renderOptionsScreen() {
         console.log("UI Coordinator: Delegating options screen rendering.");
         this.#optionsUI.render();
    }
    renderInitialGameState() {
        console.log("UI Coordinator: Delegating initial game state rendering.");
         if (!this.#gameInstance || !this.#localPlayerId) {
             console.error("UI Coordinator: Cannot render game state - game/player not set.");
             return;
         }
        this.#battleUI.renderInitialState();
    }

    // --- Método para Salvar Opções (Chamado por main.js ou outro lugar) ---
    // Este método coordena o salvamento das opções e a atualização do AudioManager
    saveOptions() {
        // Verifica se a instância de OptionsUI existe e tem o método _saveOptions
        if (this.#optionsUI && typeof this.#optionsUI._saveOptions === 'function') {
             // Pede para OptionsUI salvar as opções lidas da UI no localStorage
             this.#optionsUI._saveOptions();

             // Informa o AudioManager para recarregar as configurações do localStorage
             if (this.#audioManager) {
                this.#audioManager.updateSettings();
                console.log("UIManager: Delegated options save and updated AudioManager settings.");
             } else {
                 console.warn("UIManager: AudioManager instance not available to update settings.");
             }
        } else {
            console.warn("UIManager: OptionsUI instance or _saveOptions method not found. Cannot save options.");
        }
    }

    // --- Bindings Globais e da Top Bar ---
    _bindPermanentUIActions() {
        console.log("UI Coordinator: Binding permanent UI actions (Top Bar, global)...");
        const self = this; // Armazena 'this' (UIManager) para usar dentro dos listeners

        // --- Helper para adicionar listeners de áudio aos botões da Top Bar ---
        const addTopBarAudioListeners = ($element, sfxClick = 'buttonClick', sfxHover = 'buttonHover') => {
            // Remove listeners antigos para evitar duplicação se _bind for chamado novamente
            $element.off('click.tbaudio').on('click.tbaudio', () => {
                // Toca SFX no clique (Verifica se audioManager existe)
                self.#audioManager?.playSFX(sfxClick);
            });
            $element.off('mouseenter.tbaudio').on('mouseenter.tbaudio', () => {
                // Toca SFX no hover (Verifica se audioManager existe)
                self.#audioManager?.playSFX(sfxHover);
            });
        };

         // Botão Home
         const $btnHome = $('#top-bar-btn-home');
         $btnHome.on('click', async () => { // Ação de clique principal (navegação)
            const currentScreen = self.#screenManager.getActiveScreenId();
            if(currentScreen !== 'home-screen'){
                console.log("UI Coordinator: Navigating to Home Screen...");
                await self.renderHomeScreen();
                self.#screenManager.showScreen('home-screen');
                self.#audioManager?.playBGM('home-screen'); // <<<=== Toca BGM da Home
                console.log("UI Coordinator: Home Screen shown.");
            }
         });
         addTopBarAudioListeners($btnHome); // Adiciona sons de clique/hover ao botão

         // Botão Perfil
         const $btnProfile = $('#top-bar-btn-profile');
         $btnProfile.on('click', () => {
            const currentScreen = self.#screenManager.getActiveScreenId();
            if(currentScreen !== 'profile-screen'){
                 console.log("UI Coordinator: Navigating to Profile Screen...");
                self.renderProfileScreen();
                self.#screenManager.showScreen('profile-screen');
                self.#audioManager?.playBGM('profile-screen'); // <<<=== Toca BGM do Perfil
                 console.log("UI Coordinator: Profile Screen shown.");
            }
         });
         addTopBarAudioListeners($btnProfile);

         // Botão Decks
         const $btnDecks = $('#top-bar-btn-decks');
         $btnDecks.on('click', () => {
            const currentScreen = self.#screenManager.getActiveScreenId();
            if (currentScreen !== 'deck-management-screen') {
                 console.log("UI Coordinator: Navigating to Deck Management Screen...");
                 self.renderDeckManagementScreen();
                 self.#screenManager.showScreen('deck-management-screen');
                 self.#audioManager?.playBGM('deck-management-screen'); // <<<=== Toca BGM dos Decks
                 console.log("UI Coordinator: Deck Management Screen shown.");
             }
         });
         addTopBarAudioListeners($btnDecks);

         // Botão Conectar
         const $btnConnect = $('#top-bar-btn-connect');
         $btnConnect.on('click', () => {
            const currentScreen = self.#screenManager.getActiveScreenId();
             if(currentScreen !== 'connect-screen') {
                 console.log("UI Coordinator: Navigating to Connect Screen...");
                 $('#connect-message').text(''); // Limpa UI da tela connect
                 $('#server-status-section, #join-game-section').hide();
                 self.#screenManager.showScreen('connect-screen');
                 self.#audioManager?.playBGM('connect-screen'); // <<<=== Toca BGM de Conectar
                  console.log("UI Coordinator: Connect Screen shown.");
             }
         });
         addTopBarAudioListeners($btnConnect);

         // Botão Opções
         const $btnOptions = $('#top-bar-btn-options');
         $btnOptions.on('click', () => {
            const currentScreen = self.#screenManager.getActiveScreenId();
             if(currentScreen !== 'options-screen') {
                 console.log("UI Coordinator: Navigating to Options Screen...");
                 self.renderOptionsScreen(); // Renderiza opções (carrega valores atuais)
                 self.#screenManager.showScreen('options-screen');
                 self.#audioManager?.playBGM('options-screen'); // <<<=== Toca BGM de Opções
                 console.log("UI Coordinator: Options Screen shown.");
             }
         });
         addTopBarAudioListeners($btnOptions);

         // Botão Logout
         const $btnLogout = $('#top-bar-btn-logout');
         $btnLogout.on('click', () => { // Ação de clique principal (logout)
             console.log("Top Bar: Logout button clicked.");
             self.#audioManager?.stopBGM(); // Para a música atual antes de deslogar
             self.#accountManager.logout();
             self.hideTopBar();
             $('#screens-container').removeClass('with-top-bar');
             self.#screenManager.showScreen('title-screen');
             self.#audioManager?.playBGM('title-screen'); // <<<=== Toca BGM da Title após logout
              console.log("UI Coordinator: Logged out, showing Title Screen.");
             // O som de clique já é adicionado por addTopBarAudioListeners
         });
         addTopBarAudioListeners($btnLogout); // Adiciona sons de clique/hover

         // Listener global de ESC para fechar overlays (zoom)
         $(document).off('keydown.uimclose').on('keydown.uimclose', (e) => {
             if (e.key === "Escape") {
                 self.#zoomHandler?.closeZoom();
             }
         });
    }

} // End class UIManager (Coordinator)
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\UIManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\CardRenderer.js ---
// js/ui/helpers/CardRenderer.js

/**
 * Módulo Helper para renderizar o HTML das cartas.
 */
export default class CardRenderer {

    /**
     * Gera o HTML para uma carta no tamanho de batalha.
     * @param {object} cardData - Os dados da carta (resultado de getRenderData() ou definição).
     * @param {string} [location='hand'] - A localização atual (afeta classes/atributos).
     * @returns {jQuery|null} Objeto jQuery representando a carta ou null.
     */
    renderCard(cardData, location = 'hand') {
        if (!cardData) return null;
        const cardClass = 'card'; // Sempre .card para batalha
        const uniqueIdAttr = `data-card-unique-id="${cardData.uniqueId}"`; // Sempre adicionar uniqueId para instâncias de jogo
        const baseIdAttr = `data-card-id="${cardData.id}"`;
        const cardName = cardData.name || 'Unknown Card';
        const imageSrc = cardData.imageSrc || 'assets/images/cards/default.png';

        // Tooltip (mais detalhado para batalha)
        const tooltipParts = [
            `${cardName} [${cardData.cost ?? '?'}]`,
            `${cardData.type}${cardData.tribe ? ` - ${cardData.tribe}` : ''}`,
        ];
        if (cardData.attack !== undefined) { // Base Attack/Toughness da Definição para tooltip
             const baseAttack = cardData.baseAttack ?? cardData.attack ?? '?';
             const baseToughness = cardData.baseToughness ?? cardData.toughness ?? '?';
             tooltipParts.push(` ${baseAttack}/${baseToughness}`);
        }
        tooltipParts.push(cardData.description || cardData.effectText || '');
        const tooltip = tooltipParts.join('\n');

        // Estrutura HTML
        let cardHtml = `<div class="${cardClass} ${cardData.type?.toLowerCase() || ''}"
                           ${uniqueIdAttr} ${baseIdAttr}
                           title="${tooltip}"
                           style="background-image: url('${imageSrc}')">`;

        // Overlays (Cost, Name, Stats)
        cardHtml += `<div class="card-overlay card-cost">${cardData.cost ?? '?'}</div>`;
        cardHtml += `<div class="card-overlay card-name">${cardName}</div>`;
        if (cardData.type === 'Creature') {
            // Mostra stats ATUAIS (calculados) vindos de cardData.getRenderData()
            const displayAttack = cardData.attack ?? '?';
            const displayToughness = cardData.currentToughness ?? cardData.toughness ?? '?'; // Prefere currentToughness
            cardHtml += `<div class="card-overlay card-stats">
                            <span class="card-attack">${displayAttack}</span>/<span class="card-toughness">${displayToughness}</span>
                         </div>`;
        }
        // Adicionar indicadores visuais para status (tapped, sickness, etc.)
        // if (cardData.isTapped) cardHtml += `<div class="card-status-icon tapped-icon">↷</div>`;
        // if (cardData.hasSummoningSickness) cardHtml += `<div class="card-status-icon sickness-icon">🌀</div>`;

        cardHtml += `</div>`; // Fecha card div
        const $card = $(cardHtml);
        $card.data('card-name', cardName); // Armazena nome para fácil acesso
        // Aplicar classes de estado visual baseadas nos dados recebidos
        $card.toggleClass('tapped', !!cardData.isTapped);
        $card.toggleClass('has-summoning-sickness', !!cardData.hasSummoningSickness);
        $card.toggleClass('cannot-act', !(cardData.canAttack ?? true)); // Exemplo
        if(cardData.statusEffects) { $card.toggleClass('shielded', !!cardData.statusEffects['shielded']); $card.toggleClass('silenced', !!cardData.statusEffects['silenced'] || !!cardData.statusEffects['cant_attack']); }

        return $card;
    }

    /**
     * Gera o HTML para uma mini-carta (Coleção, Deck Builder).
     * @param {object} cardDefinition - A definição da carta do cardDatabase.
     * @param {string} [location='collection'] - 'collection' ou 'deck'.
     * @returns {jQuery|null} Objeto jQuery representando a mini-carta ou null.
     */
    renderMiniCard(cardDefinition, location = 'collection') {
        if (!cardDefinition) return null;
        const cardClass = 'mini-card';
        const locationClass = location === 'deck' ? 'in-deck' : 'in-collection';
        const baseIdAttr = `data-card-id="${cardDefinition.id}"`; // Mini cards só precisam do ID base
        const cardName = cardDefinition.name || 'Unknown Card';
        const imageSrc = cardDefinition.image_src || 'assets/images/cards/default.png';

        // Tooltip (pode ser igual ao renderCard ou simplificado)
        const tooltipParts = [
            `${cardName} [${cardDefinition.cost ?? '?'}]`,
            `${cardDefinition.type}${cardDefinition.tribe ? ` - ${cardDefinition.tribe}` : ''}`,
        ];
        if (cardDefinition.attack !== undefined) {
            tooltipParts.push(` ${cardDefinition.attack}/${cardDefinition.toughness}`);
        }
        tooltipParts.push(cardDefinition.description || cardDefinition.effect || '');
        const tooltip = tooltipParts.join('\n');

        // Estrutura HTML (background na div principal)
        const $card = $(`
            <div class="${cardClass} ${locationClass}"
                 ${baseIdAttr}
                 title="${tooltip}"
                 style="background-image: url('${imageSrc}')">
                 <div class="card-name-overlay">${cardName}</div>
                 <!-- Mini-cards geralmente não mostram stats diretamente -->
             </div>`);

        $card.data('card-name', cardName);
        return $card;
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\CardRenderer.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\ZoomHandler.js ---
// js/ui/helpers/ZoomHandler.js - ATUALIZADO

export default class ZoomHandler {
    #cardDatabase;
    #activeOverlayId = null; // Controla qual overlay está ativo

    // --- ATUALIZAÇÃO AQUI ---
    // Adicionada a entrada para 'deck-management-screen'
    #overlayMap = {
        // 'profile-screen': { overlay: '#image-zoom-overlay', image: '#zoomed-image' }, // Não é mais necessário no perfil
        'deck-builder-screen': { overlay: '#deckbuilder-image-zoom-overlay', image: '#deckbuilder-zoomed-image' },
        'battle-screen': { overlay: '#battle-image-zoom-overlay', image: '#battle-zoomed-image' },
        'deck-management-screen': { overlay: '#deck-management-zoom-overlay', image: '#deck-management-zoomed-image' } // <<<=== ENTRADA ADICIONADA
    };
    // --- FIM DA ATUALIZAÇÃO ---

    constructor(cardDatabase) {
        if (!cardDatabase) {
            throw new Error("ZoomHandler requires cardDatabase.");
        }
        this.#cardDatabase = cardDatabase;
        this._bindGlobalClose(); // Bind ESC key globally
        console.log("ZoomHandler initialized.");
    }

    /**
     * Manipula o evento de clique (ou contextmenu) para exibir o zoom.
     * Determina o contexto (tela) e mostra o overlay correto.
     * @param {Event} event - O evento de clique/contextmenu.
     * @param {Game | null} [gameInstance=null] - Instância do jogo (opcional, para buscar dados de cartas em jogo).
     */
    handleZoomClick(event, gameInstance = null) {
        event.preventDefault(); // Previne menu de contexto padrão
        event.stopPropagation(); // Impede propagação

        const $card = $(event.currentTarget);
        const cardUniqueId = $card.data('card-unique-id'); // Para cartas em jogo
        const cardBaseId = $card.data('card-id');       // Para cartas na coleção/DB

        let cardData = null;
        let imageSrc = null;
        let cardName = 'Carta Desconhecida';

        // 1. Tenta obter dados da instância do jogo (se houver e for carta em jogo)
        if (cardUniqueId && gameInstance) {
            // Precisa garantir que gameInstance.findCardInstance existe e funciona
             try {
                 const gameCard = gameInstance.findCardInstance(cardUniqueId);
                 if (gameCard) {
                     cardData = gameCard.getRenderData(); // Pega os dados atuais da instância
                     imageSrc = cardData.imageSrc;
                     cardName = cardData.name;
                     console.log(`ZoomHandler: Found card in game instance: ${cardName} (${cardUniqueId})`);
                 } else {
                      console.log(`ZoomHandler: Card unique ID ${cardUniqueId} not found in game instance.`);
                 }
             } catch (e) {
                 console.error("ZoomHandler: Error calling gameInstance.findCardInstance:", e);
             }
        }

        // 2. Se não encontrou no jogo ou não era carta de jogo, busca na database pelo ID base
        if (!imageSrc && cardBaseId) {
            cardData = this.#cardDatabase[cardBaseId];
            if (cardData) {
                imageSrc = cardData.image_src; // Certifique-se que a prop é image_src no JSON
                cardName = cardData.name;
                console.log(`ZoomHandler: Found card in database: ${cardName} (${cardBaseId})`);
            }
        }

        // 3. Se encontrou uma imagem, determina o overlay e mostra
        if (imageSrc) {
            const $screen = $card.closest('.screen'); // Encontra a tela pai
            if (!$screen.length) {
                console.error("ZoomHandler: Could not find parent .screen for the card.");
                return;
            }
            const screenId = $screen.attr('id');
            const mapping = this.#overlayMap[screenId]; // Pega o mapeamento para essa tela

             console.log(`ZoomHandler: Handling zoom for screen '${screenId}'. Mapping found:`, mapping); // Log para debug

            if (mapping) {
                const $overlay = $(mapping.overlay);
                const $image = $(mapping.image);

                if ($overlay.length && $image.length) {
                    this.closeZoom(); // Fecha qualquer zoom anterior
                    $image.attr('src', imageSrc).attr('alt', cardName);
                    $overlay.addClass('active');
                    this.#activeOverlayId = mapping.overlay; // Guarda qual overlay está ativo
                    console.log(`ZoomHandler: Overlay ${this.#activeOverlayId} activated.`);
                } else {
                    console.error(`ZoomHandler Error: Zoom overlay ('${mapping.overlay}') or image ('${mapping.image}') element not found in the DOM for screen '${screenId}'!`);
                }
            } else {
                console.warn(`ZoomHandler Warning: Zoom mapping not found for screen: ${screenId}. Cannot display zoom.`);
            }
        } else {
            console.log(`ZoomHandler: No image source found for card ${cardUniqueId || cardBaseId}. Cannot display zoom.`);
        }
    }

    /**
     * Fecha o overlay de zoom atualmente ativo.
     * Este é um método PÚBLICO.
     */
    closeZoom() {
        if (this.#activeOverlayId) {
            $(this.#activeOverlayId).removeClass('active');
            // Limpa a imagem para evitar flash de imagem antiga
            $(`${this.#activeOverlayId} img`).attr('src', '');
            console.log(`ZoomHandler: Closed zoom overlay: ${this.#activeOverlayId}`);
            this.#activeOverlayId = null;
        }
        // Fallback para fechar todos, caso o estado se perca (menos provável agora)
        else if ($('.image-zoom-overlay.active').length > 0) {
            console.warn("ZoomHandler: Closing zoom overlay without activeOverlayId set. Closing all.");
            $('.image-zoom-overlay').removeClass('active');
            $('.image-zoom-overlay img').attr('src', '');
        }
    }

    /**
     * Vincula o fechamento global (ESC).
     */
    _bindGlobalClose() {
        // Fechar com ESC
        $(document).off('keydown.zoomhandler').on('keydown.zoomhandler', (e) => {
            if (e.key === "Escape") {
                this.closeZoom(); // Chama o método público
            }
        });
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\ZoomHandler.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\battleScreenTemplate.js ---
// js/ui/html-templates/battleScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Batalha principal.
 * @returns {string} HTML da tela de batalha.
 */
export function generateBattleScreenHTML() {
    // --- CAMINHO DAS IMAGENS ---
    const deckCoverImage = 'assets/images/cards/card_cover.png';
    const graveyardPlaceholderImage = 'assets/images/ui/graveyard.png'; // Certifique-se que esta imagem existe no caminho

    return `
        <div id="battle-screen" class="screen battle-screen-layout">

            <!-- Área do Oponente (Topo) -->
            <div class="player-area opponent">
                <div class="player-info">
                    <div class="player-avatar">
                         <img id="opponent-avatar-img" src="assets/images/avatars/default.png" alt="Opponent Avatar">
                    </div>
                    <div class="player-stats">
                        <span id="opponent-name">Oponente</span>
                        <div class="resource life">❤️ <span id="opponent-life">20</span></div>
                        <div class="resource mana">💧 <span id="opponent-mana">0</span>/<span id="opponent-max-mana">0</span></div>
                    </div>
                </div>
                <div class="hand opponent-hand-area">
                    <span>Mão Oponente: <span id="opponent-hand-count">0</span> cartas</span>
                    <div id="opponent-hand" class="card-zone">
                        <!-- Cartas escondidas ou contagem -->
                    </div>
                </div>
                 <div class="player-zones">
                     
                     <div class="deck-zone" title="Deck do Oponente">
                         <img id="opponent-deck-img" src="${deckCoverImage}" alt="Deck Oponente" class="zone-image deck-image"> {/* <-- Imagem do Deck Adicionada */}
                         <div class="deck-count" id="opponent-deck-count">0</div>
                         <span>Deck</span>
                     </div>
                    
                     <div class="graveyard-zone" title="Cemitério do Oponente">
                         <img id="opponent-graveyard-img" src="${graveyardPlaceholderImage}" alt="Cemitério Oponente" class="zone-image graveyard-image"> {/* <-- Imagem do Cemitério Adicionada */}
                         <div class="graveyard-count" id="opponent-graveyard-count">0</div>
                         <span>Cemitério</span>
                     </div>
                 </div>
                <div id="opponent-battlefield" class="battlefield card-zone">
                    <!-- Criaturas e Runebindings do oponente -->
                </div>
            </div>

            <!-- Área Central (Controles, Log) -->
            <div class="center-area">
                <div class="game-log-container scrollable-list">
                    <ul id="game-log" class="game-log">
                        <li>Log da Partida:</li>
                        <!-- Mensagens serão adicionadas aqui -->
                    </ul>
                </div>
                <div class="turn-info">
                    Turno <span id="turn-number">1</span> - Fase: <span id="phase-indicator">Mana</span>
                    (<span id="current-player-indicator">Jogador</span>)
                </div>
                 <div class="turn-controls">
                    <button id="btn-pass-phase">Passar Fase</button>
                    <button id="btn-end-turn">Finalizar Turno</button>
                    <button id="btn-discard-mana" title="Descartar 1 carta para ganhar +1 Mana Máx (1x por turno)">Descartar p/ Mana</button>
                    <!-- Botões de combate serão adicionados/mostrados pelo UIManager -->
                    <button id="btn-confirm-attack" style="display: none;">Confirmar Ataque</button>
                    <button id="btn-confirm-blocks" style="display: none;">Confirmar Bloqueios</button>
                </div>
                <div id="action-feedback" class="action-feedback-area">
                    <!-- Mensagens como "Selecione um alvo", "Descartar X", etc. -->
                </div>
            </div>

            <!-- Área do Jogador (Baixo) -->
            <div class="player-area local-player">
                 <div id="player-battlefield" class="battlefield card-zone">
                    <!-- Criaturas e Runebindings do jogador -->
                </div>
                 <div class="player-zones">
                     
                      <div class="deck-zone" title="Seu Deck">
                          <img id="player-deck-img" src="${deckCoverImage}" alt="Seu Deck" class="zone-image deck-image"> {/* <-- Imagem do Deck Adicionada */}
                          <div class="deck-count" id="player-deck-count">0</div>
                          <span>Deck</span>
                      </div>
                      
                      <div class="graveyard-zone" title="Seu Cemitério">
                           <img id="player-graveyard-img" src="${graveyardPlaceholderImage}" alt="Seu Cemitério" class="zone-image graveyard-image"> {/* <-- Imagem do Cemitério Adicionada */}
                           <div class="graveyard-count" id="player-graveyard-count">0</div>
                           <span>Cemitério</span>
                      </div>
                 </div>
                <div id="player-hand" class="hand card-zone">
                    <!-- Suas cartas na mão -->
                </div>
                 <div class="player-info">
                     <div class="player-avatar">
                         <img id="player-avatar-img" src="assets/images/avatars/default.png" alt="Player Avatar">
                     </div>
                     <div class="player-stats">
                        <span id="player-name">Você</span>
                        <div class="resource life">❤️ <span id="player-life">20</span></div>
                        <div class="resource mana">💧 <span id="player-mana">0</span>/<span id="player-max-mana">0</span></div>
                    </div>
                </div>
            </div>

            <!-- Overlay para Zoom da Imagem de Carta -->
            <div id="battle-image-zoom-overlay" class="image-zoom-overlay">
                 <img id="battle-zoomed-image" src="" alt="Zoomed Card">
             </div>

             <!-- Overlay para Confirmação/Resultado do Jogo -->
             <div id="game-over-overlay" class="game-over-overlay">
                 <div id="game-over-message">Fim de Jogo!</div>
                 <button id="btn-back-to-profile">Voltar ao Perfil</button>
             </div>

        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\battleScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\connectScreenTemplate.js ---
// js/ui/html-templates/connectScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Conexão/Criação de Partida.
 * Contém lógica simulada para criar/entrar em jogos.
 * @returns {string} HTML da tela de conexão.
 */
export function generateConnectScreenHTML() {
    // A lógica real de rede não está aqui, apenas a estrutura da UI
    return `
        <div id="connect-screen" class="screen connect-layout">
        <img class="connect-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>Conectar e Jogar</h2>
            

            <div class="connect-options">
                <!-- Opção 1: Criar um Jogo (Simulado) -->
                <div class="connect-section">
                    <h3>Criar Partida</h3>
                    <img class="connect-host" src="assets/images/ui/host.png" alt="Runebound Clash Logo" class="title-logo">
                    <button id="btn-create-server">Criar Jogo (Host)</button>

                    <div id="server-status-section" style="display: none; margin-top: 15px; padding: 10px; border: 1px solid #ccc;">
                        <p>Status: <strong id="server-ip-code">Aguardando conexão...</strong></p>
                        <p>(Aguardando oponente...)</p>
                        <button id="btn-cancel-hosting">Cancelar Criação</button>
                    </div>
                </div>

                <!-- Opção 2: Entrar em um Jogo (Simulado) -->
                <div class="connect-section">
                    <h3>Entrar em Partida</h3>
                    <img class="connect-join" src="assets/images/ui/join.png" alt="Runebound Clash Logo" class="title-logo">
                    <button id="btn-show-join-options">Procurar Jogo (Join)</button>

                    <div id="join-game-section" style="display: none; margin-top: 15px;" class="form-container">
                         <div class="form-group">
                            <label for="opponent-ip">Código/IP do Host:</label>
                            <input type="text" id="opponent-ip" placeholder="Insira o código">
                        </div>
                         <div class="form-actions">
                            <button id="btn-connect-to-server">Conectar</button>
                            <!-- Poderia ter um botão para cancelar/voltar -->
                        </div>
                    </div>
                </div>
            </div>

            <p id="connect-message" class="message" style="margin-top: 20px;"></p>

            <div class="connect-actions">
                <button id="btn-connect-back-to-main">Voltar ao Perfil</button>
            </div>

            <!-- Futuro: Lista de Jogos Abertos/Amigos Online -->

        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\connectScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\createAccountScreenTemplate.js ---
// js/ui/html-templates/createAccountScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Criação de Conta.
 * @returns {string} HTML da tela de criação de conta.
 */
export function generateCreateAccountScreenHTML() {
    return `
        <div id="create-account-screen" class="screen">
        <img class="create-account-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>CRIAR CONTA NOVA</h2>
            <form id="create-account-form" class="form-container">
                <div class="form-group">
                    <label for="create-username">Nome de Usuário (min 3):</label>
                    <input type="text" id="create-username" name="username" required minlength="3">
                </div>
                <div class="form-group">
                    <label for="create-password">Senha:</label>
                    <input type="password" id="create-password" name="password" required>
                    <!-- Poderia adicionar confirmação de senha se desejado -->
                    <!--
                    <label for="create-confirm-password">Confirmar Senha:</label>
                    <input type="password" id="create-confirm-password" name="confirm_password" required>
                    -->
                </div>
                <div class="form-actions">
                    <button type="submit">Criar Conta</button>
                    <button type="button" id="btn-create-back-to-title">Voltar</button>
                </div>
            </form>
            <p id="create-account-message" class="message"></p>
            
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\createAccountScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckBuilderScreenTemplate.js ---
// js/ui/html-templates/deckBuilderScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela do Construtor de Decks.
 * ATUALIZADO: Texto do botão Voltar para refletir a navegação para a tela de gerenciamento.
 * Requer a biblioteca SortableJS para a funcionalidade de arrastar e soltar.
 * @returns {string} HTML da tela do construtor de decks.
 */
export function generateDeckBuilderScreenHTML() { // <<<--- Certifique-se que 'export' está aqui
    return `
        <div id="deck-builder-screen" class="screen deck-builder-layout">
            <h2 id="deck-builder-title">Construtor de Decks</h2>

            <!-- Área Superior: Nome do Deck e Controles Principais -->
            <div class="deck-builder-top-bar">
                <div class="form-group">
                    <label for="db-deck-name">Nome do Deck:</label>
                    <input type="text" id="db-deck-name" placeholder="Meu Novo Deck" maxlength="30">
                </div>
                <div class="deck-info">
                     <span id="db-deck-count">0</span>/40 cartas <!-- Contador principal na barra -->
                     <span id="db-deck-validity">(Inválido)</span> <!-- Status de validade -->
                </div>
                <div class="deck-actions">
                    <button id="btn-save-deck" disabled>Salvar Deck</button>
                    <button id="btn-clear-deck">Limpar Deck</button>
                    <!-- Texto do botão atualizado para refletir o destino -->
                    <button id="btn-deck-builder-back">Voltar aos Decks</button> <!-- ID permanece o mesmo, texto mudou -->
                </div>
            </div>
            <p id="deck-builder-message" class="message"></p> <!-- Mensagens de feedback -->

            <!-- Área Principal: Coleção e Deck Atual -->
            <div class="deck-builder-main-area">

                <!-- Painel Esquerdo: Coleção Disponível e Filtros -->
                <div class="deck-builder-panel collection-panel">
                    <h3>Coleção Disponível (<span id="db-collection-count">0</span>)</h3>
                    <div class="filters">
                        <input type="text" id="db-filter-name" placeholder="Filtrar por nome...">
                        <select id="db-filter-type">
                            <option value="">Tipo</option>
                            <option value="Creature">Criatura</option>
                            <option value="Runebinding">Runebinding</option>
                            <option value="Instant">Instantânea</option>
                        </select>
                        <select id="db-filter-cost">
                            <option value="">Custo</option>
                            <!-- Opções de custo preenchidas dinamicamente ou ter valores fixos -->
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7+</option>
                        </select>
                        <select id="db-filter-tribe">
                            <option value="">Tribo</option>
                            <!-- Opções de tribo preenchidas dinamicamente ou ter valores fixos -->
                            <option value="Elf">Elfo</option>
                            <option value="Dwarf">Anão</option>
                            <option value="Beast">Besta</option>
                            <option value="Dragon">Dragão</option>
                            <option value="Undead">Morto-vivo</option>
                            <option value="Elemental">Elemental</option>
                            <option value="Human">Humano</option>
                            <option value="Construct">Construto</option>
                            <option value="Spirit">Espírito</option>
                            <option value="None">Nenhuma</option>
                        </select>
                    </div>
                    <div id="db-available-cards" class="card-list scrollable-list">
                        <!-- Mini-cards da coleção filtrada são renderizados aqui -->
                        <p class="placeholder-message">(Carregando coleção...)</p>
                    </div>
                </div>

                <!-- Painel Direito: Deck Atual Sendo Construído -->
                <div class="deck-builder-panel deck-panel">
                     <!-- Contador secundário dentro do painel -->
                    <h3>Deck Atual (<span id="db-deck-count-display">0</span>/40)</h3>
                    <p class="subtle-text">Arraste cartas aqui ou para fora.</p>
                     <div id="db-current-deck" class="card-list scrollable-list">
                        <!-- Mini-cards no deck atual são renderizados aqui -->
                         <p class="placeholder-message">(Arraste cartas da coleção para cá)</p>
                    </div>
                </div>

            </div>
             <!-- Overlay para Zoom da Imagem (específico ou global) -->
             <div id="deckbuilder-image-zoom-overlay" class="image-zoom-overlay">
                 <img id="deckbuilder-zoomed-image" src="" alt="Zoomed Card">
             </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckBuilderScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckManagementScreenTemplate.js ---
// js/ui/html-templates/deckManagementScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Gerenciamento de Decks e Coleção.
 * @returns {string} HTML da tela.
 */
export function generateDeckManagementScreenHTML() { 

    return `
        <div id="deck-management-screen" class="screen deck-management-layout">
            <h2>Gerenciar Decks e Coleção</h2>

            <div class="deck-management-main-area">

                <!-- Coluna Esquerda: Decks -->
                <div class="deck-management-left-column">
                    <div class="profile-section profile-decks">
                        <h3>Meus Decks</h3>
                         <ul id="deck-management-list" class="scrollable-list deck-list-profile">
                             <li>(Carregando decks...)</li>
                         </ul>
                         <button id="btn-create-new-deck" class="button-primary">Criar Novo Deck</button>
                         <p id="deck-mgmt-message" class="message" style="margin-top: 10px;"></p>
                    </div>
                </div>

                <!-- Coluna Direita: Coleção -->
                <div class="deck-management-right-column">
                     <div class="profile-section profile-collection">
                        <h3>Coleção (<span id="deck-mgmt-collection-count">0</span> cartas)</h3>

                        <!-- Filtros da Coleção -->
                        <div class="filters collection-filters">
                            <input type="text" id="deck-mgmt-filter-name" placeholder="Filtrar por nome...">
                            <select id="deck-mgmt-filter-type">
                                <option value="">Tipo</option>
                                <option value="Creature">Criatura</option>
                                <option value="Runebinding">Runebinding</option>
                                <option value="Instant">Instantânea</option>
                            </select>
                            <select id="deck-mgmt-filter-cost">
                                <option value="">Custo</option>
                                <!-- Opções preenchidas dinamicamente -->
                            </select>
                            <select id="deck-mgmt-filter-tribe">
                                <option value="">Tribo</option>
                                <!-- Opções preenchidas dinamicamente -->
                            </select>
                        </div>

                        <p class="subtle-text">Clique com o botão direito do mouse para ampliar a carta</p>
                        <div id="deck-management-collection" class="card-grid scrollable-list">
                            <p>(Carregando coleção...)</p>
                        </div>
                    </div>
                </div>
            </div>

             <!-- Overlay para Zoom da Imagem -->
             <div id="deck-management-zoom-overlay" class="image-zoom-overlay">
                 <img id="deck-management-zoomed-image" src="" alt="Zoomed Card">
             </div>

        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckManagementScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\homeScreenTemplate.js ---
// js/ui/html-templates/homeScreenTemplate.js

/**
 * Gera a string HTML para a Tela Inicial (Mural de Notícias).
 * @returns {string} HTML da tela inicial.
 */
export function generateHomeScreenHTML() {
    return `
        <div id="home-screen" class="screen home-layout">
            <h2>Notícias e Novidades</h2>

            <!-- Área Principal: Feed ou Detalhe -->
            <div class="home-content-area">

                <!-- Feed de Notícias (inicialmente visível) -->
                <div id="news-feed-container" class="scrollable-list news-feed">
                    <p class="placeholder-message">Carregando notícias...</p>
                    <!-- Notícias serão inseridas aqui pelo JS -->
                </div>

                <!-- Detalhe da Notícia (inicialmente escondido) -->
                <div id="news-detail-container" class="news-detail-view" style="display: none;">
                    <button id="btn-back-to-news-feed" class="button-back">< Voltar</button>
                    <h3 id="news-detail-title">Título da Notícia</h3>
                    <img id="news-detail-image" src="" alt="Imagem da Notícia" style="display: none;" class="news-image-detail"/>
                    <div id="news-detail-content" class="news-content-detail scrollable-list">
                        <p>Conteúdo completo da notícia...</p>
                    </div>
                </div>

            </div>

            <!-- Botão Jogar -->
            <button id="btn-goto-connect-from-home" class="button-play" title="Encontrar Partida">
                 <span role="img" aria-label="Jogar">⚔️</span> Jogar
            </button>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\homeScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\loginScreenTemplate.js ---
// js/ui/html-templates/loginScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Login.
 * @returns {string} HTML da tela de login.
 */
export function generateLoginScreenHTML() {
    return `
        <div id="login-screen" class="screen">
            <img class="login-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>LOGIN</h2>
            
            <form id="login-form" class="form-container">
                <div class="form-group">
                    <label for="login-username">Nome de Usuário:</label>
                    <input type="text" id="login-username" name="username" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Senha:</label>
                    <input type="password" id="login-password" name="password" required>
                </div>
                <div class="form-actions">
                    <button type="submit">Entrar</button>
                    <button type="button" id="btn-login-back-to-title">Voltar</button>
                </div>
            </form>
            <p id="login-message" class="message"></p>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\loginScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\optionsScreenTemplate.js ---
// js/ui/html-templates/optionsScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela de Opções.
 * ATUALIZADO: Adicionados checkboxes para Mute.
 * @returns {string} HTML da tela de opções.
 */
export function generateOptionsScreenHTML() {
    return `
        <div id="options-screen" class="screen options-layout">

            <h2>Opções do Jogo</h2>

            <div class="options-container scrollable-list">

                <fieldset class="options-group">
                    <legend>Áudio</legend>
                    <div class="option-item">
                        <label for="opt-music-volume">Volume da Música:</label>
                        <input type="range" id="opt-music-volume" min="0" max="100" step="1" value="80">
                        <span class="volume-value">80%</span>
                        </div>
                   
                    <div class="option-item">
                        <label for="opt-mute-music">Silenciar Música:</label>
                        <input type="checkbox" id="opt-mute-music">
                        </div>
                   
                    <div class="option-item">
                        <label for="opt-sfx-volume">Volume dos Efeitos:</label>
                        <input type="range" id="opt-sfx-volume" min="0" max="100" step="1" value="100">
                        <span class="volume-value">100%</span>
                        </div>
                   
                     <div class="option-item">
                         <label for="opt-mute-sfx">Silenciar Efeitos:</label>
                         <input type="checkbox" id="opt-mute-sfx">
                         </div>
                   
                </fieldset>

                <fieldset class="options-group">
                    <legend>Gráficos</legend>
                    
                     <div class="option-item">
                        <label for="opt-graphics-quality">Qualidade Gráfica:</label>
                        <select id="opt-graphics-quality">
                            <option value="low">Baixa</option>
                            <option value="medium" selected>Média</option>
                            <option value="high">Alta</option>
                        </select>
                    </div>
                    <div class="option-item">
                        <label for="opt-card-animations">Animações das Cartas:</label>
                        <input type="checkbox" id="opt-card-animations" checked>
                    </div>
                </fieldset>

                <fieldset class="options-group">
                    <legend>Interface</legend>
                   
                     <div class="option-item">
                        <label for="opt-language">Idioma:</label>
                        <select id="opt-language">
                            <option value="pt-BR" selected>Português (BR)</option>
                            <option value="en-US">English (US)</option>
                        </select>
                    </div>
                     <div class="option-item">
                        <label for="opt-text-size">Tamanho do Texto:</label>
                        <select id="opt-text-size">
                            <option value="small">Pequeno</option>
                            <option value="normal" selected>Normal</option>
                            <option value="large">Grande</option>
                        </select>
                    </div>
                     <div class="option-item">
                        <label for="opt-high-contrast">Alto Contraste:</label>
                        <input type="checkbox" id="opt-high-contrast">
                    </div>
                </fieldset>

            </div>

            <div class="options-actions form-actions">
                <button id="btn-save-options">Salvar Opções</button>
                <button id="btn-options-back-to-main">Voltar</button>
            </div>
             <p id="options-save-message" class="message" style="text-align: center; margin-top: 10px;"></p>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\optionsScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\profileScreenTemplate.js ---
// js/ui/html-templates/profileScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Perfil do Jogador.
 * ATUALIZADO: Removeu seção de decks e coleção.
 * @returns {string} HTML da tela de perfil.
 */
export function generateProfileScreenHTML() {
    const avatarPath = 'assets/images/avatars/';
    const availableAvatars = ['default.png', 'avatar1.png', 'avatar2.png', 'avatar3.png']; // Adicione mais se tiver

    let avatarChoicesHTML = availableAvatars.map(filename => `
        <img src="${avatarPath}${filename}"
             class="avatar-choice ${filename === 'default.png' ? 'selected-avatar' : ''}"
             data-avatar="${filename}"
             alt="Avatar ${filename.split('.')[0]}"
             title="Selecionar ${filename.split('.')[0]}">
    `).join('');

    return `
        <div id="profile-screen" class="screen profile-layout-single-column"> <!-- Ajuste o layout CSS -->
            <h2>Perfil do Jogador</h2>

            <div class="profile-main-area">
                <!-- Conteúdo fica em uma única coluna agora -->
                <div class="profile-section profile-info">
                    <h3>Informações</h3>
                    <p>Nome: <strong id="profile-username">(Carregando...)</strong></p>
                    <p>Rank: <span id="profile-rank">N/A</span></p>
                    <p>Vitórias/Derrotas: <span id="profile-wins">0</span> / <span id="profile-losses">0</span></p>
                </div>

                <div class="profile-section profile-avatar-section">
                    <h3>Avatar</h3>
                    <div class="profile-avatar-display">
                        <img id="profile-avatar-img" src="${avatarPath}default.png" alt="Avatar do Jogador">
                    </div>
                    <div id="profile-avatar-choices" class="avatar-choices-container">
                        ${avatarChoicesHTML}
                    </div>
                </div>

                <div class="profile-section profile-history">
                     <h3>Histórico de Partidas (Últimas 10)</h3>
                     <ul id="profile-match-history" class="scrollable-list">
                         <li>(Nenhum histórico ainda)</li>
                         <!-- O histórico será preenchido -->
                     </ul>
                </div>
                <!-- Seção de Decks e Coleção REMOVIDA -->

            </div>

             <!-- Overlay de Zoom não é mais necessário aqui se a coleção foi movida -->
             <!-- <div id="image-zoom-overlay" class="image-zoom-overlay"> ... </div> -->
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\profileScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\splashScreenTemplate.js ---
// js/ui/html-templates/splashScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela de Splash (Carregamento Inicial).
 * A imagem é definida como background no CSS.
 * A mensagem funciona como barra de progresso.
 * @returns {string} HTML da tela de splash.
 */
export function generateSplashScreenHTML() {
    return `
        <div id="splash-screen" class="screen active"> <!-- Começa ativa -->
            <!-- A imagem de fundo é aplicada via CSS -->
            <div class="splash-content"> <!-- Container para posicionar a mensagem -->
                 <p class="splash-message">Carregando Runebound...</p>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\splashScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\titleScreenTemplate.js ---
// js/ui/html-templates/titleScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela de Título.
 * Inclui logo acima dos botões.
 * @returns {string} HTML da tela de título.
 */
export function generateTitleScreenHTML() {
    return `
        <div id="title-screen" class="screen">
            <!-- Título Principal -->
            

            <!-- Logo Adicionado -->
            <img class="title-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">

            <!-- Menu de Botões -->
            <div class="title-menu">
                <button id="btn-goto-login">Login</button>
                <button id="btn-goto-create-account">Criar Conta</button>
                <button id="btn-goto-options-icon" class="icon-button" title="Opções">⚙️</button>
            </div>

            <!-- Você pode adicionar mais elementos aqui, como links para créditos, patch notes, etc. -->
            <div class="title-footer">
                <a href="#">Créditos</a> | <a href="#">Versão 0.1.0</a>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\titleScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\topBarTemplate.js ---
// js/ui/html-templates/topBarTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Barra Superior (Top Bar).
 * Contém logo, nome do jogo, nome do usuário (direita) e botões de navegação.
 * @returns {string} HTML da Top Bar.
 */
export function generateTopBarHTML() {
    // Logo e Nome do Jogo adicionados à esquerda.
    // Nome do Usuário movido para a direita.
    return `
        <div id="top-bar" class=""> <!-- Começa sem a classe 'active' -->
            <div class="top-bar-left">
                <img src="assets/images/ui/logo_small_placeholder.png" alt="Runebound Clash Logo" class="top-bar-logo">
                <span class="top-bar-game-name">Runebound Clash</span>
            </div>
            <div class="top-bar-right">
                <!-- Nome do usuário vem ANTES dos botões na direita -->
                <span id="top-bar-username">Carregando...</span>

                <button id="top-bar-btn-home" title="Início / Notícias">
                     <span role="img" aria-label="Início">🏠</span>
                </button>

                <button id="top-bar-btn-profile" title="Perfil / Coleção">
                    <span role="img" aria-label="Perfil">👤</span>
                </button>
                   <!-- NOVO BOTÃO DE DECKS -->
                <button id="top-bar-btn-decks" title="Decks / Coleção">
                    <span role="img" aria-label="Decks">📚</span>
                </button>
                <!-- FIM NOVO BOTÃO -->
                <button id="top-bar-btn-connect" title="Conectar / Jogar Online">
                     <span role="img" aria-label="Jogar">⚔️</span>
                </button>
                 <button id="top-bar-btn-options" title="Opções do Jogo">
                     <span role="img" aria-label="Opções">⚙️</span>
                 </button>
                 <button id="top-bar-btn-logout" title="Sair da Conta">
                     <span role="img" aria-label="Sair">🚪</span>
                 </button>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\topBarTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\BattleScreenUI.js ---
// js/ui/screens/BattleScreenUI.js - ATUALIZADO (v2.5 - AudioManager Integration)

// Importar dependências
import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';
import CreatureCard from '../../core/CreatureCard.js';
import { RunebindingCard } from '../../core/RunebindingCard.js';
import { InstantCard } from '../../core/InstantCard.js'; // Importar InstantCard se for verificar tipo
import { Graveyard } from '../../core/Graveyard.js';
// AudioManager não precisa ser importado aqui, ele é injetado

export default class BattleScreenUI {
    // --- Referências Injetadas ---
    #screenManager;
    #accountManager;
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;
    #audioManager; // <<<=== Adicionado: Referência para AudioManager

    // --- Estado do Jogo (Recebido) ---
    #gameInstance = null;
    #localPlayerId = null;

    // --- Elementos da UI (Cache) ---
    #battleScreenElement;
    #playerHandElement;
    #playerBattlefieldElement;
    #opponentHandElement;
    #opponentBattlefieldElement;
    #playerDeckCountElement;
    #playerGraveyardCountElement;
    #opponentDeckCountElement;
    #opponentGraveyardCountElement;
    #playerLifeElement;
    #playerManaElement;
    #playerMaxManaElement;
    #playerNameElement;
    #playerAvatarElement;
    #opponentLifeElement;
    #opponentManaElement;
    #opponentMaxManaElement;
    #opponentNameElement;
    #opponentAvatarElement;
    #opponentHandCountElement;
    #gameLogElement;
    #gameLogContainerElement;
    #turnNumberElement;
    #phaseIndicatorElement;
    #currentPlayerIndicatorElement;
    #actionFeedbackElement;
    #gameOverOverlayElement;
    #gameOverMessageElement;
    #btnEndTurn;
    #btnPassPhase;
    #btnDiscardMana;
    #btnConfirmAttack;
    #btnConfirmBlocks;
    #btnBackToProfile;
    #playerDeckImgElement;
    #playerGraveyardImgElement;
    #opponentDeckImgElement;
    #opponentGraveyardImgElement;

    // --- Estado Interno da UI da Batalha ---
    #isSelectingDiscard = false;
    #isSelectingTarget = false;
    #actionPendingTarget = null;
    #isDeclaringAttackers = false;
    #selectedAttackerIds = new Set();
    #isAssigningBlockers = false;
    #blockerAssignmentsUI = {};
    #selectedBlockerId = null;
    #pendingDiscardCount = 0;
    #graveyardPlaceholderSrc = 'assets/images/ui/graveyard.png';

    // --- Construtor ---
    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler, audioManager) { // <<<=== Parâmetro audioManager adicionado
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer;
        this.#zoomHandler = zoomHandler;
        this.#audioManager = audioManager; // <<<=== Armazena a instância

        this.#graveyardPlaceholderSrc = 'assets/images/ui/graveyard.png';

        this._cacheSelectors();
        if (!this.#battleScreenElement || !this.#battleScreenElement.length) {
            console.error("BattleScreenUI Error: #battle-screen element not found!");
            return;
        }
        this._bindPermanentEvents();
        console.log("BattleScreenUI initialized with AudioManager.");
    }

    // --- Métodos de Setup ---
    setGameInstance(gameInstance) {
        this.#gameInstance = gameInstance;
        if (this.#gameInstance) {
            this._bindGameEventListeners();
        }
    }
    setLocalPlayer(playerId) {
        this.#localPlayerId = playerId;
    }

    // --- Método Principal de Renderização ---
    renderInitialState() {
        if (!this.#gameInstance || !this.#localPlayerId) {
            console.error("BattleScreenUI Error: Game Instance or Local Player ID not set.");
            this.#screenManager.showScreen('profile-screen'); // Volta pro perfil se der erro
            return;
        }
        console.log("BattleScreenUI: Rendering initial game state...");

        // Limpeza e Reset
        this._clearUI();
        this._resetUIState();

        const localPlayer = this.#gameInstance.getPlayer(this.#localPlayerId);
        const opponent = this.#gameInstance.getOpponent(this.#localPlayerId);
        if (!localPlayer || !opponent) { console.error("BattleScreenUI Error: Players not found."); return; }

        // Render Infos, Mãos, Campos, Zonas
        this._renderPlayerInfo(localPlayer, true);
        this._renderPlayerInfo(opponent, false);
        this._renderPlayerHand(localPlayer);
        this._renderOpponentHand(opponent);
        this._updateDeckDisplay(localPlayer);
        this._updateDeckDisplay(opponent);
        this._updateGraveyardDisplay(localPlayer);
        this._updateGraveyardDisplay(opponent);
        this._renderBattlefield(localPlayer.battlefield, this.#playerBattlefieldElement); // Renderiza campo inicial
        this._renderBattlefield(opponent.battlefield, this.#opponentBattlefieldElement); // Renderiza campo inicial

        // Render Info Turno/Fase
        this.#turnNumberElement.text(this.#gameInstance.turnNumber || 1);
        this._updatePhaseIndicator();
        this._updateCurrentPlayerIndicator();

        // Configurar Botões
        this.#btnConfirmAttack.hide().prop('disabled', true);
        this.#btnConfirmBlocks.hide().prop('disabled', true);
        this._updateTurnControls();

        // Vincular Ações da UI
        this.bindGameActions();

        // Mostra a tela (após tudo renderizado)
        // this.#screenManager.showScreen('battle-screen'); // O main.js faz isso após initializeAndStartGame
        console.log("BattleScreenUI: Initial game state render complete.");
    }

    // --- Bindings de Eventos ---
    _bindPermanentEvents() {
        // Fechar zoom clicando fora
        $('#battle-image-zoom-overlay').off('click.battlezoom').on('click.battlezoom', (event) => {
            if (event.target === event.currentTarget) this.#zoomHandler.closeZoom();
        });
        // Não fechar game over clicando fora
        this.#gameOverOverlayElement.off('click.gameover').on('click.gameover', (event) => {
            if (event.target === event.currentTarget) { /* Não faz nada */ }
        });
        // Fechar seletores/zoom com ESC
        $(document).off('keydown.battlescreen').on('keydown.battlescreen', (e) => {
            if (!this.#battleScreenElement.hasClass('active')) return;
            if (e.key === "Escape") {
                this.#zoomHandler.closeZoom();
                if (this.#isSelectingTarget) this._exitTargetSelectionMode();
                if (this.#isSelectingDiscard) this._exitDiscardSelectionMode();
                if (this.#isDeclaringAttackers) this._exitAttackerDeclarationMode();
                if (this.#isAssigningBlockers) this._exitBlockerAssignmentMode();
            }
        });
    }
    _bindGameEventListeners() {
         if (!this.#gameInstance) return;
         console.log("BattleScreenUI: Binding game event listeners...");
         // Adiciona listeners para eventos do Game
         this.#gameInstance.addEventListener('turnChange', this._handleTurnChange.bind(this));
         this.#gameInstance.addEventListener('phaseChange', this._handlePhaseChange.bind(this));
         this.#gameInstance.addEventListener('playerStatsChanged', this._handlePlayerStatsChanged.bind(this));
         this.#gameInstance.addEventListener('cardDrawn', this._handleCardDrawn.bind(this));
         // 'cardPlayed' é tratado implicitamente por 'cardMoved'
         this.#gameInstance.addEventListener('cardMoved', this._handleCardMoved.bind(this));
         this.#gameInstance.addEventListener('gameLog', this._handleGameLog.bind(this));
         this.#gameInstance.addEventListener('creatureUpdate', this._handleCreatureUpdate.bind(this));
         this.#gameInstance.addEventListener('damagePrevented', this._handleDamagePrevented.bind(this));
         this.#gameInstance.addEventListener('creatureTookDamage', this._handleCreatureTookDamage.bind(this));
         this.#gameInstance.addEventListener('creatureHealed', this._handleCreatureHealed.bind(this));
         this.#gameInstance.addEventListener('gameOver', this._handleGameOver.bind(this));
         this.#gameInstance.addEventListener('deckEmpty', this._handleDeckEmpty.bind(this));
         this.#gameInstance.addEventListener('discardRequired', this._handleDiscardRequired.bind(this));
         this.#gameInstance.addEventListener('attackPhaseStart', this._handleAttackPhaseStart.bind(this));
         this.#gameInstance.addEventListener('attackersDeclared', this._handleAttackersDeclared.bind(this));
         this.#gameInstance.addEventListener('blockersDeclared', this._handleBlockersDeclared.bind(this));
         this.#gameInstance.addEventListener('combatResolved', this._handleCombatResolved.bind(this));
    }
    bindGameActions() {
        console.log("BattleScreenUI: Binding game action interactions...");

        // --- Adicionar áudio aos botões ---
        const addBattleAudio = ($element, sfxClick = 'buttonClick', sfxHover = 'buttonHover') => {
             $element.off('click.battleaudio').on('click.battleaudio', () => this.#audioManager?.playSFX(sfxClick));
             $element.off('mouseenter.battleaudio').on('mouseenter.battleaudio', () => this.#audioManager?.playSFX(sfxHover));
        };

        // Bind Ações Principais + Áudio
        this.#btnEndTurn.off('click').on('click', this._handleEndTurnClick.bind(this));
        addBattleAudio(this.#btnEndTurn);

        this.#btnPassPhase.off('click').on('click', this._handlePassPhaseClick.bind(this));
        addBattleAudio(this.#btnPassPhase);

        this.#btnDiscardMana.off('click').on('click', this._handleDiscardForManaClick.bind(this));
        addBattleAudio(this.#btnDiscardMana);

        // Bind Ações de Combate + Áudio
        this.#btnConfirmAttack.off('click').on('click', this._handleConfirmAttackersClick.bind(this));
        addBattleAudio(this.#btnConfirmAttack);

        this.#btnConfirmBlocks.off('click').on('click', this._handleConfirmBlockersClick.bind(this));
        addBattleAudio(this.#btnConfirmBlocks);

        // Bind Ações nas Cartas (Mão e Campo)
        this.#playerHandElement.off('click', '.card').on('click', '.card', this._handleHandCardClick.bind(this));
        this.#playerBattlefieldElement.off('click', '.card').on('click', '.card', this._handleBattlefieldCardClick.bind(this));
        this.#opponentBattlefieldElement.off('click', '.card').on('click', '.card', this._handleBattlefieldCardClick.bind(this));

        // Bind Zoom (Context Menu)
        this.#playerHandElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        this.#playerBattlefieldElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        this.#opponentBattlefieldElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        this.#battleScreenElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => e.preventDefault()); // Previne menu default

        // Botão Voltar do Game Over + Áudio
        const $btnGameOverBack = this.#btnBackToProfile; // Renomeado para clareza
        $btnGameOverBack.off('click').on('click', () => {
            this.#gameOverOverlayElement.removeClass('active');
            this.#gameInstance = null; // Desvincula a instância do jogo
            this.#screenManager.showScreen('profile-screen'); // Vai para o perfil
            // A BGM será tocada pelo handler de navegação do UIManager
        });
        addBattleAudio($btnGameOverBack);
    }

    // --- Handlers de Eventos do Jogo (com Áudio) ---
    _handleTurnChange(e) { this._updateCurrentPlayerIndicator(); this._updateTurnControls(); }
    _handlePhaseChange(e) { this._updatePhaseIndicator(); this._updateTurnControls(); this._exitCombatModes(); }
    _handlePlayerStatsChanged(e) { const p = this.#gameInstance?.getPlayer(e.detail.playerId); if (p) this._updatePlayerStats(p); }
    _handleCardDrawn(e) {
        const { playerId, card } = e.detail;
        if (playerId === this.#localPlayerId) {
            this._addCardToHandUI(card);
            this.#audioManager?.playSFX('cardDraw'); // <<<=== Toca SFX
        } else {
            this._updateOpponentHandCount(this.#gameInstance?.getPlayer(playerId));
        }
        const player = this.#gameInstance?.getPlayer(playerId);
        if (player) this._updateDeckDisplay(player);
    }
    _handleCardPlayed(e) { /* Tratado por _handleCardMoved */ }
    _handleCardMoved(e) {
        const { cardUniqueId, cardData, fromZone, toZone, ownerId } = e.detail;
        const isLocal = ownerId === this.#localPlayerId;
        const player = this.#gameInstance?.getPlayer(ownerId); if (!player) return;

        // --- Remover do DOM antigo ---
        if (fromZone === 'hand' && isLocal) this.#playerHandElement.find(`.card[data-card-unique-id="${cardUniqueId}"]`).remove();
        else if (fromZone === 'battlefield') $(`#${isLocal ? 'player' : 'opponent'}-battlefield .card[data-card-unique-id="${cardUniqueId}"]`).remove();
        // Adicionar remoção de outras zonas se necessário

        // --- Adicionar ao DOM novo ---
        if (toZone === 'hand' && isLocal) this._addCardToHandUI(cardData);
        else if (toZone === 'battlefield') this._addCardToBattlefieldUI(cardData, ownerId);
        // Adicionar adição a outras zonas se necessário

        // --- Tocar SFX baseado na Ação ---
        if (toZone === 'graveyard' && fromZone === 'hand' && isLocal) {
            // Descarte da mão (inclui descarte por mana ou por excesso)
            this.#audioManager?.playSFX('cardDiscard');
            // Atualiza contador de descarte obrigatório, se aplicável
            if (this.#pendingDiscardCount > 0) {
                 this.#pendingDiscardCount--;
                 if (this.#pendingDiscardCount <= 0) this._exitDiscardRequiredMode();
                 else this.#actionFeedbackElement.text(`Mão cheia! Descarte ${this.#pendingDiscardCount} carta(s).`);
             }
        } else if ((toZone === 'battlefield' || toZone === 'graveyard') && fromZone === 'hand') {
            // Carta jogada da mão (para campo ou direto pro cemitério como Instant)
            if (cardData?.type === 'Creature') {
                this.#audioManager?.playSFX('playCreature');
            } else if (cardData?.type === 'Instant') {
                this.#audioManager?.playSFX('playInstant');
            } else if (cardData?.type === 'Runebinding') {
                 this.#audioManager?.playSFX('playRunebinding');
            }
        } else if (toZone === 'graveyard' && fromZone === 'battlefield') {
            // Criatura destruída, etc. (Poderia ter um som específico de destruição)
            // this.#audioManager?.playSFX('creatureDestroyed'); // Exemplo
        }

        // --- Atualizar Contagens/Displays ---
        if (['deck'].includes(fromZone) || ['deck'].includes(toZone)) this._updateDeckDisplay(player);
        if (['graveyard'].includes(fromZone) || ['graveyard'].includes(toZone)) this._updateGraveyardDisplay(player);
        if ((fromZone === 'hand' || toZone === 'hand') && !isLocal) this._updateOpponentHandCount(player);

        // NÃO decrementar #pendingDiscardCount aqui novamente, já foi feito acima no if (toZone === 'graveyard')
    }
    _handleGameLog(e) { this._addLogMessage(e.detail.message, e.detail.type || 'system'); }
    _handleCreatureUpdate(e) { /* ... (lógica de update visual inalterada) ... */ }
    _handleDamagePrevented(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.target.uniqueId}"]`), 'damage-prevented'); /* SFX aqui? */ }
    _handleCreatureTookDamage(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.creature.uniqueId}"]`), 'damage', e.detail.amount); /* SFX aqui? ('takeDamage') */ }
    _handleCreatureHealed(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.creature.uniqueId}"]`), 'heal', e.detail.amount); /* SFX aqui? ('healEffect') */ }
    _handleCombatResolved(e) { /* ... (lógica visual inalterada) ... */ }
    _handleGameOver(e) {
        const { winnerId, winnerName, loserName } = e.detail;
        const isWinner = winnerId === this.#localPlayerId;
        const msg = isWinner ? `Vitória! Você derrotou ${loserName || 'o oponente'}!` : `Derrota! ${winnerName || 'O oponente'} venceu!`;
        this.#gameOverMessageElement.text(msg);
        this.#gameOverOverlayElement.addClass('active');
        this._disableAllGameActions();
        this.#audioManager?.playSFX(isWinner ? 'gameOverWin' : 'gameOverLose'); // <<<=== Toca SFX Fim de Jogo
        this.#audioManager?.stopBGM(); // <<<=== Para BGM
    }
    _handleDeckEmpty(e) { /* ... (log inalterado) ... */ }
    _handleDiscardRequired(e) { /* ... (lógica de estado inalterada) ... */ }
    _handleAttackPhaseStart(e) { this._updateTurnControls(); }
    _handleAttackersDeclared(e) { /* ... (lógica visual inalterada) ... */ }
    _handleBlockersDeclared(e) { /* ... (lógica visual inalterada) ... */ }

    // --- Handlers de Ações da UI ---
    // Os handlers de clique nos botões (_handleEndTurnClick, etc.) não precisam
    // tocar áudio aqui, pois já foi adicionado nos listeners em bindGameActions.
    _handleEndTurnClick() { if (this._canInteract(true)) this.#gameInstance?.endTurn(); }
    _handlePassPhaseClick() { if (this._canInteract(true)) this.#gameInstance?.passPhase(); }
    _handleDiscardForManaClick() { if (this._canInteract(true) && !this.#btnDiscardMana.prop('disabled')) this._enterDiscardSelectionMode(); }
    _handleHandCardClick(event) { /* ... (lógica de jogar/descartar/selecionar alvo inalterada) ... */ }
    _handleBattlefieldCardClick(event) { /* ... (lógica de alvo/ataque/bloqueio inalterada) ... */ }
    _handleConfirmAttackersClick() { if (this.#isDeclaringAttackers) { this.#gameInstance?.confirmAttackDeclaration(this.#localPlayerId, [...this.#selectedAttackerIds]); this._exitAttackerDeclarationMode(); } }
    _handleConfirmBlockersClick() { if (this.#isAssigningBlockers) { this.#gameInstance?.confirmBlockDeclaration(this.#localPlayerId, { ...this.#blockerAssignmentsUI }); this._exitBlockerAssignmentMode(); } }

    // --- Métodos de Estado da UI ---
    _resetUIState() { /* ... (inalterado) ... */ }
    _canInteract(needsActiveTurn=true){ /* ... (inalterado) ... */ }
    _enterDiscardRequiredMode(c){ /* ... (inalterado) ... */ }
    _exitDiscardRequiredMode(){ /* ... (inalterado) ... */ }
    _enterDiscardSelectionMode(){ /* ... (inalterado) ... */ }
    _exitDiscardSelectionMode(){ /* ... (inalterado) ... */ }
    _enterTargetSelectionMode(aI){ /* ... (inalterado) ... */ }
    _exitTargetSelectionMode(){ /* ... (inalterado) ... */ }
    _enterAttackerDeclarationMode(){ /* ... (inalterado) ... */ }
    _exitAttackerDeclarationMode(){ /* ... (inalterado) ... */ }
    _enterBlockerAssignmentMode(){ /* ... (inalterado) ... */ }
    _exitBlockerAssignmentMode(){ /* ... (inalterado) ... */ }
    _exitCombatModes(){ /* ... (inalterado) ... */ }
    _clearCombatVisuals(){ /* ... (inalterado) ... */ }
    _assignBlocker(aId,bId){ /* ... (inalterado) ... */ }
    _updateBlockerAssignmentVisuals(){ /* ... (inalterado) ... */ }
    _highlightValidTargets(tT){ /* ... (inalterado) ... */ }
    _checkIfValidTarget(tI, tOId, aI) { /* ... (inalterado) ... */ }
    _showCardFeedback($cE, fT, v = ''){ /* ... (inalterado) ... */ }
    _disableAllGameActions(allowTargetables=false){ /* ... (inalterado) ... */ }
    _closeZoomedImage() { this.#zoomHandler.closeZoom(); }

    // --- Métodos de Renderização da UI ---
    _clearUI() { /* ... (inalterado) ... */ }
    _renderPlayerInfo(player, isLocal) { /* ... (inalterado) ... */ }
    _addCardToHandUI(cD) { /* ... (inalterado) ... */ }
    _renderPlayerHand(p) { /* ... (inalterado) ... */ }
    _renderOpponentHand(o) { /* ... (inalterado) ... */ }
    _updateOpponentHandCount(o) { /* ... (inalterado) ... */ }
    _addCardToBattlefieldUI(cD, oId) { /* ... (inalterado) ... */ }
    _renderBattlefield(battlefield, $container) { // <<<=== NOVO (ou ajustar se já existir)
        $container.empty();
        battlefield.getAllCards().forEach(card => {
            this._addCardToBattlefieldUI(card.getRenderData(), card.ownerId);
        });
    }
    _updatePlayerStats(p) { /* ... (inalterado) ... */ }
    _updatePhaseIndicator() { /* ... (inalterado) ... */ }
    _updateCurrentPlayerIndicator() { /* ... (inalterado) ... */ }
    _updateTurnControls() { /* ... (inalterado) ... */ }
    _addLogMessage(m, t = 'info') { /* ... (inalterado) ... */ }
    _updateDeckDisplay(player) { /* ... (inalterado) ... */ }
    _updateGraveyardDisplay(player) { /* ... (inalterado) ... */ }

    // Cache dos seletores jQuery
    _cacheSelectors() {
        this.#battleScreenElement = $('#battle-screen');
        if (!this.#battleScreenElement.length) { console.error("BattleScreenUI CacheSelectors Error: #battle-screen not found during caching."); return; }
        this.#playerHandElement = this.#battleScreenElement.find('#player-hand');
        this.#playerBattlefieldElement = this.#battleScreenElement.find('#player-battlefield');
        this.#playerDeckCountElement = this.#battleScreenElement.find('#player-deck-count');
        this.#playerGraveyardCountElement = this.#battleScreenElement.find('#player-graveyard-count');
        this.#playerLifeElement = this.#battleScreenElement.find('#player-life');
        this.#playerManaElement = this.#battleScreenElement.find('#player-mana');
        this.#playerMaxManaElement = this.#battleScreenElement.find('#player-max-mana');
        this.#playerNameElement = this.#battleScreenElement.find('#player-name');
        this.#playerAvatarElement = this.#battleScreenElement.find('#player-avatar-img');
        this.#playerDeckImgElement = this.#battleScreenElement.find('#player-deck-img');
        this.#playerGraveyardImgElement = this.#battleScreenElement.find('#player-graveyard-img');

        this.#opponentHandElement = this.#battleScreenElement.find('#opponent-hand');
        this.#opponentBattlefieldElement = this.#battleScreenElement.find('#opponent-battlefield');
        this.#opponentDeckCountElement = this.#battleScreenElement.find('#opponent-deck-count');
        this.#opponentGraveyardCountElement = this.#battleScreenElement.find('#opponent-graveyard-count');
        this.#opponentLifeElement = this.#battleScreenElement.find('#opponent-life');
        this.#opponentManaElement = this.#battleScreenElement.find('#opponent-mana');
        this.#opponentMaxManaElement = this.#battleScreenElement.find('#opponent-max-mana');
        this.#opponentNameElement = this.#battleScreenElement.find('#opponent-name');
        this.#opponentAvatarElement = this.#battleScreenElement.find('#opponent-avatar-img');
        this.#opponentHandCountElement = this.#battleScreenElement.find('#opponent-hand-count');
        this.#opponentDeckImgElement = this.#battleScreenElement.find('#opponent-deck-img');
        this.#opponentGraveyardImgElement = this.#battleScreenElement.find('#opponent-graveyard-img');

        this.#gameLogElement = this.#battleScreenElement.find('#game-log');
        this.#gameLogContainerElement = this.#battleScreenElement.find('.game-log-container');
        this.#turnNumberElement = this.#battleScreenElement.find('#turn-number');
        this.#phaseIndicatorElement = this.#battleScreenElement.find('#phase-indicator');
        this.#currentPlayerIndicatorElement = this.#battleScreenElement.find('#current-player-indicator');
        this.#actionFeedbackElement = this.#battleScreenElement.find('#action-feedback');
        this.#gameOverOverlayElement = this.#battleScreenElement.find('#game-over-overlay');
        this.#gameOverMessageElement = this.#battleScreenElement.find('#game-over-message');
        this.#btnBackToProfile = this.#battleScreenElement.find('#btn-back-to-profile');

        this.#btnEndTurn = this.#battleScreenElement.find('#btn-end-turn');
        this.#btnPassPhase = this.#battleScreenElement.find('#btn-pass-phase');
        this.#btnDiscardMana = this.#battleScreenElement.find('#btn-discard-mana');
        this.#btnConfirmAttack = this.#battleScreenElement.find('#btn-confirm-attack');
        this.#btnConfirmBlocks = this.#battleScreenElement.find('#btn-confirm-blocks');
        console.log("BattleScreenUI: Selectors cached.");
    }

} // End class BattleScreenUI
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\BattleScreenUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckBuilderUI.js ---
// js/ui/screens/DeckBuilderUI.js

// Importar dependências (presumindo que CardRenderer e ZoomHandler estão em ../helpers/)
import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';
// Assume que SortableJS está disponível globalmente (via CDN) ou importado

export default class DeckBuilderUI {
    // --- Referências Injetadas ---
    #screenManager;
    #accountManager;
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;

    // --- Elementos da UI (Cache) ---
    #deckBuilderScreenElement;
    #collectionListElement;
    #deckListElement;
    #deckNameInput;
    #deckCountDisplay; // Para o contador no painel direito
    #deckCountTop;     // Para o contador na barra superior
    #deckValiditySpan;
    #saveButton;
    #messageParagraph;
    #titleElement;
    #collectionCountSpan;

    // --- Estado Interno ---
    #dbState = {
        currentDeckId: null,
        currentDeckName: '',
        currentDeckCards: [],
        isEditing: false,
        MAX_COPIES_PER_CARD: 4
    };

    // --- SortableJS Instances ---
    #collectionSortable = null;
    #deckSortable = null;

    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer;
        this.#zoomHandler = zoomHandler;

        // Cache dos seletores principais
        this.#deckBuilderScreenElement = $('#deck-builder-screen');
        if (!this.#deckBuilderScreenElement.length) {
            console.error("DeckBuilderUI Error: Element #deck-builder-screen not found!");
            return;
        }
        this.#collectionListElement = this.#deckBuilderScreenElement.find('#db-available-cards')[0]; // Precisa do elemento DOM para Sortable
        this.#deckListElement = this.#deckBuilderScreenElement.find('#db-current-deck')[0];     // Precisa do elemento DOM para Sortable
        this.#deckNameInput = this.#deckBuilderScreenElement.find('#db-deck-name');
        this.#deckCountDisplay = this.#deckBuilderScreenElement.find('#db-deck-count-display'); // No painel direito
        this.#deckCountTop = this.#deckBuilderScreenElement.find('#db-deck-count'); // Na barra superior
        this.#deckValiditySpan = this.#deckBuilderScreenElement.find('#db-deck-validity');
        this.#saveButton = this.#deckBuilderScreenElement.find('#btn-save-deck');
        this.#messageParagraph = this.#deckBuilderScreenElement.find('#deck-builder-message');
        this.#titleElement = this.#deckBuilderScreenElement.find('#deck-builder-title');
        this.#collectionCountSpan = this.#deckBuilderScreenElement.find('#db-collection-count');


        this._bindEvents(); // Vincula eventos da tela uma vez
        console.log("DeckBuilderUI initialized.");
    }

    /**
     * Renderiza a tela do Deck Builder, carregando um deck existente ou preparando para um novo.
     * @param {string | null} [deckIdToEdit=null] - O ID do deck a ser editado, ou null para criar um novo.
     */
    render(deckIdToEdit = null) {
        console.log(`DeckBuilderUI: Rendering screen. Edit ID: ${deckIdToEdit}`);
        this._resetState(); // Limpa o estado anterior

        const currentUser = this.#accountManager.getCurrentUser();
        const collection = this.#accountManager.getCollection();

        if (!currentUser || !Array.isArray(collection)) {
            console.error("DeckBuilderUI Error: Cannot render - User/collection invalid.");
            this.#screenManager.showScreen('profile-screen');
            alert("Erro ao carregar coleção do usuário para o Deck Builder.");
            return;
        }

        if (deckIdToEdit) {
            this._loadDeckForEditing(deckIdToEdit, collection);
        } else {
            this.#titleElement.text('Criar Novo Deck');
            this.#deckNameInput.val('');
        }

        this._populateFilters(collection);
        this._renderCollectionPanel(collection); // Renderiza coleção e inicializa Sortable
        this._renderDeckPanel();                 // Renderiza o painel do deck (vazio ou carregado)
        this._updateDeckValidity();              // Atualiza a validade inicial

        console.log("DeckBuilderUI: Render complete.");
    }

    /** Vincula eventos específicos da tela do Deck Builder */
    _bindEvents() {
        console.log("DeckBuilderUI: Binding events...");

        // Botões
        this.#deckBuilderScreenElement.on('click', '#btn-save-deck', this._handleSaveDeck.bind(this));
        this.#deckBuilderScreenElement.on('click', '#btn-clear-deck', this._handleClearDeck.bind(this));
        this.#deckBuilderScreenElement.on('click', '#btn-deck-builder-back', this._handleBackButton.bind(this));

        // Filtros
        this.#deckBuilderScreenElement.on('input', '#db-filter-name', this._handleFilterChange.bind(this));
        this.#deckBuilderScreenElement.on('change', '#db-filter-type, #db-filter-cost, #db-filter-tribe', this._handleFilterChange.bind(this));

        // Input Nome do Deck
        this.#deckBuilderScreenElement.on('input', '#db-deck-name', this._handleDeckNameInput.bind(this));

        // Zoom de Cartas (usando o ZoomHandler injetado)
        this.#deckBuilderScreenElement.on('contextmenu', '#db-available-cards .mini-card', (event) => {
            this.#zoomHandler.handleZoomClick(event); // Delega ao handler
        });
         this.#deckBuilderScreenElement.on('contextmenu', '#db-current-deck .mini-card', (event) => {
            this.#zoomHandler.handleZoomClick(event); // Delega ao handler
        });
        // Prevenir menu contexto default
        this.#deckBuilderScreenElement.on('contextmenu', '.mini-card', (e) => e.preventDefault());

        // Fechar overlay de zoom específico do Deck Builder
        $('#deckbuilder-image-zoom-overlay').off('click.dbzoom').on('click.dbzoom', (event) => {
            if (event.target === event.currentTarget) {
                this.#zoomHandler.closeZoom(); // Delega ao handler
            }
        });
    }

    // --- Métodos de Lógica e Estado Interno ---

    _resetState() {
        this.#dbState = {
            currentDeckId: null,
            currentDeckName: '',
            currentDeckCards: [],
            isEditing: false,
            MAX_COPIES_PER_CARD: 4
        };
        this.#messageParagraph.text(''); // Limpa mensagens
        console.log("DeckBuilderUI: State reset.");
    }

    _loadDeckForEditing(deckId, collection) {
        const decks = this.#accountManager.loadDecks();
        const deckToLoad = decks?.[deckId];
        if (deckToLoad) {
            this.#dbState.currentDeckId = deckId;
            this.#dbState.currentDeckName = deckToLoad.name;
            this.#dbState.currentDeckCards = deckToLoad.cards.filter(cardId => collection.includes(cardId));
            if (this.#dbState.currentDeckCards.length !== deckToLoad.cards.length) {
                 this.#messageParagraph.text('Algumas cartas salvas não estão na sua coleção e foram removidas.').css('color', 'orange');
            }
            this.#dbState.isEditing = true;
            this.#titleElement.text(`Editando: ${deckToLoad.name}`);
            this.#deckNameInput.val(deckToLoad.name);
            console.log(`DeckBuilderUI: Loaded deck '${deckToLoad.name}' for editing.`);
        } else {
            console.warn(`DeckBuilderUI: Deck ID ${deckId} not found for editing.`);
            this.#titleElement.text('Criar Novo Deck');
            this.#deckNameInput.val('');
        }
    }

    _addCardToDeck(cardId) {
        if (!cardId) return false;
        const currentCountInDeck = this.#dbState.currentDeckCards.filter(id => id === cardId).length;
        const cardName = this.#cardDatabase[cardId]?.name || cardId;

        if (currentCountInDeck >= this.#dbState.MAX_COPIES_PER_CARD) {
            this._showMessage(`Máx ${this.#dbState.MAX_COPIES_PER_CARD} de "${cardName}".`, 'orange');
            return false;
        }
        if (this.#dbState.currentDeckCards.length >= 40) {
            this._showMessage('Máx 40 cartas.', 'orange');
            return false;
        }

        this.#dbState.currentDeckCards.push(cardId);
        console.log(`DeckBuilderUI State: Added ${cardId}. New count: ${this.#dbState.currentDeckCards.length}`);
        this._updateDeckValidity();
        this._showMessage(''); // Clear message
        return true;
    }

    _removeCardFromDeck(cardId) {
        if (!cardId) return false;
        const initialLength = this.#dbState.currentDeckCards.length;
        const index = this.#dbState.currentDeckCards.indexOf(cardId);
        console.log(`_removeCardFromDeck: Trying to remove ${cardId}. Index: ${index}`);
    
        if (index > -1) {
            this.#dbState.currentDeckCards.splice(index, 1);
             if (this.#dbState.currentDeckCards.length < initialLength) {
                  console.log(`DeckBuilderUI State: OK removed ${cardId}. New count: ${this.#dbState.currentDeckCards.length}`);
                  this._updateDeckValidity(); // Atualiza a UI após remover do estado
                  return true;
             } else { console.error(`DeckBuilderUI State: Error splicing ${cardId}?`); return false; }
        }
        console.warn("DeckBuilderUI State: ID not found, cannot remove:", cardId);
        return false;
    }
    
    _updateDeckValidity() {
        const count = this.#dbState.currentDeckCards.length;
        const min = 30; const max = 40;
        const isValid = count >= min && count <= max;
        const deckName = this.#deckNameInput.val().trim();

        // Atualiza ambos os contadores
        this.#deckCountDisplay.text(count);
        this.#deckCountTop.text(count);

        if (isValid) {
            this.#deckValiditySpan.text('(Válido)').css('color', 'var(--valid-color)');
        } else if (count < min) {
            this.#deckValiditySpan.text(`(Mín ${min})`).css('color', 'var(--invalid-color)');
        } else {
            this.#deckValiditySpan.text(`(Máx ${max})`).css('color', 'var(--invalid-color)');
        }
        this.#saveButton.prop('disabled', !isValid || !deckName);
    }

    _showMessage(text, color = 'lightblue', duration = 3000) {
         this.#messageParagraph.text(text).css('color', `var(--${color}-color, ${color})`); // Usa variável CSS ou cor direta
         if (duration > 0) {
             setTimeout(() => {
                 if (this.#messageParagraph.text() === text) { // Só limpa se a mensagem ainda for a mesma
                     this.#messageParagraph.text('');
                 }
             }, duration);
         }
     }

    // --- Handlers de Eventos ---

    _handleSaveDeck() {
        const deckName = this.#deckNameInput.val().trim();
        if (!deckName) { this._showMessage('Dê um nome ao deck.', 'orange'); return; }
        const cardIds = this.#dbState.currentDeckCards;
        if (!this.#saveButton.prop('disabled')) { // Verifica se o botão está habilitado (indica validade)
            const deckId = this.#dbState.isEditing && this.#dbState.currentDeckId ? this.#dbState.currentDeckId : `deck_${Date.now()}`;
            const result = this.#accountManager.saveDeck(deckId, deckName, cardIds);
            this._showMessage(result.message, result.success ? 'success' : 'error');
            if (result.success) {
                 this.#dbState.isEditing = true; this.#dbState.currentDeckId = deckId;
                 this.#titleElement.text(`Editando: ${deckName}`);
                 // Não volta automaticamente, permite continuar editando
            }
        } else {
             this._showMessage('Deck inválido ou sem nome.', 'orange');
        }
     }

    _handleClearDeck() {
        if (confirm('Limpar deck atual? Isso removerá todas as cartas.')) {
            this.#dbState.currentDeckCards = [];
            this._renderDeckPanel(); // Re-renderiza o painel do deck (vazio)
            this._initializeSortables(); // Re-inicializa para garantir que o alvo de drop funcione
            this._showMessage('Deck limpo.', 'lightblue');
        }
    }

    _handleFilterChange() {
        this._renderCollectionPanel(this.#accountManager.getCollection() || []);
        // Sortable é re-inicializado dentro de _renderCollectionPanel
    }

    _handleDeckNameInput() {
        this.#dbState.currentDeckName = this.#deckNameInput.val();
        this._updateDeckValidity(); // Valida se o botão save deve ser habilitado
    }

    _handleBackButton() {
         this.#screenManager.showScreen('profile-screen');
         // O ProfileScreenUI.render() será chamado pelo UIManager ou main.js ao navegar para lá
    }

    // --- Métodos de Renderização Privados ---

    _populateFilters(collectionIds) {
        const $costFilter = this.#deckBuilderScreenElement.find('#db-filter-cost');
        const $tribeFilter = this.#deckBuilderScreenElement.find('#db-filter-tribe');
        $costFilter.children('option:not(:first-child)').remove();
        $tribeFilter.children('option:not(:first-child)').remove();
        const costs = new Set(), tribes = new Set();
        collectionIds.forEach(id => { const cd = this.#cardDatabase[id]; if(cd) { costs.add(cd.cost >= 7 ? '7+' : cd.cost.toString()); if (cd.tribe && cd.tribe !== 'None') tribes.add(cd.tribe); }});
        [...costs].sort((a, b) => (a === '7+' ? Infinity : parseInt(a)) - (b === '7+' ? Infinity : parseInt(b))).forEach(c => $costFilter.append(`<option value="${c}">${c}</option>`));
        [...tribes].sort().forEach(t => $tribeFilter.append(`<option value="${t}">${t}</option>`));
    }

    _renderCollectionPanel(collectionIds) {
        const $container = $(this.#collectionListElement).empty(); // Usa o elemento DOM cacheado
        this.#collectionCountSpan.text(collectionIds?.length || 0);

        if (!Array.isArray(collectionIds)) { $container.append('<p class="placeholder-message">Erro coleção.</p>'); return; }

        const fN = this.#deckBuilderScreenElement.find('#db-filter-name').val().toLowerCase();
        const fT = this.#deckBuilderScreenElement.find('#db-filter-type').val();
        const fC = this.#deckBuilderScreenElement.find('#db-filter-cost').val();
        const fR = this.#deckBuilderScreenElement.find('#db-filter-tribe').val();
        let cardsRendered = 0;

        collectionIds.forEach(id => {
            const cd = this.#cardDatabase[id];
            if (cd) {
                if (fN && !cd.name.toLowerCase().includes(fN)) return;
                if (fT && cd.type !== fT) return;
                if (fC) { if (fC === '7+' && cd.cost < 7) return; if (fC !== '7+' && cd.cost != fC) return; }
                if (fR && (cd.tribe || 'None') !== fR) return;
                const $mc = this.#cardRenderer.renderMiniCard(cd, 'collection'); // Usa o helper
                if ($mc) { $container.append($mc); cardsRendered++; }
            }
        });

        if (cardsRendered === 0 && collectionIds.length > 0) $container.append('<p class="placeholder-message">(Nenhuma carta corresponde)</p>');
        else if (collectionIds.length === 0) $container.append('<p class="placeholder-message">(Coleção vazia)</p>');

        console.log(`DeckBuilderUI: Rendered ${cardsRendered} collection cards.`);
        this._initializeSortables(); // Re-inicializa após renderizar
    }

    _renderDeckPanel() {
        const $container = $(this.#deckListElement).empty(); // Usa o elemento DOM cacheado
        console.log("DeckBuilderUI: Rendering Deck Panel. Current cards:", this.#dbState.currentDeckCards);

        this.#dbState.currentDeckCards.forEach(id => {
            if (this.#cardDatabase[id]) {
                const $mc = this.#cardRenderer.renderMiniCard(this.#cardDatabase[id], 'deck'); // Usa o helper
                if ($mc) $container.append($mc);
            } else {
                console.warn(`DeckBuilderUI: Card ID '${id}' in deck state not found in database.`);
            }
        });

        if (this.#dbState.currentDeckCards.length === 0) {
             $container.append('<p class="placeholder-message">(Arraste cartas da coleção para cá)</p>');
        }
        // Não chama _updateDeckValidity aqui, é chamado por quem chama _renderDeckPanel
        // Não chama _initializeSortables aqui, é chamado por _renderCollectionPanel
    }


    // --- SortableJS Initialization & Re-initialization ---
    _initializeSortables() {
        if (this.#collectionSortable) this.#collectionSortable.destroy();
        if (this.#deckSortable) this.#deckSortable.destroy();
    
        if (!this.#collectionListElement || !this.#deckListElement) {
            console.error("DeckBuilderUI Error: Sortable list DOM elements not found.");
            return;
        }
        console.log("DeckBuilderUI: Initializing/Re-initializing SortableJS...");
        const self = this;
    
        const commonSortableOptions = {
            animation: 150,
            filter: '.placeholder-message',
            preventOnFilter: false,
            onMove: function (evt) {
                $(evt.to).addClass('drag-over');
                const $relatedList = $(evt.related).closest('.card-list');
                if ($relatedList.is(self.#collectionListElement)) {
                    $relatedList.addClass('drag-over');
                }
                if (!$relatedList.length) { $('body').addClass('drag-over-body'); }
                else { $('body').removeClass('drag-over-body'); }
            },
            onUnchoose: function(evt) {
                $('.card-list').removeClass('drag-over');
                $('body').removeClass('drag-over-body');
            }
        };
    
        this.#collectionSortable = new Sortable(this.#collectionListElement, {
            ...commonSortableOptions,
            group: { name: 'deckBuilderShared', pull: 'clone', put: true }, // Adicionado put:true para permitir que cards sejam colocados de volta
            sort: false,
            onStart: () => { $('body').removeClass('dragging-from-deck'); }
        });
    
        this.#deckSortable = new Sortable(this.#deckListElement, {
            ...commonSortableOptions,
            group: { name: 'deckBuilderShared', pull: true, put: true },
            sort: true,
            onAdd: function (evt) {
                const cardId = $(evt.item).data('card-id');
                const added = self._addCardToDeck(cardId);
                if (!added) $(evt.item).remove();
                $(evt.to).removeClass('drag-over');
            },
            onRemove: function (evt) {
                const cardId = $(evt.item).data('card-id');
                console.log(`Removing card from deck: ${cardId}`); // Debug log
                const removed = self._removeCardFromDeck(cardId);
                if (!removed) console.warn(`Failed to remove ${cardId} from state.`);
                
                // Adiciona sinalização vermelha no container da coleção
                $(self.#collectionListElement).addClass('drag-removal');
                
                // Remove a classe após 500ms para limpar o efeito
                setTimeout(() => {
                    $(self.#collectionListElement).removeClass('drag-removal');
                }, 500);
                
                $('body').removeClass('drag-over-body');
                $(evt.from).removeClass('drag-over');
            },
            onUpdate: function (evt) {
                setTimeout(() => {
                    self.#dbState.currentDeckCards = $(self.#deckListElement).children('.mini-card').map((i, el) => $(el).data('card-id')).get();
                    self._updateDeckValidity();
                    console.log("DeckBuilderUI State: Deck reordered", self.#dbState.currentDeckCards);
                }, 0);
            },
            onStart: () => { $('body').addClass('dragging-from-deck'); },
            onEnd: () => { $('body').removeClass('dragging-from-deck'); }
        });
        console.log("DeckBuilderUI: SortableJS initialized/re-initialized.");
    }
}


--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckBuilderUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckManagementScreenUI.js ---
// js/ui/screens/DeckManagementScreenUI.js

import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';

export default class DeckManagementScreenUI {
    #screenManager;
    #accountManager;
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;
    #uiManager; // Para navegação

    // --- Elementos da UI ---
    #screenElement;
    #deckListElement;
    #collectionElement;
    #collectionCountSpan;
    #messageParagraph;
    #filterNameInput;
    #filterTypeSelect;
    #filterCostSelect;
    #filterTribeSelect;

    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler, uiManager) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer;
        this.#zoomHandler = zoomHandler;
        this.#uiManager = uiManager;

        this._cacheSelectors();
        if (!this.#screenElement || !this.#screenElement.length) {
            console.error("DeckManagementScreenUI Error: Element #deck-management-screen not found!");
            return;
        }
        this._bindEvents();
        console.log("DeckManagementScreenUI initialized.");
    }

    _cacheSelectors() {
        this.#screenElement = $('#deck-management-screen');
        this.#deckListElement = this.#screenElement.find('#deck-management-list');
        this.#collectionElement = this.#screenElement.find('#deck-management-collection');
        this.#collectionCountSpan = this.#screenElement.find('#deck-mgmt-collection-count');
        this.#messageParagraph = this.#screenElement.find('#deck-mgmt-message');
        // Filtros
        this.#filterNameInput = this.#screenElement.find('#deck-mgmt-filter-name');
        this.#filterTypeSelect = this.#screenElement.find('#deck-mgmt-filter-type');
        this.#filterCostSelect = this.#screenElement.find('#deck-mgmt-filter-cost');
        this.#filterTribeSelect = this.#screenElement.find('#deck-mgmt-filter-tribe');
    }

    _bindEvents() {
        console.log("DeckManagementScreenUI: Binding events...");

        // Botões na lista de decks (delegação)
        this.#deckListElement.on('click', '.btn-edit-deck', this._handleEditDeck.bind(this));
        this.#deckListElement.on('click', '.btn-delete-deck', this._handleDeleteDeck.bind(this));

        // Botão Criar Novo Deck
        this.#screenElement.on('click', '#btn-create-new-deck', this._handleCreateNewDeck.bind(this));

        // Filtros
        this.#screenElement.on('input', '#deck-mgmt-filter-name', this._handleFilterChange.bind(this));
        this.#screenElement.on('change', '#deck-mgmt-filter-type, #deck-mgmt-filter-cost, #deck-mgmt-filter-tribe', this._handleFilterChange.bind(this));

        // Zoom na Coleção (delegação ao ZoomHandler)
        this.#collectionElement.on('contextmenu', '.mini-card', (event) => {
            this.#zoomHandler.handleZoomClick(event);
        });
        this.#collectionElement.on('contextmenu', '.mini-card', (e) => e.preventDefault()); // Prevenir menu contexto

        // Fechar Zoom Overlay específico (se houver um específico)
        $('#deck-management-zoom-overlay').off('click.deckmgmtzoom').on('click.deckmgmtzoom', (event) => {
            if (event.target === event.currentTarget) {
                this.#zoomHandler.closeZoom();
            }
        });

        // Botão Voltar (se existir um no template)
        // this.#screenElement.on('click', '#btn-deck-mgmt-back', () => {
        //     this.#screenManager.showScreen('home-screen'); // Ou onde quer que ele volte
        // });
    }

    /** Renderiza a tela buscando dados atuais */
    render() {
        console.log("DeckManagementScreenUI: Rendering...");
        this.#messageParagraph.text(''); // Limpa mensagens
        const currentUser = this.#accountManager.getCurrentUser();
        if (!currentUser) {
            console.warn("DeckManagementScreenUI: No user logged in.");
            this.#screenManager.showScreen('login-screen');
            return;
        }

        const collection = currentUser.collection || [];
        const decks = currentUser.decks || {};

        this._populateFilters(collection);
        this._renderDeckList(decks);
        this._renderCollection(collection); // Aplica filtros automaticamente
    }

    // --- Handlers de Eventos ---

    _handleCreateNewDeck() {
        console.log("DeckManagementScreenUI: Create new deck requested.");
        this.#uiManager.renderDeckBuilderScreen(); // Chama UIManager para preparar o DeckBuilder sem ID
        this.#screenManager.showScreen('deck-builder-screen');
    }

    _handleEditDeck(event) {
        const deckId = $(event.currentTarget).closest('li').data('deck-id');
        if (deckId) {
            console.log(`DeckManagementScreenUI: Edit deck requested: ${deckId}`);
            this.#uiManager.renderDeckBuilderScreen(deckId); // Chama UIManager para preparar o DeckBuilder com ID
            this.#screenManager.showScreen('deck-builder-screen');
        }
    }

    _handleDeleteDeck(event) {
        const $li = $(event.currentTarget).closest('li');
        const deckId = $li.data('deck-id');
        const deckName = $li.find('.deck-name').text().replace(/\(\d+\s*cartas?\)$/, '').trim(); // Extrai nome
        if (deckId && confirm(`Tem certeza que deseja excluir o deck "${deckName}"?`)) {
            const result = this.#accountManager.deleteDeck(deckId);
            if (result.success) {
                console.log(`DeckManagementScreenUI: Deck ${deckId} deleted.`);
                this._showMessage(`Deck "${deckName}" excluído.`, 'success');
                this.render(); // Re-renderiza a lista de decks
            } else {
                this._showMessage(`Erro ao excluir deck: ${result.message}`, 'error');
                console.error(`Error deleting deck: ${result.message}`);
            }
        }
    }

     _handleFilterChange() {
        this._renderCollection(this.#accountManager.getCollection() || []);
    }

    // --- Métodos de Renderização ---

    _renderDeckList(decks) {
        this.#deckListElement.empty();
        const deckIds = Object.keys(decks || {});
        if (!deckIds.length) {
            this.#deckListElement.append('<li>(Nenhum deck criado)</li>');
            return;
        }
        deckIds.forEach(id => {
            const deck = decks[id];
            if (deck) {
                 const cardCount = deck.cards?.length || 0;
                 const isValid = cardCount >= 30 && cardCount <= 40;
                 const validityClass = isValid ? 'deck-valid' : 'deck-invalid';
                 const validityText = isValid ? '' : ` (Inválido: ${cardCount})`; // Texto opcional de invalidade

                this.#deckListElement.append(`
                    <li data-deck-id="${id}">
                        <span class="deck-name ${validityClass}">${deck.name} (${cardCount} cartas)${validityText}</span>
                        <span class="deck-buttons">
                            <button class="btn-edit-deck" title="Editar Deck ${deck.name}">✏️</button>
                            <button class="btn-delete-deck" title="Excluir Deck ${deck.name}">🗑️</button>
                        </span>
                    </li>`);
            }
        });
        console.log(`DeckManagementScreenUI: Rendered ${deckIds.length} decks.`);
    }

    _populateFilters(collectionIds) {
        // Reusa a lógica de _populateFilters do DeckBuilderUI (pode ser extraída para um helper)
        this.#filterCostSelect.children('option:not(:first-child)').remove();
        this.#filterTribeSelect.children('option:not(:first-child)').remove();
        const costs = new Set(), tribes = new Set();
        collectionIds.forEach(id => {
             const cd = this.#cardDatabase[id];
             if(cd) {
                 costs.add(cd.cost >= 7 ? '7+' : cd.cost.toString());
                 if (cd.tribe && cd.tribe !== 'None') tribes.add(cd.tribe);
             }
        });
        // Adiciona opção para 'None' se não houver já
        if (!tribes.has('None')) tribes.add('None');

        [...costs].sort((a, b) => (a === '7+' ? Infinity : parseInt(a)) - (b === '7+' ? Infinity : parseInt(b)))
                  .forEach(c => this.#filterCostSelect.append(`<option value="${c}">${c}</option>`));
        [...tribes].sort()
                   .forEach(t => this.#filterTribeSelect.append(`<option value="${t}">${t === 'None' ? 'Sem Tribo' : t}</option>`));
    }

    _renderCollection(collectionIds) {
        this.#collectionElement.empty();
        this.#collectionCountSpan.text(collectionIds?.length || 0);

        if (!Array.isArray(collectionIds) || collectionIds.length === 0) {
            this.#collectionElement.append('<p class="placeholder-message">(Nenhuma carta na coleção)</p>');
            return;
        }

        const filterName = this.#filterNameInput.val().toLowerCase();
        const filterType = this.#filterTypeSelect.val();
        const filterCost = this.#filterCostSelect.val();
        const filterTribe = this.#filterTribeSelect.val();
        let cardsRendered = 0;

        collectionIds.forEach(id => {
            const cardDef = this.#cardDatabase[id];
            if (cardDef) {
                // Aplicar filtros
                if (filterName && !cardDef.name.toLowerCase().includes(filterName)) return;
                if (filterType && cardDef.type !== filterType) return;
                if (filterCost) {
                    if (filterCost === '7+' && cardDef.cost < 7) return;
                    if (filterCost !== '7+' && cardDef.cost.toString() !== filterCost) return;
                }
                 // Ajuste para filtro de Tribo "None"
                 const cardTribe = cardDef.tribe || 'None';
                 if (filterTribe && cardTribe !== filterTribe) return;

                const $miniCard = this.#cardRenderer.renderMiniCard(cardDef, 'collection');
                if ($miniCard) {
                    this.#collectionElement.append($miniCard);
                    cardsRendered++;
                }
            } else {
                console.warn(`DeckManagementScreenUI: Card ID '${id}' in collection not found in database.`);
            }
        });

         if (cardsRendered === 0 && collectionIds.length > 0) {
            this.#collectionElement.append('<p class="placeholder-message">(Nenhuma carta corresponde aos filtros)</p>');
        }

        console.log(`DeckManagementScreenUI: Rendered ${cardsRendered} collection cards.`);
    }

     _showMessage(text, type = 'info', duration = 3000) {
        const colorVar = type === 'success' ? '--success-color' : type === 'error' ? '--error-color' : '--info-color';
        this.#messageParagraph.text(text).css('color', `var(${colorVar}, #ccc)`); // Fallback color
        if (duration > 0) {
            setTimeout(() => {
                if (this.#messageParagraph.text() === text) { // Only clear if message is still the same
                    this.#messageParagraph.text('');
                }
            }, duration);
        }
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckManagementScreenUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\HomeScreenUI.js ---
// js/ui/screens/HomeScreenUI.js

export default class HomeScreenUI {
    #screenManager;
    #uiManager; // Para possível comunicação futura, não estritamente necessário aqui

    #homeScreenElement;
    #newsFeedContainer;
    #newsDetailContainer;
    #newsDetailTitle;
    #newsDetailImage;
    #newsDetailContent;
    #btnBackToFeed;
    #btnGotoConnect;

    #newsData = []; // Armazena as notícias carregadas

    constructor(screenManager, uiManager) {
        this.#screenManager = screenManager;
        this.#uiManager = uiManager;

        this._cacheSelectors();
        if (!this.#homeScreenElement || !this.#homeScreenElement.length) {
            console.error("HomeScreenUI Error: Element #home-screen not found!");
            return;
        }

        this._bindEvents();
        console.log("HomeScreenUI initialized.");
    }

    _cacheSelectors() {
        this.#homeScreenElement = $('#home-screen');
        this.#newsFeedContainer = this.#homeScreenElement.find('#news-feed-container');
        this.#newsDetailContainer = this.#homeScreenElement.find('#news-detail-container');
        this.#newsDetailTitle = this.#homeScreenElement.find('#news-detail-title');
        this.#newsDetailImage = this.#homeScreenElement.find('#news-detail-image');
        this.#newsDetailContent = this.#homeScreenElement.find('#news-detail-content');
        this.#btnBackToFeed = this.#homeScreenElement.find('#btn-back-to-news-feed');
        this.#btnGotoConnect = this.#homeScreenElement.find('#btn-goto-connect-from-home');
    }

    _bindEvents() {
        // Clicar num item do feed
        this.#newsFeedContainer.on('click', '.news-item', (event) => {
            const newsId = $(event.currentTarget).data('news-id');
            if (newsId) {
                this._showNewsDetail(newsId);
            }
        });

        // Clicar no botão Voltar do detalhe
        this.#btnBackToFeed.on('click', () => {
            this._showNewsFeed();
        });

        // Clicar no botão Jogar
        this.#btnGotoConnect.on('click', () => {
            // Navega para a tela de conexão (UIManager pode ter método para resetar estado dela)
             $('#connect-message').text(''); // Reset connect screen UI state if needed
             $('#server-status-section, #join-game-section').hide();
            this.#screenManager.showScreen('connect-screen');
        });
    }

    /** Renderiza a tela inicial, buscando e mostrando o feed */
    async render() {
        console.log("HomeScreenUI: Rendering...");
        await this._loadNewsData(); // Carrega os dados antes de mostrar
        this._renderNewsFeed();
        this._showNewsFeed(); // Garante que o feed está visível
    }

    /** Carrega os dados das notícias do JSON */
    async _loadNewsData() {
        // Idealmente, use fetch. Se fetch não for uma opção fácil agora,
        // você pode importar diretamente se transformar o JSON num módulo JS.
        try {
            // Usando Fetch (preferível)
            const response = await fetch('js/data/news-data.json'); // Caminho relativo ao index.html
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            this.#newsData = await response.json();
            // Ordena por data, mais recente primeiro
            this.#newsData.sort((a, b) => new Date(b.date) - new Date(a.date));
            console.log("HomeScreenUI: News data loaded successfully:", this.#newsData.length, "items");

        } catch (error) {
            console.error("HomeScreenUI: Failed to load news data:", error);
            this.#newsData = []; // Define como vazio em caso de erro
            this.#newsFeedContainer.html('<p class="error-message">Não foi possível carregar as notícias.</p>');
        }
    }

    /** Popula o container do feed com os itens de notícia */
    _renderNewsFeed() {
        this.#newsFeedContainer.empty(); // Limpa antes de adicionar
        if (this.#newsData.length === 0) {
            this.#newsFeedContainer.html('<p class="placeholder-message">Nenhuma notícia disponível no momento.</p>');
            return;
        }

        this.#newsData.forEach(item => {
            const itemHtml = this._renderNewsItemSummaryHTML(item);
            this.#newsFeedContainer.append(itemHtml);
        });
    }

    /** Gera o HTML para um item resumido no feed */
    _renderNewsItemSummaryHTML(item) {
        const formattedDate = new Date(item.date).toLocaleDateString('pt-BR', { year: 'numeric', month: 'short', day: 'numeric' });
        const imageHtml = item.image ? `<img src="${item.image}" alt="" class="news-image-summary">` : '';
        const categoryHtml = item.category ? `<span class="news-category">[${item.category}]</span>` : '';

        return `
            <div class="news-item" data-news-id="${item.id}">
                ${imageHtml}
                <div class="news-item-content">
                    <div class="news-item-header">
                        <h4 class="news-title-summary">${item.title}</h4>
                        <span class="news-date">${formattedDate} ${categoryHtml}</span>
                    </div>
                    <p class="news-summary">${item.summary}</p>
                </div>
            </div>
        `;
    }

    /** Mostra a visualização detalhada de uma notícia */
    _showNewsDetail(newsId) {
        const item = this.#newsData.find(n => n.id === newsId);
        if (!item) {
            console.error(`HomeScreenUI: News item with ID ${newsId} not found.`);
            return;
        }

        this.#newsDetailTitle.text(item.title);
        this.#newsDetailContent.html(item.content); // Usa .html() para renderizar o HTML do conteúdo

        if (item.image) {
            this.#newsDetailImage.attr('src', item.image).attr('alt', item.title).show();
        } else {
            this.#newsDetailImage.hide();
        }

        this.#newsFeedContainer.hide();
        this.#newsDetailContainer.show();
        this.#newsDetailContainer.scrollTop(0); // Scroll to top
        console.log(`HomeScreenUI: Showing detail for news ID ${newsId}`);
    }

    /** Mostra o feed de notícias, escondendo o detalhe */
    _showNewsFeed() {
        this.#newsDetailContainer.hide();
        this.#newsFeedContainer.show();
        console.log("HomeScreenUI: Showing news feed.");
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\HomeScreenUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\OptionsUI.js ---
// js/ui/screens/OptionsUI.js - ATUALIZADO

export default class OptionsUI {
    #audioManager; // <<<=== Referência para AudioManager

    // --- Elementos da UI (Cache) ---
    #optionsScreenElement;
    #musicVolumeSlider;
    #musicVolumeValueSpan;
    #musicMuteCheckbox; // <<<=== Novo
    #sfxVolumeSlider;
    #sfxVolumeValueSpan;
    #sfxMuteCheckbox;   // <<<=== Novo
    #graphicsQualitySelect;
    #cardAnimationsCheckbox;
    #languageSelect;
    #textSizeSelect;
    #highContrastCheckbox;
    #saveButton;
    #saveMessageParagraph;

    // --- Estado Interno ---
    #options = { // Default options
        musicVolume: 60, // Ajustado default
        sfxVolume: 80,   // Ajustado default
        isMusicMuted: false, // <<<=== Novo default
        isSfxMuted: false,   // <<<=== Novo default
        graphicsQuality: 'medium',
        cardAnimations: true,
        language: 'pt-BR',
        textSize: 'normal',
        highContrast: false
    };
    #OPTIONS_STORAGE_KEY = 'runebound_clash_options';

    constructor(audioManager) { // <<<=== Recebe AudioManager
        this.#audioManager = audioManager; // <<<=== Armazena AudioManager
        this._cacheSelectors();
        if (!this.#optionsScreenElement || !this.#optionsScreenElement.length) {
            console.error("OptionsUI Error: #options-screen element not found!");
            return;
        }
        this._loadOptions();
        this._bindEvents();
        console.log("OptionsUI initialized.");
    }

    _cacheSelectors() {
        this.#optionsScreenElement = $('#options-screen');
        this.#musicVolumeSlider = this.#optionsScreenElement.find('#opt-music-volume');
        this.#musicVolumeValueSpan = this.#musicVolumeSlider.siblings('.volume-value');
        this.#musicMuteCheckbox = this.#optionsScreenElement.find('#opt-mute-music'); // <<<=== Cache Mute Music
        this.#sfxVolumeSlider = this.#optionsScreenElement.find('#opt-sfx-volume');
        this.#sfxVolumeValueSpan = this.#sfxVolumeSlider.siblings('.volume-value');
        this.#sfxMuteCheckbox = this.#optionsScreenElement.find('#opt-mute-sfx');     // <<<=== Cache Mute SFX
        this.#graphicsQualitySelect = this.#optionsScreenElement.find('#opt-graphics-quality');
        this.#cardAnimationsCheckbox = this.#optionsScreenElement.find('#opt-card-animations');
        this.#languageSelect = this.#optionsScreenElement.find('#opt-language');
        this.#textSizeSelect = this.#optionsScreenElement.find('#opt-text-size');
        this.#highContrastCheckbox = this.#optionsScreenElement.find('#opt-high-contrast');
        this.#saveButton = this.#optionsScreenElement.find('#btn-save-options');
        this.#saveMessageParagraph = this.#optionsScreenElement.find('#options-save-message');
    }

    render() {
        console.log("OptionsUI: Rendering options screen controls.");
        if (!this.#optionsScreenElement.length) return;

        // Define valores dos controles
        this.#musicVolumeSlider.val(this.#options.musicVolume);
        this.#musicVolumeValueSpan.text(`${this.#options.musicVolume}%`);
        this.#musicMuteCheckbox.prop('checked', this.#options.isMusicMuted); // <<<=== Define Mute Music Checkbox
        this.#musicVolumeSlider.prop('disabled', this.#options.isMusicMuted); // <<<=== Desabilita slider se mutado

        this.#sfxVolumeSlider.val(this.#options.sfxVolume);
        this.#sfxVolumeValueSpan.text(`${this.#options.sfxVolume}%`);
        this.#sfxMuteCheckbox.prop('checked', this.#options.isSfxMuted);     // <<<=== Define Mute SFX Checkbox
        this.#sfxVolumeSlider.prop('disabled', this.#options.isSfxMuted);     // <<<=== Desabilita slider se mutado

        this.#graphicsQualitySelect.val(this.#options.graphicsQuality);
        this.#cardAnimationsCheckbox.prop('checked', this.#options.cardAnimations);
        this.#languageSelect.val(this.#options.language);
        this.#textSizeSelect.val(this.#options.textSize);
        this.#highContrastCheckbox.prop('checked', this.#options.highContrast);

        this._applyVisualOptions();
        this.#saveMessageParagraph.text('');
    }

    _bindEvents() {
        console.log("OptionsUI: Binding events...");

        // Sliders de Volume (APENAS atualiza o span de valor no input)
        this.#musicVolumeSlider.on('input', () => {
            this.#musicVolumeValueSpan.text(`${this.#musicVolumeSlider.val()}%`);
            // Não chama AudioManager aqui, só no save ou ao desmutar
        });
        this.#sfxVolumeSlider.on('input', () => {
            this.#sfxVolumeValueSpan.text(`${this.#sfxVolumeSlider.val()}%`);
            // Não chama AudioManager aqui
        });

        // --- Checkboxes de Mute ---
        this.#musicMuteCheckbox.on('change', (event) => {
            const isMuted = $(event.currentTarget).is(':checked');
            this.#musicVolumeSlider.prop('disabled', isMuted); // Desabilita/habilita slider
            this.#audioManager?.setMusicMuted(isMuted); // <<<=== Informa AudioManager IMEDIATAMENTE
            this.#audioManager?.playSFX('buttonClick'); // Som ao clicar no checkbox
        });
        this.#sfxMuteCheckbox.on('change', (event) => {
            const isMuted = $(event.currentTarget).is(':checked');
            this.#sfxVolumeSlider.prop('disabled', isMuted);   // Desabilita/habilita slider
            this.#audioManager?.setSfxMuted(isMuted);     // <<<=== Informa AudioManager IMEDIATAMENTE
            this.#audioManager?.playSFX('buttonClick'); // Som ao clicar no checkbox
        });
        // -------------------------

        // Botão Salvar
        this.#saveButton.on('click', this._saveOptions.bind(this));

        // Outros controles (alto contraste, tamanho texto) - podem ter listeners 'change' se quiserem aplicar na hora
        // ...
    }

    _loadOptions() {
        try {
            const storedOptions = localStorage.getItem(this.#OPTIONS_STORAGE_KEY);
            if (storedOptions) {
                const loaded = JSON.parse(storedOptions);
                // Mescla para garantir todas as chaves, incluindo as novas de mute
                this.#options = { ...this.#options, ...loaded };
                 // Certifica que os valores de mute são booleanos
                 this.#options.isMusicMuted = !!this.#options.isMusicMuted;
                 this.#options.isSfxMuted = !!this.#options.isSfxMuted;
                console.log("OptionsUI: Options loaded from localStorage:", this.#options);
            } else {
                console.log("OptionsUI: No saved options found, using defaults.");
            }
        } catch (e) {
            console.error("OptionsUI: Error loading options from localStorage:", e);
        }
        // Aplica estado inicial carregado ao AudioManager (importante!)
        this.#audioManager?.setMusicMuted(this.#options.isMusicMuted);
        this.#audioManager?.setSfxMuted(this.#options.isSfxMuted);
    }

    _saveOptions() {
        // Lê os valores atuais dos controles da UI
        this.#options.musicVolume = parseInt(this.#musicVolumeSlider.val(), 10);
        this.#options.sfxVolume = parseInt(this.#sfxVolumeSlider.val(), 10);
        this.#options.isMusicMuted = this.#musicMuteCheckbox.is(':checked'); // <<<=== Lê estado Mute Music
        this.#options.isSfxMuted = this.#sfxMuteCheckbox.is(':checked');   // <<<=== Lê estado Mute SFX
        this.#options.graphicsQuality = this.#graphicsQualitySelect.val();
        this.#options.cardAnimations = this.#cardAnimationsCheckbox.is(':checked');
        this.#options.language = this.#languageSelect.val();
        this.#options.textSize = this.#textSizeSelect.val();
        this.#options.highContrast = this.#highContrastCheckbox.is(':checked');

        try {
            localStorage.setItem(this.#OPTIONS_STORAGE_KEY, JSON.stringify(this.#options));
            console.log("OptionsUI: Options saved to localStorage:", this.#options);
            this._showMessage('Opções salvas com sucesso!', 'success');
            this._applyVisualOptions(); // Aplica opções visuais

            // Informa o AudioManager para recarregar TODAS as configurações salvas
            // Isso inclui os volumes E os estados de mute recém-salvos
            this.#audioManager?.updateSettings(); // <<<=== Chama updateSettings
             // Toca SFX de salvar
             this.#audioManager?.playSFX('deckSave'); // Usando 'deckSave' como exemplo

        } catch (e) {
            console.error("OptionsUI: Error saving options to localStorage:", e);
            this._showMessage('Erro ao salvar opções.', 'error');
             this.#audioManager?.playSFX('genericError'); // Som de erro
        }
    }

    _applyVisualOptions() {
        console.log("OptionsUI: Applying visual options...");
        // Aplica tamanho de texto e contraste
        $('body')
            .removeClass('text-small text-normal text-large contrast-high')
            .addClass(`text-${this.#options.textSize || 'normal'}`)
            .toggleClass('contrast-high', this.#options.highContrast);

        // Aplica estado desabilitado aos sliders baseado no mute (redundante com render, mas garante)
        this.#musicVolumeSlider.prop('disabled', this.#options.isMusicMuted);
        this.#sfxVolumeSlider.prop('disabled', this.#options.isSfxMuted);

        // Aplica outras opções visuais
        $('body').toggleClass('disable-card-animations', !this.#options.cardAnimations);
        // TODO: Lógica para qualidade gráfica, etc.
    }

    _showMessage(text, type = 'info', duration = 3000) {
        const colorVar = type === 'success' ? '--success-color' : type === 'error' ? '--error-color' : '--info-color'; // Adicionado --info-color
        this.#saveMessageParagraph.text(text).css('color', `var(${colorVar}, #ccc)`); // Fallback
        if (duration > 0) {
            setTimeout(() => {
                if (this.#saveMessageParagraph.text() === text) {
                    this.#saveMessageParagraph.text('');
                }
            }, duration);
        }
    }

} // End class OptionsUI
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\OptionsUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\ProfileScreenUI.js ---
// js/ui/screens/ProfileScreenUI.js - ATUALIZADO

import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';

export default class ProfileScreenUI {
    #screenManager;
    #accountManager;
    #cardDatabase; // Ainda pode ser útil para algo no futuro? Mantém por enquanto.
    #cardRenderer; // Não mais necessário aqui
    #zoomHandler;   // Não mais necessário aqui
    #uiManager;     // Mantém para navegação futura, se necessário

    #profileScreenElement; // Cache do elemento da tela

    // --- Selectors Removidos ---
    // #profileCardCount;
    // #profileUnlockedCards;
    // #profileDeckList;

    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler, uiManager) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer; // Recebe, mas não usa mais diretamente
        this.#zoomHandler = zoomHandler;   // Recebe, mas não usa mais diretamente
        this.#uiManager = uiManager;

        this.#profileScreenElement = $('#profile-screen');
        if (!this.#profileScreenElement.length) {
            console.error("ProfileScreenUI Error: Element #profile-screen not found!");
            return;
        }
        this._bindEvents();
        console.log("ProfileScreenUI initialized (Simplified).");
    }

    render() {
        console.log("ProfileScreenUI: Rendering (Simplified)...");
        const currentUser = this.#accountManager.getCurrentUser();
        if (!currentUser) {
            console.warn("ProfileScreenUI: Cannot render - user not logged in.");
            this.#screenManager.showScreen('login-screen');
            return;
        }

        this._renderUserInfo(currentUser);
        this._renderAvatarSection(currentUser.avatar);
        this._renderMatchHistory(currentUser.matchHistory || []);
        // Chamadas para _renderCollection e _renderDeckList REMOVIDAS

        console.log("ProfileScreenUI: Render complete (Simplified).");
    }

    _bindEvents() {
        console.log("ProfileScreenUI: Binding events (Simplified)...");

        // Seleção de Avatar
        this.#profileScreenElement.on('click', '.avatar-choice', (event) => {
            this._handleAvatarClick(event);
        });

        // Bindings para zoom, editar/deletar deck REMOVIDOS

        // Zoom overlay binding REMOVIDO (agora na DeckManagementScreenUI ou global)
    }

    // --- Handlers ---
    _handleAvatarClick(event) {
        const avatarFilename = $(event.currentTarget).data('avatar');
        if (avatarFilename && this.#accountManager.saveAvatarChoice(avatarFilename)) {
            $('#profile-avatar-img').attr('src', `assets/images/avatars/${avatarFilename}`);
            this.#profileScreenElement.find('.avatar-choice').removeClass('selected-avatar');
            $(event.currentTarget).addClass('selected-avatar');
            console.log("ProfileScreenUI: Avatar updated.");
            // TODO: Atualizar top bar avatar via UIManager
             // this.#uiManager.updateTopBarAvatar(avatarFilename);
        }
    }
    // Handlers _handleEditDeck, _handleDeleteDeck, _handleManageDecks REMOVIDOS

    // --- Métodos de Renderização Privados ---
    _renderUserInfo(currentUser) {
        $('#profile-username').text(currentUser.username);
        $('#profile-rank').text(currentUser.rank || 'N/A');
        $('#profile-wins').text(currentUser.stats?.wins ?? 0);
        $('#profile-losses').text(currentUser.stats?.losses ?? 0);
    }

    _renderAvatarSection(currentAvatarFilename) {
        const avatarFile = currentAvatarFilename || 'default.png';
        $('#profile-avatar-img').attr('src', `assets/images/avatars/${avatarFile}`).attr('alt', `Avatar: ${avatarFile}`);
        this.#profileScreenElement.find('.avatar-choice').removeClass('selected-avatar');
        this.#profileScreenElement.find(`.avatar-choice[data-avatar="${avatarFile}"]`).addClass('selected-avatar');
    }

    _renderMatchHistory(history) {
        const $list = $('#profile-match-history').empty();
        if (!history || history.length === 0) {
            $list.append('<li>(Nenhum histórico ainda)</li>');
            return;
        }
        history.slice(0, 10).forEach(match => {
             const dateStr = new Date(match.date).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', hour:'2-digit', minute: '2-digit'});
             const resultClass = match.result === 'win' ? 'history-win' : match.result === 'loss' ? 'history-loss' : 'history-draw';
             const resultText = match.result === 'win' ? 'Vitória' : match.result === 'loss' ? 'Derrota' : 'Empate';
             $list.append(`<li class="${resultClass}">${dateStr} - ${resultText} vs ${match.opponent || 'Oponente'}</li>`);
        });
    }

    // Métodos _renderCollection, _renderDeckList REMOVIDOS
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\ProfileScreenUI.js ---
