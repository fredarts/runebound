### ESTRUTURA DE DIRETÓRIOS ###

runebound_dccg/
    estrutura_e_scripts.txt
    index.html
    README.md
    .git/
        COMMIT_EDITMSG
        config
        description
        FETCH_HEAD
        HEAD
        index
        ORIG_HEAD
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            sendemail-validate.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    main
                remotes/
                    origin/
                        main
        objects/
            00/
                d56d7158bdefb196e5bfd9c750a2d6b6c43cf8
            02/
                03c26eb576253bed5a397f7998ccb22bab6805
            05/
                b7cc3e8513e6031222432ed1f3afb0bbaff21f
                c72ced70d301770803c7a0d6f3b2e08391c8b0
            08/
                9928c461c10e03a3e12275391639dd43562be6
            0a/
                68dedcbbd7cad1f82ad27ae596c31e9982318a
            0b/
                5165fab49a805e6d3ce8084bc4eaefad521eda
                facdac434312080060df27705cda1d608f9c15
            0c/
                5b573312ebe229808df327388fa63ed47105c0
                d620c9458ced659ca6661bfb963ef02f2d7e7e
            0d/
                95b0db212f1eed3d7cd0ebb4c61358ef03f82e
            10/
                35489a3ad90fb79ddc75dcbb770fc391dc2577
                685dd3e7b02399b4ba6c1f8e4fbab8dca55bf6
            11/
                b481f5fd6cd59c836b7697e933f253683c8ff3
            12/
                329d7bf1479fd0ecaadfc06bbd2b15add733c1
            14/
                f00ebdd3e3f0f36c5f9aed570355081fdee97a
            15/
                8966491f9c9f6fa8a7458039d1f9d83b9c2971
            19/
                3fc5865060ebc9bfe5face7c14da42a55eb5f3
                b5c824cb13578818a401e96d95a4ba8d4f6d31
            1b/
                16854a3eb1fdd5f1ac44d96c06eafa1e8d8476
                bb755a146c59a2faa5d5386ccce2cd0501dbdd
            1d/
                8d269f50f1392686255cd0286f3868a84b85d6
                c8610e80d8516a98db89726564e92a31918847
                dbcb278e310ed4a7270164056ed44c12c027ba
            20/
                44e5c4d02e09643e58de8294867e0cb363d3a3
            23/
                f7f4e99f3c642c6a4ca2c7dcbe75b4f1c7a4e2
            25/
                6dcfb604f3a3a4848307d741c97025c1dd19f3
                a71707f2caf99d5fec3942c6a8eabf01bf6fe7
            26/
                faaf98cb7fa0b67f6c21ec05e66a1a0d58f6df
            28/
                490804951ca2379eef543e09d33774aaf7c03d
            2b/
                d1a8c4d27e698f1d4a7fb0ccf740ccba9e0bb0
            2d/
                5969610575477854886ba9c5337b27d53e7b98
            2e/
                554aea58c0b7517381f0b791b320618fa38741
            2f/
                5c318df42ef22665e8b3883ab0995c34c9c152
            33/
                553de290aa47b662bd10bc4c0465e49417871b
                85f327eec533ce89a7c0f9d99f3fa55b13bfc1
            34/
                acf84b943010640f4727f2a296a120a4e8a23d
                cf0b22f1773b5abb5aec08c14d3a505c16820a
            35/
                787ecce228914a7dc7853da764c6018031171f
            3b/
                73853b61d6b9ec56fce08faf1a6b13c43de708
            3c/
                7f426e275b4e36eafbbc3ce6480803799d0627
                ca4f42939b8b55b41f474b00f80a2ac4b12e19
            3f/
                3f2cf88bb0f031b4467df6e8eb2cf28ef2c0b2
            41/
                91e9c28efc857d9e38282504a6883b783f1edb
            42/
                5ea9a9d53773298b442e11509a2d57a741b2e1
            45/
                ef01722ac6703062a7dec7409a89cd9658dde0
            48/
                759a3e0a804983d196dd99c15288485529ae37
            49/
                0a4bc15ef601fd87d8053ceea0e8f4d11fef21
            4b/
                bde34bb2277e6769b0fb3a68fd8f727eeb92b0
            4c/
                0102d3a30c29a0b9783a9bc98f6cc2df22c437
            4e/
                03021c64e6a581cf69c58efbbb6aaf5ecd9150
                34de3366d221cfca740f1eec1f60e6f57aafdd
            50/
                900869b9694bdb03dea6a4ad2a0fc34236eda9
            58/
                7c65dee4dae69dfc89a4bf8d2b1f154c20c0f4
            59/
                af3be4ce712fa53f0cd23536da909a926781cb
            5d/
                53c1d45811ce68b7f636847b24c265edac4aa9
                6c9de058820d614c54e95f89b6a5ef5bfa838c
                8b3975a825da20c90f5bd5716bf04a71e72137
            5f/
                f8838fb273643ec4e2ad31dbe5ce43c0d14a4d
            60/
                48c42317e6688acaec5ad95956fa9a35f9151e
            61/
                93ec381ed83aa0a2fb1814abd822b13ff9a5e6
                e3a853918d99c47e7f4e9f9f1d42500eec2d37
            62/
                1f4ded3fad645c84a3322a673d969a65618b58
                f4d920201442a6a49ad86bfe5194f55e2ffab2
            63/
                4e69da777824f8651e8b89c37d484690a1a5a9
            64/
                6d3b814bfed4830e6f517f74dcac49c206788f
            68/
                d37e178889acbb8090173d119b562bd6f8f6b6
            6c/
                d073f322848b3e06d6f3710f6218e541f8815e
            6f/
                b4c96ab0cfb834b1509791cf3d5771efdd5ec2
            70/
                38a8cc32e05294729d0890ab8a4e00eaa9e879
                a662e5cfc04e54d03558a74fd0442787ce26c5
                f890df21d31da4c543d034dbc246d8195002c4
            75/
                3ee19d72990b6575e562ba0c645c9853a5e124
                e33cb3eb771900de8d9566499e83acb69bde0b
            77/
                eff917ea2bc2cb514aafef15cd3b42b562fe84
            79/
                f3abfd2fdd7ecb2dcac777212f1ebfd2a458b0
            7a/
                fa18feb94cc97978c939b7af2532770793a086
            7d/
                2dd0f6ddeaa800bd7dbf6738bbdc7a662660d6
                374a426b785d0ec47b935603faa6c1b7393720
                707687dfdbaa902e1fc28938073412e74f8632
            7f/
                5558172f2953e481884f0366005967f445004b
            80/
                18109aa5e88a5193dcd8aba56e02e7e00a1b4c
            81/
                7629d9c207975f06a6d4e2e5e9ab03e44845e5
                9da2dfb6059d1014e2cb2bc14456b0f71033e7
            84/
                73cbeb90528ff0407e7f6293e6a81024e52092
            86/
                dd7796e77990867efd177b297fe16144e51bc5
            8a/
                1e495e2ef6c5de879151867481a78b5bbd8074
            8c/
                53465ea535f135ad16ed75ace76db63c810f8e
            8d/
                32b33dcdfb3d1b463f4b090f8f6ae3ae673999
                6c4892cb5afbf6a1e9df3c831c6c4dd2d572c8
            8e/
                2fd03b4c9f45d1352e6c3cf94dc4cf985d5cd9
            91/
                36f0f2c774390d28b8d356fa83dc0ad0f07f99
            92/
                6fd1beea74c37c037f7c04552be91d4658e291
                99b2bd3e709bf810b3577082843929da659f87
            93/
                1060547b6b731a92efe25ba6d93b96261f3503
            95/
                01a8884ca2ef9b2bf2b1a7c8318f9917f8705c
                3c43e78acdfbabe411bbc21b0f85b86e0cc14b
            96/
                4d2ef9cb4ad995abdb5e5c6d1a2040a380199f
            97/
                c950bc7b01e6feb3a66f09580d3e70b61fafdf
            98/
                883b0cb7e91d28b034fc6526491f07a587f17c
                e9b8cceab5b9ce5b556b2ba4183eb8d409ff71
            9b/
                810333862d281f78afdc06c0611ad3c5218cd1
                ebae9186dfceb7c526ab83addbaf0c26e6ebfe
            9c/
                6df79146c9d497ead103fb9027f7499ef6e816
            a2/
                2a812df8a9a85a97c0a641ef6697667f44edad
                fc75f836c7bdd29ccef66dd97ea11d9043bd38
            a3/
                a0b5c3514231b4dba53c70200af5814dba26dc
            a5/
                7085d27ab3da7b5245c2eac210a4d0f96c610f
            ab/
                929ede334e40f15cf6e8ffa7db830904deafa7
            ac/
                620d6b8316f0f1798c861c07e896fddeca1fd0
            af/
                a3e18d5a2c8c65227ecb73e63cad1a87ec69f3
            b0/
                eb4b1f954ba02505a8b8226c3fb0b2abbebd34
            b1/
                558bf0db1b5bcb86d876269ceb02cf211364bc
                66c058d9097513b1adb84e0d99d413e96ed230
            b2/
                3baae7d5082155fc1a762ddd7c082118b01c46
            b4/
                61ec3355a842e92d174d9a397b68eea3402da7
            b7/
                1d4d5bd986cbb8371ec53d432f181858c64448
                7886e2dc67991f6bb96626a82b276c8d1163b0
            b9/
                730865f80944017c2239aaf3651086849b11e4
                7db54e3474e18ff3d92dc2408127b2b6e5531e
            bb/
                ce376d51b3a67fae3c59e0f9d097ec50083022
            c0/
                207c9d78d9e24e6748e1fb69f69cb102f8de29
            c1/
                b6a3cf069a9d2fbc751546ae36ae38bb775ad9
                cd2c8855df81df9f834b417e3dd5e7ff39bff3
            c4/
                a52ef327332de6c060d591e21e0c33ca86558a
            c8/
                0cf582d03d9b7a7c955395c2167fd57efa3ea9
            ca/
                1819f68eedbf5ad6af5bb6f19f48afae379837
                270bdea2536df5c7532c0eaaba741067e10a83
                2c968f574091733b025c5e353c3ee8945388e8
                4ae4e94d8eb68439657169437d241927c69ca7
            cb/
                c976ec0968176400b42254eb9899da907dcf3c
            cd/
                201dfd41304ad1cd335a50bf0786ec9d75cf64
                699b089645c967198742c6c7d4e74d67abf37e
            d1/
                12defc5f664db2e88e34d83db4f5580fb552b8
                287ab8825496d0678994eb009df60136051e84
            d2/
                f1be81e8649f0751ff7363d180cd3516e29589
            d5/
                8c8de5c4d3b66d4561428436f33242325d1209
                970c1a8fda3a5e045c87a306b02d63c313cbf6
            d7/
                060f9f16f56b16f12e651993be61c445f4ae00
                f2e139e0a0ddd3b0f2f03f759acf93b3105d9b
            d9/
                d9a24f376419e76229ba42ce10153c646264e6
            da/
                41442fffd6c2daff3dac068cec33b29cb58de8
                8700f6d35deaa6abb61515a6caf920178cb4e2
            dc/
                2f3f356258eb4185fd056b0fba5a216b1c3c08
                b4c419ce0c4b6e477f8b1cd12059a7622d4295
            dd/
                d53bb57185d659577bca1af380664bc68f6337
            de/
                99a67b77189d8d5003572afbf297e3c7b1762d
            e2/
                37e34038a7b9650cf0f4dbde8be2054bd85796
            e3/
                9b4dd7e973491dec9542df96a4d23daef3777a
            e4/
                63e7687eb61b4cf5938bc29b8b1de58198d1b3
            e6/
                9de29bb2d1d6434b8b29ae775ad8c2e48c5391
            ea/
                282ff4d9b37b7f089aa8edefeb711b44cd4e9e
            ed/
                dba2a3acca50f0519331eb2a3e6606fbf336c6
            f0/
                c7b9d7cd5b86fff6c71b981fd84d056a681e8c
            f5/
                43afbe0c503d2bfcc021bc053fa053bfdf74b5
                9eff8f0fafbc9b0a295075ed2ae96019d08264
            f6/
                55da995f26f0c12507152359dcb4eb0e9c80bd
            f7/
                bb2af30778f669d161d743db1a1c803f356d60
                de9117bfaf1038ed8a1920b2d497b56e010ac2
            info/
            pack/
        refs/
            heads/
                main
            remotes/
                origin/
                    main
            tags/
    assets/
        audio/
            placeholder.txt
        images/
            avatars/
                avatar1.png
                avatar2.png
                avatar3.png
                default.png
            cards/
                arcane_familiar.png
                bounce.png
                card_cover.png
                crystal_golem.png
                destroy.png
                destroy_binding.png
                draw.png
                draw_rune.png
                dwarf_guardian.png
                elf_ranger.png
                feral_bear.png
                fireball.png
                firebrand_zealot.png
                ghoul_devourer.png
                heal.png
                human_duelist.png
                molten_wyrm.png
                plague_rat.png
                power_boost.png
                shadowblade_assassin.png
                shield.png
                soul_revenant.png
                stonecaller.png
                storm_elemental.png
                toughness_boost.png
                volcanic_behemoth.png
                weaken.png
                wisp_of_light.png
            favicon/
                android-chrome-192x192.png
                android-chrome-512x512.png
                apple-touch-icon.png
                favicon-16x16.png
                favicon-32x32.png
                favicon.ico
            printscreens/
                01.png
                02.png
                03.png
                04.png
                05.png
                06.png
                07.png
                08.png
            ui/
                battle_background.jpg
                connect_background.jpg
                create_account_background.jpg
                graveyard.png
                host.png
                join.png
                login_background.jpg
                logo_placeholder.png
                logo_small_placeholder.png
                placeholder.txt
                runebound_logo.png
                SplashCreenLogo.png
                title_background.jpg
    css/
        animations.css
        cards.css
        style.css
    js/
        config.js
        main.js
        utils.js
        account/
            AccountManager.js
        core/
            Battlefield.js
            Card.js
            CombatManager.js
            CreatureCard.js
            Deck.js
            Game.js
            Graveyard.js
            Hand.js
            InstantCard.js
            Player.js
            RunebindingCard.js
            TurnManager.js
        data/
            card-definitions.json
        network/
            NetworkManager.js
        ui/
            ScreenManager.js
            templates.js
            UIManager.js
            helpers/
                CardRenderer.js
                ZoomHandler.js
            html-templates/
                battleScreenTemplate.js
                connectScreenTemplate.js
                createAccountScreenTemplate.js
                deckBuilderScreenTemplate.js
                loginScreenTemplate.js
                optionsScreenTemplate.js
                profileScreenTemplate.js
                splashScreenTemplate.js
                titleScreenTemplate.js
                topBarTemplate.js
            screens/
                BattleScreenUI.js
                DeckBuilderUI.js
                OptionsUI.js
                ProfileScreenUI.js

### CONTEÚDO DOS SCRIPTS ###

--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\config.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\config.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\main.js ---
// js/main.js

// --- Imports ---
// Core Modules
import Game from './core/Game.js';
import UIManager from './ui/UIManager.js';
import ScreenManager from './ui/ScreenManager.js';
import AccountManager from './account/AccountManager.js';
import { loadCardDefinitions } from './utils.js';

// --- HTML Template Imports ---
import { generateSplashScreenHTML } from './ui/html-templates/splashScreenTemplate.js';
import { generateTitleScreenHTML } from './ui/html-templates/titleScreenTemplate.js';
import { generateLoginScreenHTML } from './ui/html-templates/loginScreenTemplate.js';
import { generateCreateAccountScreenHTML } from './ui/html-templates/createAccountScreenTemplate.js';
import { generateProfileScreenHTML } from './ui/html-templates/profileScreenTemplate.js';
import { generateConnectScreenHTML } from './ui/html-templates/connectScreenTemplate.js';
import { generateDeckBuilderScreenHTML } from './ui/html-templates/deckBuilderScreenTemplate.js';
import { generateOptionsScreenHTML } from './ui/html-templates/optionsScreenTemplate.js';
import { generateBattleScreenHTML } from './ui/html-templates/battleScreenTemplate.js';
import { generateTopBarHTML } from './ui/html-templates/topBarTemplate.js';
// Add any other screen templates you create here

// --- Document Ready ---
$(document).ready(() => {
    console.log("Runebound Clash - Initializing (Dynamic HTML)...");

    // --- STEP 1: Build HTML Structure Dynamically ---
    console.log("MAIN: Generating HTML structure...");
    const $screensContainer = $('#screens-container');
    const $body = $('body');

    // CRITICAL CHECK: Ensure the main container exists in index.html
    if (!$screensContainer.length) {
        console.error("CRITICAL ERROR: #screens-container div not found in index.html! Cannot generate UI.");
        // Display a visible error message if the container is missing
        $body.empty().css({ // Clear body and add error
            'background-color': '#333', 'color': 'red', 'display': 'flex',
            'justify-content': 'center', 'align-items': 'center', 'height': '100vh',
            'font-size': '1.5em', 'padding': '20px', 'text-align': 'center'
        }).html('<h1>Erro Crítico</h1><p>A estrutura base do HTML (index.html) parece estar faltando o elemento <code><div id="screens-container"></code>. A aplicação não pode iniciar.</p>');
        return; // Stop execution
    }

    try {
        // Generate and Append/Prepend HTML content
        // Clear any static placeholder content first
        $screensContainer.empty()
            .append(generateSplashScreenHTML())          // Splash Screen FIRST
            .append(generateTitleScreenHTML())
            .append(generateLoginScreenHTML())
            .append(generateCreateAccountScreenHTML())
            .append(generateProfileScreenHTML())
            .append(generateConnectScreenHTML())
            .append(generateDeckBuilderScreenHTML())
            .append(generateOptionsScreenHTML())
            .append(generateBattleScreenHTML());
            // .append(generateOtherScreenHTML()); // Add other screens as needed

        // Prepend Top Bar (it sits above the screen container)
        $body.prepend(generateTopBarHTML());

        console.log("MAIN: HTML Structure dynamically generated.");

    } catch (htmlGenError) {
         console.error("MAIN: Critical error during HTML generation from templates:", htmlGenError);
         // Try to show error on splash screen if it exists, otherwise fallback
         const $splash = $('#splash-screen');
         if ($splash.length) {
             $splash.addClass('active').html(`<p style="color:red; font-weight:bold;">Erro Crítico na Geração da UI: ${htmlGenError.message}. Recarregue.</p>`);
             $('.screen').not($splash).removeClass('active'); // Hide others
         } else {
             $screensContainer.html(`<p style="color:red; font-weight:bold;">Erro Crítico na Geração da UI: ${htmlGenError.message}. Recarregue.</p>`);
         }
         return; // Stop further execution
    }
    // --- END STEP 1 ---


    // --- STEP 2: Initialize Modules and Logic (Mostly unchanged from original) ---
    console.log("MAIN: Initializing modules and binding events...");
    try { // Wrap main initialization in a try...catch
        // --- Module Initialization ---
        const cardDatabase = loadCardDefinitions();
        if (!cardDatabase) {
            // Ensure splash exists before trying to modify it
            const $splashError = $('#splash-screen');
             if ($splashError.length) {
                 $splashError.text('Erro Crítico: Falha ao carregar cartas. Recarregue.').css('color', 'salmon');
                 $('.screen').removeClass('active'); $splashError.addClass('active');
             } else {
                 console.error("CRITICAL: Failed to load card definitions AND splash screen not found!");
                 $screensContainer.html('<p style="color:red; font-weight:bold;">Erro Crítico: Falha ao carregar cartas.</p>');
             }
            console.error("CRITICAL: Failed to load card definitions!");
            return; // Stop further execution
        }

        // Initialize managers AFTER HTML is generated
        const screenManager = new ScreenManager(); // Uses default transition duration
        const accountManager = new AccountManager();
        const uiManager = new UIManager(screenManager, accountManager, cardDatabase); // UIManager now works with generated HTML

        // --- Initial Screen & Splash Transition ---
        console.log("MAIN: Showing splash screen...");
        // ScreenManager needs the #splash-screen div to exist, which it does now.
        screenManager.showScreen('splash-screen'); // Show splash initially
        // Add 'loading' class shortly after to trigger progress bar animation
        setTimeout(() => $('#splash-screen').addClass('loading'), 50); // Pequeno delay para garantir renderização inicial

        console.log("MAIN: Setting timeout for screen transition (3000ms)...");
        setTimeout(() => {
            console.log("MAIN: Timeout finished. Checking login state...");
            try {
                const currentUser = accountManager.getCurrentUser();
                if (currentUser) {
                    // --- Logged In Flow ---
                    console.log(`MAIN: User '${currentUser.username}' found. Showing Top Bar and Profile.`);
                    uiManager.showTopBar(currentUser); // Show the top bar
                    $('#screens-container').addClass('with-top-bar'); // Add padding for top bar
                    uiManager.renderProfileScreen(); // Render profile content (finds generated elements)
                    screenManager.showScreen('profile-screen'); // Show profile screen initially
                } else {
                    // --- Logged Out Flow ---
                    console.log("MAIN: No user found. Showing title-screen.");
                    uiManager.hideTopBar(); // Ensure top bar is hidden
                    $('#screens-container').removeClass('with-top-bar');
                    screenManager.showScreen('title-screen'); // Go to Title Screen
                }
                console.log("MAIN: Initial screen setup complete.");
            } catch (error) {
                console.error("MAIN: Error inside setTimeout callback:", error);
                console.log("MAIN: Fallback - Showing title-screen due to error.");
                 uiManager.hideTopBar(); // Ensure top bar is hidden on error too
                 $('#screens-container').removeClass('with-top-bar');
                screenManager.showScreen('title-screen');
            }
        }, 3000); // 3-second delay

        // --- Global UI Bindings ---
        // IMPORTANT: These bindings are attached AFTER the HTML is generated,
        // so jQuery can find the elements by their IDs.

        // Title Screen Actions
        $('#btn-goto-login').on('click', () => screenManager.showScreen('login-screen'));
        $('#btn-goto-create-account').on('click', () => screenManager.showScreen('create-account-screen'));
        $('#btn-goto-options-icon').on('click', () => { uiManager.renderOptionsScreen(); screenManager.showScreen('options-screen'); }); // Options from Title

        // Back to Title from Login/Create
        $('#btn-create-back-to-title, #btn-login-back-to-title').on('click', () => { $('#create-account-message, #login-message').text(''); screenManager.showScreen('title-screen'); });

        // Create Account Form Submit
        $('#create-account-form').on('submit', (event) => {
            event.preventDefault();
            const $form = $(event.currentTarget); // Referência ao formulário
            const u = $('#create-username').val().trim(), p = $('#create-password').val(), $m = $('#create-account-message');
            const r = accountManager.createAccount(u, p);
            $m.text(r.message).css('color', r.success ? 'lightgreen' : 'salmon');

            if (r.success) {
                $form[0].reset();
                setTimeout(() => {
                    if (screenManager.getActiveScreenId() === 'create-account-screen') {
                        screenManager.showScreen('login-screen');
                        $m.text('');
                    }
                 }, 2000);
            } else {
                // ---> ADICIONAR SHAKE NO ERRO <---
                const $container = $form.closest('.form-container'); // Acha o container
                if ($container.length) {
                    $container.addClass('form-shake'); // Adiciona a classe
                    // Remove a classe após a animação terminar (0.5s + margem)
                    setTimeout(() => {
                        $container.removeClass('form-shake');
                    }, 600); // Duração um pouco maior que a animação CSS
                }
                // ---> FIM SHAKE <---
            }
        });

        // Login Form Submit
        $('#login-form').on('submit', (event) => {
            event.preventDefault();
            const $form = $(event.currentTarget); // Referência ao formulário
            const u = $('#login-username').val().trim(), p = $('#login-password').val(), $m = $('#login-message');
            const r = accountManager.login(u, p);
            $m.text(r.message).css('color', r.success ? 'lightgreen' : 'salmon');

            if (r.success) {
                $form[0].reset();
                // --- Login Success Flow ---
                uiManager.showTopBar(r.user);
                $('#screens-container').addClass('with-top-bar');
                uiManager.renderProfileScreen();
                screenManager.showScreen('profile-screen');
            } else {
                // ---> ADICIONAR SHAKE NO ERRO <---
                const $container = $form.closest('.form-container'); // Acha o container
                if ($container.length) {
                    $container.addClass('form-shake'); // Adiciona a classe
                    // Remove a classe após a animação terminar (0.5s + margem)
                    setTimeout(() => {
                        $container.removeClass('form-shake');
                    }, 600); // Duração um pouco maior que a animação CSS
                }
                 // ---> FIM SHAKE <---
            }
        });


        // --- Top Bar Navigation ---
        $('#top-bar-btn-profile').on('click', () => {
            if(screenManager.getActiveScreenId() !== 'profile-screen'){ uiManager.renderProfileScreen(); screenManager.showScreen('profile-screen'); }
        });
        $('#top-bar-btn-connect').on('click', () => {
             $('#connect-message').text(''); screenManager.showScreen('connect-screen');
             // Reset connect screen UI state if needed
             $('#server-status-section, #join-game-section').hide();
        });
         $('#top-bar-btn-options').on('click', () => { // Options icon in top bar
            uiManager.renderOptionsScreen(); screenManager.showScreen('options-screen');
        });
        $('#top-bar-btn-logout').on('click', () => {
            accountManager.logout();
            uiManager.hideTopBar(); // Hide top bar
            $('#screens-container').removeClass('with-top-bar'); // Remove padding
            screenManager.showScreen('title-screen'); // Go to title
        });

        // --- Other Screen Bindings ---
        // Back Buttons (Use goBack or specific navigation)
         $('#btn-options-back-to-main').on('click', () => screenManager.goBack('profile-screen')); // Go back or to profile
         $('#btn-deck-builder-back').on('click', () => screenManager.showScreen('profile-screen')); // Always back to profile from DB
         $('#btn-connect-back-to-main').on('click', () => screenManager.showScreen('profile-screen')); // Back to profile from connect

        // Profile Actions (UIManager handles internal bindings like avatar/deck clicks)
        // $('#btn-goto-deck-builder-new') click might be handled inside UIManager._bindProfileInteractions

        // Options Save
        $('#btn-save-options').on('click', () => uiManager.saveOptions()); // UIManager handles this

        // --- Game Initialization Logic & Connect Screen Bindings ---
        let gameInstance = null;

        /** Function to set up and start a new game instance (Unchanged) */
        function initializeAndStartGame(localPlayerDeckId, opponentUsername = "Opponent_AI", opponentDeckId = 'default_deck_1') {
             console.log("MAIN: Initializing game...");
             const currentUser = accountManager.getCurrentUser(); if (!currentUser) { console.error("MAIN: No user logged in."); screenManager.showScreen('login-screen'); return; }
             const localDecks = accountManager.loadDecks(); const localDeck = localDecks?.[localPlayerDeckId];
             if (!localDeck?.cards || localDeck.cards.length < 30) { console.error(`MAIN: Local deck '${localDeck?.name || localPlayerDeckId}' invalid.`); $('#connect-message').text(`Erro: Deck '${localDeck?.name || localPlayerDeckId}' inválido.`).css('color', 'salmon'); return; }
             const localPlayerDeckIds = localDeck.cards; console.log(`MAIN: Local Deck '${localDeck.name}' (${localPlayerDeckIds.length} cards) found.`);
             // Opponent Deck Sim/Fallback (Unchanged)
             let defaultOpponentDeckIds = accountManager.getUserData(currentUser.username)?.decks?.[opponentDeckId]?.cards;
             if (!defaultOpponentDeckIds || defaultOpponentDeckIds.length < 30) { console.warn(`MAIN: Opponent deck fallback.`); const allCardIds = Object.keys(cardDatabase); if (allCardIds.length >= 30) { defaultOpponentDeckIds = allCardIds.slice(0, 30); console.log(`MAIN: Using fallback opponent deck.`); } else { console.error("MAIN: Cannot create fallback opponent deck!"); $('#connect-message').text('Erro: Definições insuficientes.').css('color', 'salmon'); return; } } else { console.log(`MAIN: Using opponent deck '${opponentDeckId}'.`); }
             console.log(`MAIN: Preparing ${currentUser.username} vs ${opponentUsername}`);

             try {
                 gameInstance = new Game(cardDatabase);
                 const player1 = gameInstance.addPlayer(currentUser.username, localPlayerDeckIds);
                 const player2 = gameInstance.addPlayer(opponentUsername, defaultOpponentDeckIds);
                 if (!player1 || !player2) throw new Error("Falha ao adicionar jogadores.");

                 uiManager.setGameInstance(gameInstance); // Link game to UI
                 uiManager.setLocalPlayer(player1.id);     // Tell UI who we are

                 if (gameInstance.setupGame()) {
                     gameInstance.startGame();
                     uiManager.renderInitialGameState(); // UI draws the board
                     // uiManager.bindGameActions(); // UIManager should handle its internal game bindings
                     console.log("MAIN: Game started successfully!"); $('#connect-message').text('');
                     screenManager.showScreen('battle-screen'); // Explicitly show battle screen
                 } else {
                     throw new Error("Game setup failed.");
                 }
             } catch (error) {
                 console.error("MAIN: Error during game initialization:", error);
                 $('#connect-message').text(`Erro ao iniciar: ${error.message}`).css('color', 'salmon'); gameInstance = null;
                 setTimeout(() => {
                     // Check if still on connect screen before navigating away
                     if (screenManager.getActiveScreenId() === 'connect-screen') {
                         screenManager.showScreen('profile-screen');
                     }
                  }, 3000); // Back to profile on error
             }
        }


        // Connect Screen Buttons (Simulated Game Start)
        $('#btn-create-server').on('click', () => {
            $('#join-game-section').hide(); $('#server-status-section').show(); $('#server-ip-code').text('SIMULANDO...'); $('#connect-message').text('Simulando... Iniciando Jogo Solo.');
            const decks = accountManager.loadDecks(); const firstDeckId = decks ? Object.keys(decks)[0] : null;
            if (!firstDeckId || !decks[firstDeckId] || decks[firstDeckId].cards?.length < 30) { $('#connect-message').text('Erro: Nenhum deck válido (mín 30). Crie/Edite no Perfil.').css('color', 'salmon'); $('#server-status-section').hide(); return; }
            setTimeout(() => initializeAndStartGame(firstDeckId), 1000); // Pass deck ID
        });
        $('#btn-show-join-options').on('click', () => { $('#server-status-section').hide(); $('#join-game-section').show(); $('#connect-message').text(''); });
        $('#btn-connect-to-server').on('click', () => {
            const code = $('#opponent-ip').val().trim(); $('#connect-message').text(`Simulando conexão com ${code || 'host'}... Iniciando Jogo Solo.`);
            const decks = accountManager.loadDecks(); const firstDeckId = decks ? Object.keys(decks)[0] : null;
            if (!firstDeckId || !decks[firstDeckId] || decks[firstDeckId].cards?.length < 30) { $('#connect-message').text('Erro: Nenhum deck válido (mín 30). Crie/Edite no Perfil.').css('color', 'salmon'); return; }
            setTimeout(() => initializeAndStartGame(firstDeckId), 1000); // Pass deck ID
        });
        $('#btn-cancel-hosting').on('click', () => { $('#server-status-section').hide(); $('#connect-message').text('Criação cancelada.'); });

        // --- Final Log ---
        console.log("Runebound Clash UI Ready (v2.1 - Shake Feedback).");

    } catch (initError) {
        console.error("MAIN: Critical initialization error:", initError);
        // Try to display the error on the splash screen if possible
         const $splashSevereError = $('#splash-screen');
         if ($splashSevereError.length) {
              $splashSevereError.text(`Erro Crítico: ${initError.message}. Recarregue.`).css('color', 'red');
              $('.screen').removeClass('active');
              $splashSevereError.addClass('active');
         } else {
            // Fallback if splash itself wasn't even generated
            $screensContainer.html(`<p style="color:red; font-weight:bold;">Erro Crítico de Inicialização: ${initError.message}. Recarregue.</p>`);
         }
    }
}); // --- END Document Ready ---
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\main.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\utils.js ---
// js/utils.js

/**
 * Shuffles an array in place using the Fisher-Yates (Durstenfeld variation) algorithm.
 * @param {Array<any>} array The array to shuffle.
 * @returns {Array<any>} The shuffled array (the same instance passed in).
 */
export function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        // Generate random index from 0 to i (inclusive)
        const j = Math.floor(Math.random() * (i + 1));
        // Swap elements array[i] and array[j]
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/** Simple counter for generating unique IDs within a session. */
let uniqueInstanceCounter = 0;

/**
 * Generates a simple unique ID string. Useful for card instances/players within a game session.
 * Format: type_<timestamp>_<counter>
 * Not guaranteed to be unique across different sessions or globally.
 * @param {string} [prefix='instance'] - Optional prefix for the ID.
 * @returns {string} A unique ID string.
 */
export function generateUniqueId(prefix = 'instance') {
    uniqueInstanceCounter++;
    return `${prefix}_${Date.now()}_${uniqueInstanceCounter}`;
}

/**
 * Loads card definitions.
 * In a real app, this would likely fetch a JSON file.
 * For now, it uses the provided JSON structure.
 * IMPORTANT: Add unique 'id' fields to your card definitions JSON!
 * @returns {object | null} An object mapping card IDs to definitions, or null on error.
 */
export function loadCardDefinitions() {
    // --- PASTE YOUR CARD JSON DATA HERE ---
    // IMPORTANT: Make sure each card object has a unique "id" field (e.g., "CR001", "RB001")
    const cardDataJson = {
        "cards": [
             { "id": "CR001", "name": "Elven Ranger", "type": "Creature", "cost": 2, "attack": 2, "toughness": 2, "tribe": "Elf", "image_src": "assets/images/cards/elf_ranger.png", "description": "Quick and agile, ideal for early pressure." },
             { "id": "CR002", "name": "Dwarven Guardian", "type": "Creature", "cost": 3, "attack": 1, "toughness": 4, "tribe": "Dwarf", "image_src": "assets/images/cards/dwarf_guardian.png", "description": "A stalwart defender that protects allies." },
             { "id": "CR003", "name": "Plague Rat", "type": "Creature", "cost": 1, "attack": 1, "toughness": 1, "tribe": "Beast", "image_src": "assets/images/cards/plague_rat.png", "description": "A disposable creature." },
             { "id": "CR004", "name": "Molten Wyrm", "type": "Creature", "cost": 6, "attack": 5, "toughness": 4, "tribe": "Dragon", "image_src": "assets/images/cards/molten_wyrm.png", "description": "A powerful finisher." },
             { "id": "CR005", "name": "Soul Revenant", "type": "Creature", "cost": 4, "attack": 3, "toughness": 2, "tribe": "Undead", "image_src": "assets/images/cards/soul_revenant.png", "description": "Hard to kill." },
             { "id": "CR006", "name": "Storm Elemental", "type": "Creature", "cost": 5, "attack": 4, "toughness": 3, "tribe": "Elemental", "image_src": "assets/images/cards/storm_elemental.png", "description": "An elemental creature." },
             { "id": "CR007", "name": "Human Duelist", "type": "Creature", "cost": 2, "attack": 3, "toughness": 1, "tribe": "Human", "image_src": "assets/images/cards/human_duelist.png", "description": "Simple, fast, and deadly." },
             { "id": "CR008", "name": "Crystal Golem", "type": "Creature", "cost": 4, "attack": 2, "toughness": 5, "tribe": "Construct", "image_src": "assets/images/cards/crystal_golem.png", "description": "Solid magical defense unit." },
             { "id": "CR009", "name": "Feral Bear", "type": "Creature", "cost": 3, "attack": 3, "toughness": 3, "tribe": "Beast", "image_src": "assets/images/cards/feral_bear.png", "description": "Balanced creature." },
             { "id": "CR010", "name": "Firebrand Zealot", "type": "Creature", "cost": 2, "attack": 2, "toughness": 1, "tribe": "Human", "image_src": "assets/images/cards/firebrand_zealot.png", "description": "Fierce attacker." },
             { "id": "CR011", "name": "Wisp of Light", "type": "Creature", "cost": 1, "attack": 1, "toughness": 1, "tribe": "Spirit", "image_src": "assets/images/cards/wisp_of_light.png", "description": "Tiny, but helpful." },
             { "id": "CR012", "name": "Ghoul Devourer", "type": "Creature", "cost": 4, "attack": 4, "toughness": 2, "tribe": "Undead", "image_src": "assets/images/cards/ghoul_devourer.png", "description": "Feeds on the fallen." },
             { "id": "CR013", "name": "Stonecaller", "type": "Creature", "cost": 5, "attack": 2, "toughness": 6, "tribe": "Dwarf", "image_src": "assets/images/cards/stonecaller.png", "description": "A support tank." },
             { "id": "CR014", "name": "Shadowblade Assassin", "type": "Creature", "cost": 3, "attack": 3, "toughness": 1, "tribe": "Elf", "image_src": "assets/images/cards/shadowblade_assassin.png", "description": "Strike fast." },
             { "id": "CR015", "name": "Volcanic Behemoth", "type": "Creature", "cost": 7, "attack": 7, "toughness": 7, "tribe": "Elemental", "image_src": "assets/images/cards/volcanic_behemoth.png", "description": "Massive threat." },
             { "id": "CR016", "name": "Arcane Familiar", "type": "Creature", "cost": 2, "attack": 1, "toughness": 2, "tribe": "Spirit", "image_src": "assets/images/cards/arcane_familiar.png", "description": "Helpful spirit." },
             { "id": "RB001", "name": "Destroy", "type": "Runebinding", "cost": 2, "effect": "Destroy target creature", "image_src": "assets/images/cards/destroy.png", "description": "Eliminates a threat." },
             { "id": "RB_DRAW2", "name": "Draw Rune", "type": "Runebinding", "cost": 2, "effect": "Draw 2 cards", "image_src": "assets/images/cards/draw_rune.png", "description": "Expands your options." }, // Changed ID slightly
             { "id": "RB_SILENCE", "name": "Silence", "type": "Runebinding", "cost": 1, "effect": "Target creature can't attack next turn", "image_src": "assets/images/cards/silence.png", "description": "Temporarily disables a unit." }, // Changed ID
             { "id": "RB_POWER", "name": "Power Boost", "type": "Runebinding", "cost": 1, "effect": "Target creature gains +2 attack this turn", "image_src": "assets/images/cards/power_boost.png", "description": "Extra punch." }, // Changed ID
             { "id": "RB_TOUGH", "name": "Toughness Boost", "type": "Runebinding", "cost": 1, "effect": "Target creature gains +2 toughness this turn", "image_src": "assets/images/cards/toughness_boost.png", "description": "Extra defense." }, // Changed ID
             { "id": "IS001", "name": "Heal", "type": "Instant", "cost": 2, "effect": "Restore 4 life", "image_src": "assets/images/cards/heal.png", "description": "A burst of recovery." },
             { "id": "IS002", "name": "Fireball", "type": "Instant", "cost": 2, "effect": "Deal 3 damage to target creature", "image_src": "assets/images/cards/fireball.png", "description": "Burns a creature." },
             { "id": "IS003", "name": "Draw", "type": "Instant", "cost": 1, "effect": "Draw 2 cards", "image_src": "assets/images/cards/draw.png", "description": "Refill your hand." },
             { "id": "IS004", "name": "Shield", "type": "Instant", "cost": 1, "effect": "Prevent all damage to a creature this turn", "image_src": "assets/images/cards/shield.png", "description": "Protect a key creature." },
             { "id": "IS005", "name": "Bounce", "type": "Instant", "cost": 3, "effect": "Return target creature to its owner's hand", "image_src": "assets/images/cards/bounce.png", "description": "Reset an enemy creature." },
             { "id": "IS006", "name": "Destroy Binding", "type": "Instant", "cost": 2, "effect": "Destroy target Runebinding", "image_src": "assets/images/cards/destroy_binding.png", "description": "Dispel enchantments." },
             { "id": "IS007", "name": "Weaken", "type": "Instant", "cost": 1, "effect": "Target creature gets -2 attack this turn", "image_src": "assets/images/cards/weaken.png", "description": "Debilitate the enemy." }
        ]
    };
    // --- END OF CARD JSON DATA ---

    try {
        const cardDatabase = {};
        if (!cardDataJson || !Array.isArray(cardDataJson.cards)) {
            throw new Error("Invalid card data structure.");
        }
        cardDataJson.cards.forEach(cardDef => {
            if (!cardDef.id) {
                console.warn(`Card "${cardDef.name}" is missing a unique 'id' field. Skipping.`);
                return; // Skip cards without an ID
            }
            if (cardDatabase[cardDef.id]) {
                console.warn(`Duplicate card ID "${cardDef.id}" found for card "${cardDef.name}". Overwriting previous entry.`);
            }
            cardDatabase[cardDef.id] = cardDef;
        });

        if (Object.keys(cardDatabase).length === 0) {
             console.warn("Card database loaded, but is empty or all cards lacked IDs.");
        } else {
            console.log(`Card definitions loaded successfully: ${Object.keys(cardDatabase).length} cards.`);
        }
        return cardDatabase;

    } catch (error) {
        console.error("Error loading or parsing card definitions:", error);
        return null; // Return null to indicate failure
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\utils.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\account\AccountManager.js ---
// js/account/AccountManager.js

// Chaves usadas para armazenar os dados no localStorage/sessionStorage
const ACCOUNTS_STORAGE_KEY = 'runebound_clash_accounts';
const CURRENT_USER_SESSION_KEY = 'runebound_clash_current_user';

/**
 * Gerencia contas de usuário, login, logout e dados associados (decks, histórico, avatar).
 * Utiliza localStorage para persistência entre sessões e sessionStorage para o login atual.
 * IMPORTANTE: Este exemplo armazena senhas em texto plano no localStorage,
 * o que NÃO É SEGURO para produção. Em uma aplicação real, use hashing de senhas no servidor.
 */
export default class AccountManager {
    #accounts = {}; // Objeto para armazenar todos os dados das contas carregadas
    #currentUser = null; // Objeto do usuário atualmente logado

    constructor() {
        this.#loadAccounts();
        this.#loadCurrentUserFromSession();
        console.log("AccountManager inicializado.");
        // Alerta de segurança sobre senhas em texto plano
        console.warn("ATENÇÃO: Este AccountManager armazena senhas em texto plano no localStorage. NÃO use em produção!");
    }

    // --- Métodos Privados ---

    /** Carrega as contas do localStorage para a memória. */
    #loadAccounts() {
        const storedAccounts = localStorage.getItem(ACCOUNTS_STORAGE_KEY);
        if (storedAccounts) {
            try {
                this.#accounts = JSON.parse(storedAccounts);
                 console.log(`Contas carregadas do localStorage: ${Object.keys(this.#accounts).length}`);
            } catch (error) {
                console.error("Erro ao carregar/parsear contas do localStorage:", error);
                this.#accounts = {};
                localStorage.removeItem(ACCOUNTS_STORAGE_KEY);
            }
        } else {
            this.#accounts = {};
             console.log("Nenhuma conta encontrada no localStorage.");
        }
    }

    /** Salva o estado atual das contas de volta no localStorage. */
    #saveAccounts() {
        try {
            localStorage.setItem(ACCOUNTS_STORAGE_KEY, JSON.stringify(this.#accounts));
             console.log("Contas salvas no localStorage.");
        } catch (error) {
            console.error("Erro ao salvar contas no localStorage:", error);
        }
    }

     /** Tenta carregar o usuário logado da sessionStorage. */
     #loadCurrentUserFromSession() {
        const currentUsername = sessionStorage.getItem(CURRENT_USER_SESSION_KEY);
        if (currentUsername && this.#accounts[currentUsername]) {
            this.#currentUser = this.#accounts[currentUsername]; // Load from already parsed accounts
            console.log(`Sessão ativa encontrada para: ${currentUsername}`);
        } else {
            this.#currentUser = null;
            if (sessionStorage.getItem(CURRENT_USER_SESSION_KEY)){
                console.log("Sessão encontrada, mas usuário não existe mais nas contas. Limpando sessão.");
                sessionStorage.removeItem(CURRENT_USER_SESSION_KEY);
            } else {
                 console.log("Nenhuma sessão ativa encontrada.");
            }
        }
    }

     /** Define o usuário atual na memória e na sessionStorage. */
     #setCurrentUser(userData) {
        if(userData && userData.username) {
            this.#currentUser = userData;
            try {
                sessionStorage.setItem(CURRENT_USER_SESSION_KEY, userData.username);
                 console.log(`Sessão definida para: ${userData.username}`);
            } catch(e) {
                console.error("Erro ao salvar sessão no sessionStorage:", e);
            }
        } else {
            this.#currentUser = null;
             try {
                sessionStorage.removeItem(CURRENT_USER_SESSION_KEY);
                console.log("Sessão removida.");
             } catch(e) {
                 console.error("Erro ao remover sessão do sessionStorage:", e);
             }
        }
     }

     /** Cria a estrutura de dados padrão para um novo usuário. */
     #createDefaultUserData(username, password) {
        console.log(`Criando dados padrão para novo usuário: ${username}`);
        const startingCollection = [
            'CR001', 'CR002', 'CR003', 'CR007', 'CR009', 'CR010', 'CR011', 'CR016', // Creatures
            'RB001', 'RB_DRAW2', 'RB_POWER', 'RB_TOUGH',                          // Runebindings
            'IS001', 'IS002', 'IS003', 'IS004'                                   // Instants
        ];
        console.log("Coleção inicial definida com:", startingCollection);

        const defaultDeckCards = [
            'CR001', 'CR001', 'CR001', 'CR001', 'CR003', 'CR003', 'CR003', 'CR003',
            'CR007', 'CR007', 'CR007', 'CR011', 'CR011', 'CR011', 'CR009', 'CR009',
            'CR016', 'CR016', 'CR010', 'CR010', 'CR002', 'IS002', 'IS002', 'IS002',
            'IS002', 'IS003', 'IS003', 'IS003', 'RB_POWER','RB_POWER', 'RB_TOUGH',
            'RB_TOUGH', 'IS004', 'IS004', 'IS001', 'RB001', 'RB_DRAW2' // Total: 37 cards
        ];
         console.log("Deck inicial definido com:", defaultDeckCards.length, "cartas");

        return {
            username: username,
            password: password, // INSECURE!
            rank: 'Bronze III',
            stats: { wins: 0, losses: 0 },
            matchHistory: [],
            collection: startingCollection,
            decks: {
                'default_deck_1': {
                    id: 'default_deck_1',
                    name: 'Deck Inicial Padrão',
                    cards: defaultDeckCards
                }
            },
            // --- ADD AVATAR FIELD ---
            avatar: 'default.png', // Default avatar filename
            // -----------------------
            createdAt: Date.now()
        };
     }


    // --- Métodos Públicos ---

    createAccount(username, password) {
        if (!username || !password) { return { success: false, message: "Nome de usuário e senha são obrigatórios." }; }
        if (username.length < 3) { return { success: false, message: "Nome de usuário deve ter pelo menos 3 caracteres." }; }
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
        if (this.#accounts[username]) { return { success: false, message: "Este nome de usuário já está em uso." }; }
        const newUser = this.#createDefaultUserData(username, password);
        this.#accounts[username] = newUser;
        this.#saveAccounts();
        console.log(`Conta criada com sucesso para: ${username}`);
        return { success: true, message: "Conta criada com sucesso!", user: newUser };
    }

    login(username, password) {
        if (!username || !password) { return { success: false, message: "Nome de usuário e senha obrigatórios." }; }
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
        const userData = this.#accounts[username];
        if (!userData) { return { success: false, message: "Usuário não encontrado." }; }
        if (userData.password !== password) { return { success: false, message: "Senha incorreta." }; } // INSECURE!
        this.#setCurrentUser(userData);
        console.log(`Usuário ${username} logado com sucesso.`);
        return { success: true, message: "Login bem-sucedido!", user: this.#currentUser };
    }

    logout() {
        const username = this.#currentUser?.username;
        this.#setCurrentUser(null);
        if (username) { console.log(`Usuário ${username} desconectado.`); }
    }

    getCurrentUser() {
        if (!this.#currentUser) { this.#loadCurrentUserFromSession(); }
        // Ensure avatar exists even if loaded from old data
        if (this.#currentUser && typeof this.#currentUser.avatar === 'undefined') {
             this.#currentUser.avatar = 'default.png'; // Add default avatar if missing
             if (this.#accounts[this.#currentUser.username]) { // Ensure it exists in main map too
                this.#accounts[this.#currentUser.username] = this.#currentUser;
                this.#saveAccounts(); // Save the added default avatar
             }
        }
        return this.#currentUser ? { ...this.#currentUser } : null;
    }

    getUserData(username) {
        if (Object.keys(this.#accounts).length === 0) this.#loadAccounts();
         // Ensure avatar exists (similar to getCurrentUser) - might be overkill if only used internally
        const userData = this.#accounts[username];
         if (userData && typeof userData.avatar === 'undefined') {
             userData.avatar = 'default.png';
             this.#saveAccounts(); // Save if modified
         }
        return userData ? { ...userData } : null;
    }

    // --- Deck & Data Management ---

    saveDeck(deckId, deckName, cardIds) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!deckId || !deckName || !Array.isArray(cardIds)) { return { success: false, message: "Dados inválidos para salvar o deck." }; }
        if (cardIds.length < 30 || cardIds.length > 40) { return { success: false, message: "O deck deve ter entre 30 e 40 cartas." }; }
        if (!this.#currentUser.decks) { this.#currentUser.decks = {}; }
        this.#currentUser.decks[deckId] = { id: deckId, name: deckName, cards: cardIds, lastUpdated: Date.now() };
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Deck '${deckName}' (ID: ${deckId}) salvo para ${this.#currentUser.username}.`);
        return { success: true, message: "Deck salvo com sucesso!" };
    }

     deleteDeck(deckId) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!this.#currentUser.decks || !this.#currentUser.decks[deckId]) { return { success: false, message: "Deck não encontrado." }; }
        if (Object.keys(this.#currentUser.decks).length <= 1) { /* Optional: return { success: false, message: "Não pode excluir último deck." }; */ }
        delete this.#currentUser.decks[deckId];
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Deck ID '${deckId}' excluído para ${this.#currentUser.username}.`);
        return { success: true, message: "Deck excluído com sucesso!" };
     }

    loadDecks() {
        const user = this.getCurrentUser(); return user?.decks ? { ...user.decks } : null;
    }
     getCollection() {
        const user = this.getCurrentUser(); return user?.collection ? [...user.collection] : null;
     }

     /** Saves the user's chosen avatar preference */
     saveAvatarChoice(avatarFilename) {
         if (!this.#currentUser) { console.warn("Cannot save avatar choice, no user logged in."); return false; }
         if (typeof avatarFilename !== 'string') { console.warn("Invalid avatar filename provided."); return false; }
         this.#currentUser.avatar = avatarFilename;
         this.#accounts[this.#currentUser.username] = this.#currentUser;
         this.#saveAccounts();
         console.log(`Avatar choice saved for ${this.#currentUser.username}: ${avatarFilename}`);
         return true;
     }

     addMatchHistory(matchData) {
        if (!this.#currentUser) { return { success: false, message: "Nenhum usuário logado." }; }
        if (!matchData?.opponent || !matchData?.result) { return { success: false, message: "Dados inválidos da partida." }; }
        const historyEntry = { ...matchData, date: Date.now() };
        if (!this.#currentUser.matchHistory) this.#currentUser.matchHistory = [];
        if (!this.#currentUser.stats) this.#currentUser.stats = { wins: 0, losses: 0 };
        this.#currentUser.matchHistory.unshift(historyEntry);
        if (this.#currentUser.matchHistory.length > 50) this.#currentUser.matchHistory.pop();
        if (matchData.result === 'win') this.#currentUser.stats.wins++;
        else if (matchData.result === 'loss') this.#currentUser.stats.losses++;
        this.#accounts[this.#currentUser.username] = this.#currentUser;
        this.#saveAccounts();
        console.log(`Histórico de partida adicionado para ${this.#currentUser.username}.`);
        return { success: true, message: "Histórico salvo." };
     }

     getMatchHistory() { const user = this.getCurrentUser(); return user?.matchHistory ? [...user.matchHistory] : null; }
     getStats() { const user = this.getCurrentUser(); return user?.stats ? { ...user.stats } : null; }
     getRank() { const user = this.getCurrentUser(); return user?.rank || null; }

} // End of class AccountManager
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\account\AccountManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Battlefield.js ---
// js/core/Battlefield.js
/**
 * Represents the battlefield zone for a player.
 */
export class Battlefield { // Using export class
    #cards = new Map(); // Map<string, Card> (uniqueId -> CardInstance)

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        if (this.#cards.has(cardInstance.uniqueId)) return false;
        this.#cards.set(cardInstance.uniqueId, cardInstance);
        return true;
    }

    removeCard(cardUniqueId) {
        const card = this.#cards.get(cardUniqueId);
        if (card) {
            this.#cards.delete(cardUniqueId);
            return card;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.get(cardUniqueId) || null;
    }

    getAllCards() {
        return [...this.#cards.values()];
    }

    getCreatures() {
        // Assuming CreatureCard is imported if needed for instanceof
        return this.getAllCards().filter(card => card.type === 'Creature');
    }

    getSize() {
        return this.#cards.size;
    }

    untapAll() {
        this.#cards.forEach(card => {
            if (typeof card.untap === 'function') card.untap();
        });
    }

    clear() {
        this.#cards.clear();
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Battlefield.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Card.js ---
// js/core/Card.js
import { generateUniqueId } from '../utils.js';

export default class Card { // Using export default
    #id;
    #uniqueId;
    #name;
    #type;
    #cost;
    #imageSrc;
    #description;
    #ownerId;
    location = 'deck'; // deck, hand, battlefield, graveyard

    constructor(cardDefinition, ownerId) {
        if (!cardDefinition || !cardDefinition.id) throw new Error("Invalid card definition provided to Card constructor.");
        this.#id = cardDefinition.id;
        this.#uniqueId = generateUniqueId(`card_${cardDefinition.id}`); // Prefix with card type/id
        this.#name = cardDefinition.name;
        this.#type = cardDefinition.type;
        this.#cost = cardDefinition.cost;
        this.#imageSrc = cardDefinition.image_src || 'assets/images/cards/default.png';
        this.#description = cardDefinition.description || '';
        this.#ownerId = ownerId;
        this.location = 'deck';
    }

    // --- Getters ---
    get id() { return this.#id; }
    get uniqueId() { return this.#uniqueId; }
    get name() { return this.#name; }
    get type() { return this.#type; }
    get cost() { return this.#cost; }
    get imageSrc() { return this.#imageSrc; }
    get description() { return this.#description; }
    get ownerId() { return this.#ownerId; }

    // --- Basic Methods (to be overridden) ---

    canPlay(player, game) {
        if (!player || !game || !game.getCurrentPlayer) return false; // Basic safety
        const currentPlayer = game.getCurrentPlayer();
        if (!currentPlayer || player.id !== currentPlayer.id) return false; // Not player's turn
        if (player.mana < this.cost) return false; // Not enough mana
        if (this.location !== 'hand') return false; // Must be in hand
        // Add phase checks in subclasses (Instants vs others)
        return true;
    }

    /** Base play method - subclasses must implement actual logic */
    play(player, game, targetId = null) {
        // Basic checks are done before calling this usually by Player.playCard
        // This method *in the base class* just confirms mana cost is paid
        // Subclasses will handle moving the card and applying effects.
        console.log(`Card: Base play method called for ${this.name}. Mana should be spent by caller.`);
        // game.emitEvent('cardPlayed', { card: this.getRenderData(), player: player.getRenderData(), targetId }); // Emit basic event
        return true; // Return true indicating the 'play' sequence started
    }

     /** Placeholder: Does this card require a target? Subclasses override. */
     requiresTarget() {
        return false;
     }

     /** Placeholder: What kind of target? Subclasses override. */
     targetType() {
        return null;
     }

    // --- Rendering ---
    getRenderData() {
        return {
            uniqueId: this.uniqueId, id: this.id, name: this.name,
            cost: this.cost, type: this.type, imageSrc: this.imageSrc,
            description: this.description, location: this.location, ownerId: this.ownerId
        };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Card.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CombatManager.js ---
// js/core/CombatManager.js

/**
 * Manages the combat phase, including declaring attackers, blockers,
 * and resolving damage.
 */
export default class CombatManager {
    #game; // Reference to the main Game instance
    #attackers = new Map(); // Map<string, CreatureCard> - Attacking creatures by uniqueId
    #blockerAssignments = new Map(); // Map<string, string[]> - Attacker uniqueId -> [Array of blocker uniqueIds]
    #combatState = 'none'; // 'none', 'declare_attackers', 'declare_blockers', 'resolving'

    /**
     * Creates a CombatManager instance.
     * @param {Game} gameInstance - The main game instance.
     */
    constructor(gameInstance) {
        if (!gameInstance) {
            throw new Error("CombatManager requires a valid Game instance.");
        }
        this.#game = gameInstance;
        this.#combatState = 'none';
        console.log("CombatManager: Instance created.");
    }

    /** Resets the combat state for a new combat phase or turn. */
    reset() {
        this.#attackers.clear();
        this.#blockerAssignments.clear();
        this.#combatState = 'none';
        console.log("CombatManager: State reset.");
    }

    /**
     * Sets the attacking creatures for the current combat phase.
     * @param {Player} attackingPlayer - The player declaring attackers.
     * @param {string[]} attackerIds - Array of uniqueIds of the creatures declared as attackers.
     * @returns {boolean} True if attackers were successfully declared, false otherwise.
     */
    declareAttackers(attackingPlayer, attackerIds) {
        if (this.#combatState !== 'none' && this.#combatState !== 'declare_attackers') {
            console.warn(`CombatManager: Cannot declare attackers in state: ${this.#combatState}`);
            return false;
        }
        if (this.#game.getCurrentPhase() !== 'attack') {
            console.warn(`CombatManager: Cannot declare attackers outside of attack phase.`);
             this.#game.emitEvent('gameLog', { message: `Ataque só pode ser declarado na Fase de Ataque.` });
            return false;
        }
        if (this.#game.getCurrentPlayer()?.id !== attackingPlayer.id) {
             console.warn(`CombatManager: Only the current player can declare attackers.`);
             this.#game.emitEvent('gameLog', { message: `Apenas o jogador ativo pode atacar.` });
             return false;
        }

        this.#attackers.clear(); // Clear previous attackers for this combat
        const declaredAttackers = [];
        let success = true;

        for (const id of attackerIds) {
            const creature = attackingPlayer.battlefield.getCard(id);
            if (creature && creature.type === 'Creature' && creature.canAttack()) {
                this.#attackers.set(id, creature);
                declaredAttackers.push(creature.getRenderData()); // For event
            } else {
                console.warn(`CombatManager: Creature ${id} cannot attack or was not found.`);
                 this.#game.emitEvent('gameLog', { message: `Criatura inválida para atacar: ${creature?.name || id}` });
                success = false; // Allow declaring valid ones, but report failure if any invalid
            }
        }

        if (this.#attackers.size > 0) {
            console.log(`CombatManager: ${this.#attackers.size} attackers declared by ${attackingPlayer.name}.`);
            this.#combatState = 'declare_blockers'; // Move state forward
            // Tap the attacking creatures
            this.#attackers.forEach(attacker => {
                 attacker.tap(); // Creature method handles isTapped state
                 this.#game.emitEvent('creatureUpdate', { cardUniqueId: attacker.uniqueId, updates: { isTapped: true } });
            });
            // Emit event AFTER setting state and tapping
            this.#game.emitEvent('attackersDeclared', {
                attackingPlayerId: attackingPlayer.id,
                attackers: declaredAttackers // Send data about declared attackers
            });
        } else {
            console.log(`CombatManager: No valid attackers declared by ${attackingPlayer.name}. Skipping to next phase.`);
             this.#game.emitEvent('gameLog', { message: `Nenhum atacante válido declarado.` });
            // If no attackers, combat effectively ends, proceed past blocker declaration
            this.#combatState = 'resolving'; // Or directly call resolveCombat which resets?
            this.resolveCombat(); // Resolve immediately (will do nothing and reset)
        }

        return success; // Indicates if *all* requested attackers were valid
    }

    /**
     * Sets the blocker assignments for the current combat.
     * @param {Player} defendingPlayer - The player declaring blockers.
     * @param {Map<string, string[]>} assignments - Map where key is attacker uniqueId and value is array of blocker uniqueIds.
     * @returns {boolean} True if blockers were successfully declared.
     */
    declareBlockers(defendingPlayer, assignments) {
        if (this.#combatState !== 'declare_blockers') {
            console.warn(`CombatManager: Cannot declare blockers in state: ${this.#combatState}`);
            return false;
        }
        // Add check: Ensure it's the defending player's turn to declare blockers (implicitly handled by game flow)

        this.#blockerAssignments.clear();
        const declaredBlockersInfo = []; // For event
        let allValid = true;

        assignments.forEach((blockerIds, attackerId) => {
            const attacker = this.#attackers.get(attackerId);
            if (!attacker) {
                console.warn(`CombatManager: Invalid attacker ID ${attackerId} in blocker assignments.`);
                allValid = false;
                return; // Skip this assignment
            }

            const validBlockersForThisAttacker = [];
            for (const blockerId of blockerIds) {
                const blocker = defendingPlayer.battlefield.getCard(blockerId);
                // TODO: Add more complex block validation (e.g., Flying)
                if (blocker && blocker.type === 'Creature' && blocker.canBlock()) {
                    validBlockersForThisAttacker.push(blockerId);
                     // Add to event data only if valid
                     if (!declaredBlockersInfo.find(b => b.blockerId === blockerId)) {
                         declaredBlockersInfo.push({ blockerId: blockerId, blockerData: blocker.getRenderData() });
                     }
                } else {
                    console.warn(`CombatManager: Creature ${blockerId} cannot block ${attackerId} or not found.`);
                     this.#game.emitEvent('gameLog', { message: `Bloqueador inválido: ${blocker?.name || blockerId}` });
                    allValid = false;
                }
            }
            if (validBlockersForThisAttacker.length > 0) {
                this.#blockerAssignments.set(attackerId, validBlockersForThisAttacker);
                 console.log(`CombatManager: Attacker ${attacker.name} (${attackerId}) blocked by [${validBlockersForThisAttacker.join(', ')}]`);
            }
        });

        console.log(`CombatManager: Blockers declared by ${defendingPlayer.name}.`);
        this.#combatState = 'resolving'; // Move state forward

        this.#game.emitEvent('blockersDeclared', {
            defendingPlayerId: defendingPlayer.id,
            blockerAssignments: Object.fromEntries(this.#blockerAssignments), // Convert Map for event
            declaredBlockers: declaredBlockersInfo
        });

        // Immediately proceed to resolve combat after blockers are declared
        this.resolveCombat();

        return allValid; // Indicates if *all* assignments were fully valid
    }


    /** Resolves combat damage based on declared attackers and blockers. */
    resolveCombat() {
        if (this.#combatState !== 'resolving') {
            console.warn(`CombatManager: Cannot resolve combat in state: ${this.#combatState}. Assuming pre-declared or no combat.`);
            this.reset(); // Reset state if called unexpectedly
            return;
        }
        console.log("CombatManager: Resolving combat...");

        const defendingPlayer = this.#game.getOpponent(this.#game.getCurrentPlayer()?.id); // Player whose turn it ISN'T
        if (!defendingPlayer) {
             console.error("CombatManager: Could not determine defending player.");
             this.reset();
             return;
        }

        const damageEvents = []; // Store damage to apply simultaneously later (optional, simpler to apply directly)

        // Iterate through attackers
        this.#attackers.forEach((attacker, attackerId) => {
            const blockers = this.#blockerAssignments.get(attackerId);

            if (blockers && blockers.length > 0) {
                // --- Attacker is Blocked ---
                console.log(`CombatManager: Resolving blocked combat for ${attacker.name}`);
                let totalBlockerAttack = 0;
                const blockerInstances = [];

                blockers.forEach(blockerId => {
                    const blocker = defendingPlayer.battlefield.getCard(blockerId);
                    if (blocker) {
                        blockerInstances.push(blocker);
                        totalBlockerAttack += blocker.attack;
                    }
                });

                // Attacker deals damage to blocker(s)
                // Simple: Attacker deals full damage to first blocker only (adjust for multi-block rules)
                if (blockerInstances.length > 0) {
                    console.log(`CombatManager: ${attacker.name} deals ${attacker.attack} damage to ${blockerInstances[0].name}`);
                    blockerInstances[0].takeDamage(attacker.attack, attacker, this.#game);
                }

                // Blocker(s) deal damage to attacker
                console.log(`CombatManager: Blockers deal ${totalBlockerAttack} damage to ${attacker.name}`);
                attacker.takeDamage(totalBlockerAttack, blockerInstances[0], this.#game); // Source attribution might need work for multi-block

            } else {
                // --- Attacker is Unblocked ---
                console.log(`CombatManager: Unblocked attacker ${attacker.name} deals ${attacker.attack} damage to player ${defendingPlayer.name}`);
                defendingPlayer.takeDamage(attacker.attack, attacker, this.#game);
            }
        });

        console.log("CombatManager: Combat damage resolved.");
        this.#game.emitEvent('combatResolved', {
            // Include details about damage dealt, creatures died etc. if needed
        });

        // Reset state after resolution
        this.reset();
    }

    // --- Getters for state (optional) ---
    get state() { return this.#combatState; }
    getAttackers() { return [...this.#attackers.values()]; } // Return array copy
    getBlockerAssignments() { return new Map(this.#blockerAssignments); } // Return map copy
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CombatManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CreatureCard.js ---
// js/core/CreatureCard.js
import Card from './Card.js'; // Correct: Card uses export default

export default class CreatureCard extends Card { // Using export default
    #attack;
    #toughness;
    #currentToughness;
    #tribe;
    #abilities;
    #isTapped = false;
    #summoningSickness = true;
    #damageTakenThisTurn = 0; // Might not be needed

    // Buffs/Debuffs/Status Effects
    #tempBoosts = []; // Array of { boost: { attack?, toughness? }, duration: ticks }
    #statusEffects = new Map(); // Map<string, number> (effectName -> duration)

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId);
        if (cardDefinition.type !== 'Creature') throw new Error(`Definition "${cardDefinition.name}" is not type Creature.`);
        this.#attack = cardDefinition.attack ?? 0;
        this.#toughness = cardDefinition.toughness ?? 1;
        this.#currentToughness = this.#toughness; // Initialize current = max
        this.#tribe = cardDefinition.tribe || 'None';
        this.#abilities = cardDefinition.abilities || [];
        this.#tempBoosts = [];
        this.#statusEffects = new Map();
    }

    // --- Getters (applying modifiers) ---
    get baseAttack() { return this.#attack; }
    get baseToughness() { return this.#toughness; }

    get attack() { // Calculated attack
        let currentAttack = this.#attack;
        this.#tempBoosts.forEach(b => { currentAttack += (b.boost.attack || 0); });
        // TODO: Add permanent modifiers if any (e.g., from auras)
        return Math.max(0, currentAttack);
    }
    get toughness() { // Calculated max toughness
        let currentMaxToughness = this.#toughness;
         this.#tempBoosts.forEach(b => { currentMaxToughness += (b.boost.toughness || 0); });
         // TODO: Add permanent modifiers
         return Math.max(1, currentMaxToughness);
    }
     get currentToughness() { return this.#currentToughness; }

    get tribe() { return this.#tribe; }
    get abilities() { return [...this.#abilities]; } // Copy
    get isTapped() { return this.#isTapped; }
    get hasSummoningSickness() { return this.#summoningSickness; }
    hasStatusEffect(effectName) { return this.#statusEffects.has(effectName); }

    // --- Play Logic ---
    canPlay(player, game) {
        if (!super.canPlay(player, game)) return false;
        // Creatures usually played in Main Phase
        if (game.getCurrentPhase() !== 'main') return false;
        // TODO: Check battlefield limits
        return true;
    }

    play(player, game, targetId = null) {
        // Called AFTER Player spends mana
        console.log(`Creature: ${player.name} playing ${this.name}.`);
        const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'battlefield');
        if (moved) {
            this.#summoningSickness = true;
            this.#isTapped = false;
            this.onEnterBattlefield(game, player); // Trigger ETB effects
            // Emit full update after entering field
            game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: this.getRenderData() });
            return true;
        } else {
            console.error(`Creature: Failed move to battlefield for ${this.name}.`);
            return false; // Indicate failure
        }
    }

    // --- Combat and State ---
    canAttack() {
        return this.location === 'battlefield'
            && !this.#isTapped
            && !this.#summoningSickness
            && this.attack > 0
            && !this.hasStatusEffect('cant_attack')
            && !this.hasStatusEffect('silenced'); // Added silence check
    }
    canBlock() {
        // TODO: Add check for flying/reach interaction if relevant
        return this.location === 'battlefield'
            && !this.#isTapped
            && !this.hasStatusEffect('cant_block');
    }

    /** Explicitly taps the creature */
    tap() {
        if (!this.#isTapped) {
            this.#isTapped = true;
            console.log(`Creature: ${this.name} tapped.`);
            // Game should emit event AFTER calling this
        }
    }
    /** Explicitly untaps the creature */
    untap() {
        if (this.#isTapped) {
            this.#isTapped = false;
            console.log(`Creature: ${this.name} untapped.`);
            // Game should emit event AFTER calling this
        }
    }

    takeDamage(amount, source, game) {
        if (amount <= 0 || this.location !== 'battlefield') return;
        if (this.hasStatusEffect('shielded') || this.hasStatusEffect('prevent_damage')) {
            console.log(`Creature: ${this.name} damage prevented.`);
            if(this.hasStatusEffect('shielded')) this.removeStatusEffect('shielded'); // Shield is usually one-time
            game.emitEvent('damagePrevented', { target: this.getRenderData(), amount, source: source?.getRenderData() });
            return;
        }

        this.#currentToughness -= amount;
        console.log(`Creature: ${this.name} took ${amount} damage. Toughness: ${this.#currentToughness}/${this.toughness}`);
        // Emit individual update for toughness
        game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: { currentToughness: this.#currentToughness } });
        // Emit specific damage event
        game.emitEvent('creatureTookDamage', { creature: this.getRenderData(), amount, source: source?.getRenderData() });

        if (this.#currentToughness <= 0) {
            this.die(game);
        }
    }

    heal(amount, game) {
        if(amount <= 0 || this.location !== 'battlefield') return;
        const maxToughness = this.toughness; // Use calculated max toughness
        if (this.#currentToughness >= maxToughness) return; // Already full

        const actualHeal = Math.min(amount, maxToughness - this.#currentToughness);
        this.#currentToughness += actualHeal;
        console.log(`Creature: ${this.name} healed ${actualHeal}. Toughness: ${this.#currentToughness}/${maxToughness}`);
        game.emitEvent('creatureUpdate', { cardUniqueId: this.uniqueId, updates: { currentToughness: this.#currentToughness } });
        game.emitEvent('creatureHealed', { creature: this.getRenderData(), amount: actualHeal });
    }

    die(game) {
        if (this.location !== 'battlefield') return; // Already dead/gone
        console.log(`Creature: ${this.name} is dying.`);
        const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'battlefield', 'graveyard');
        if (moved) {
             this.onDeath(game); // Trigger death effects AFTER moving
        } else {
            console.error(`Creature: Failed to move ${this.name} to graveyard.`);
        }
    }

    endTurnCleanup(isOwnTurn) {
        if (isOwnTurn) {
            this.#summoningSickness = false; // Wears off after controller's turn ends
        }
        const changed = this.#tickDownEffects(); // Tick down effects
        // TODO: If changed is true, trigger a 'creatureUpdate' event from Game?
        // Game's endTurnCleanup loop should probably do this.
    }

    // --- Status Effects & Boosts ---
    applyStatusEffect(effectName, duration) { // duration -1 for permanent
        this.#statusEffects.set(effectName, duration);
        console.log(`Creature: ${this.name} gained '${effectName}' (${duration < 0 ? 'Permanent' : duration + ' ticks'})`);
        // Game should emit update
    }
    removeStatusEffect(effectName) {
        const existed = this.#statusEffects.delete(effectName);
        if (existed) console.log(`Creature: ${this.name} lost '${effectName}'.`);
        // Game should emit update
        return existed;
    }
    applyTemporaryBoost(boost, duration) {
        this.#tempBoosts.push({ boost: { ...boost }, duration });
        if (boost.toughness && boost.toughness > 0) this.#currentToughness += boost.toughness;
        console.log(`Creature: ${this.name} gained boost ${JSON.stringify(boost)} (${duration} ticks)`);
        // Game should emit update
    }

    #tickDownEffects() {
        let changed = false;
        // Boosts
        const previousMaxToughness = this.toughness;
        this.#tempBoosts = this.#tempBoosts.filter(b => {
            b.duration--;
            if (b.duration <= 0) { changed = true; return false; } // Remove expired
            return true;
        });
        // Adjust current toughness if max toughness decreased
        const newMaxToughness = this.toughness;
        if (newMaxToughness < previousMaxToughness) {
            this.#currentToughness = Math.min(this.#currentToughness, newMaxToughness);
        }

        // Status Effects
        for (const [effect, duration] of this.#statusEffects.entries()) {
            if (duration > 0) { // Only tick down timed effects
                 const newDuration = duration - 1;
                 if (newDuration <= 0) { this.#statusEffects.delete(effect); changed = true; }
                 else { this.#statusEffects.set(effect, newDuration); }
            }
        }
        // TODO: Need a way for Game to know 'changed' happened to emit update
        return changed;
    }

    // --- Triggered Abilities (Placeholders) ---
    onEnterBattlefield(game, player) {
        if (this.abilities.includes('ETB: Draw a card')) { player.drawCards(1, game); }
    }
    onDeath(game) {
         if (this.abilities.includes('Deathrattle: Deal 1 damage to opponent')) {
             const opp = game.getOpponent(this.ownerId);
             if(opp) opp.takeDamage(1, this, game);
         }
    }

    // --- Rendering ---
    getRenderData() {
        // Ensure all relevant calculated properties are included
        return {
            ...super.getRenderData(),
            baseAttack: this.baseAttack, baseToughness: this.baseToughness,
            attack: this.attack, toughness: this.toughness, // Calculated max toughness
            currentToughness: this.currentToughness,
            tribe: this.tribe, isTapped: this.isTapped, hasSummoningSickness: this.hasSummoningSickness,
            canAttack: this.canAttack(), canBlock: this.canBlock(),
            statusEffects: Object.fromEntries(this.#statusEffects)
        };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\CreatureCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Deck.js ---
// js/core/Deck.js
import Card from './Card.js'; // Default import
import CreatureCard from './CreatureCard.js'; // Default import
import { RunebindingCard } from './RunebindingCard.js'; // Named import
import { InstantCard } from './InstantCard.js'; // Named import
import { shuffleArray } from '../utils.js';

/**
 * Represents a player's deck of cards.
 */
export class Deck { // Using export class
    #cards = [];
    #ownerId;

    constructor(deckCardIds, cardDatabase, ownerId) {
        this.#cards = [];
        this.#ownerId = ownerId;
        if (!Array.isArray(deckCardIds) || !cardDatabase || !ownerId) throw new Error("Deck constructor requires deckCardIds, cardDatabase, and ownerId.");

        console.log(`Deck: Initializing for owner ${ownerId} with ${deckCardIds.length} IDs.`);
        deckCardIds.forEach(cardId => {
            const cardDefinition = cardDatabase[cardId];
            if (cardDefinition) {
                let cardInstance = null;
                try { // Add try-catch for safer instantiation
                    switch (cardDefinition.type) {
                        case 'Creature': cardInstance = new CreatureCard(cardDefinition, this.#ownerId); break;
                        case 'Runebinding': cardInstance = new RunebindingCard(cardDefinition, this.#ownerId); break;
                        case 'Instant': cardInstance = new InstantCard(cardDefinition, this.#ownerId); break;
                        default: console.warn(`Deck: Unknown type "${cardDefinition.type}" for ${cardId}. Using base Card.`); cardInstance = new Card(cardDefinition, this.#ownerId); break;
                    }
                    if (cardInstance) { cardInstance.location = 'deck'; this.#cards.push(cardInstance); }
                } catch (error) {
                     console.error(`Deck: Failed to instantiate card ${cardId} (${cardDefinition.name}):`, error);
                }
            } else { console.warn(`Deck: Card ID "${cardId}" not found in DB.`); }
        });
        console.log(`Deck: Created ${this.#cards.length} instances for ${ownerId}.`);
    }

    shuffle() { shuffleArray(this.#cards); console.log(`Deck (${this.#ownerId}): Shuffled.`); }
    draw() { if (this.isEmpty()) return null; return this.#cards.pop(); }
    addCard(cardInstance, toBottom = false) { if (!cardInstance?.uniqueId) return; cardInstance.location = 'deck'; if (toBottom) this.#cards.unshift(cardInstance); else this.#cards.push(cardInstance); }
    getSize() { return this.#cards.length; }
    isEmpty() { return this.#cards.length === 0; }
    clear() { this.#cards = []; }
    getCardsForDebug() { return [...this.#cards]; }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Deck.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Game.js ---
// js/core/Game.js
import Player from './Player.js';
import TurnManager from './TurnManager.js';
import CombatManager from './CombatManager.js';
// Import Card classes if needed for instanceof checks or specific game logic
import Card from './Card.js';
import CreatureCard from './CreatureCard.js';
import { RunebindingCard } from './RunebindingCard.js';
import { InstantCard } from './InstantCard.js';


export default class Game {
    #players = [];
    #currentPlayerIndex = -1;
    #turnManager;
    #combatManager;
    #state = 'setup'; // 'setup', 'starting', 'playing', 'discarding', 'game_over'
    #eventDispatcher;
    #cardDatabase;
    #pendingDiscard = null; // { playerId, count }

    constructor(cardDatabase) {
        if (!cardDatabase || Object.keys(cardDatabase).length === 0) { // Check if DB is valid
            throw new Error("Game requires a valid, non-empty cardDatabase.");
        }
        this.#players = [];
        this.#turnManager = new TurnManager();
        this.#combatManager = new CombatManager(this);
        this.#state = 'setup';
        this.#eventDispatcher = new EventTarget();
        this.#cardDatabase = cardDatabase;
        console.log("Game: Instance created with CombatManager.");
    }

    // --- Player Management (Added validation in addPlayer) ---

    /**
     * Adds a player to the game. Validates deck IDs.
     * @param {string} name Nome do jogador.
     * @param {string[]} deckCardIds Array de IDs das cartas no deck.
     * @returns {Player | null} The Player instance or null if adding failed.
     */
    addPlayer(name, deckCardIds) {
        if (this.#players.length >= 2) {
            console.error("Game Error: Cannot add more than 2 players.");
            return null;
        }
        if (!this.#cardDatabase) { // Should have been caught in constructor, but safety check
             console.error("Game Error: CardDatabase missing.");
             return null;
        }
        // --- FIX: Validate deckCardIds ---
        if (!Array.isArray(deckCardIds) || deckCardIds.length < 30 || deckCardIds.length > 40) {
             console.error(`Game Error: Invalid deckCardIds for player ${name}. Length: ${deckCardIds?.length}. Must be array [30-40].`);
             this.emitEvent('gameLog', { message: `Erro: Deck inválido para ${name}.` }); // Inform UI potentially
             return null; // Return null if deck IDs are invalid
        }
        // --- End Fix ---

        try {
            // Player constructor might throw if Deck fails (e.g., card ID not in DB)
            const player = new Player(name, deckCardIds, this.#cardDatabase);
            this.#players.push(player);
            console.log(`Game: Player ${name} (ID: ${player.id}) added with deck size ${deckCardIds.length}.`);
            return player;
        } catch (error) {
             console.error(`Game Error: Error creating Player '${name}':`, error);
             // Optionally emit a more specific error event
             return null; // Return null if Player/Deck constructor fails
        }
    }

    getPlayer(playerId) { return this.#players.find(p => p.id === playerId); }
    getOpponent(playerId) { return this.#players.find(p => p.id !== playerId); }
    getCurrentPlayer() { return this.#players[this.#currentPlayerIndex]; }
    /** Finds a card instance by its unique ID across all players and zones */
    findCardInstance(cardUniqueId) { /* ... (previous code) ... */ }
    /** Getter for Combat Manager */
    getCombatManager() { return this.#combatManager; } // <<< Added Getter


    // --- Game Flow ---
    setupGame() {
        if (this.#players.length !== 2) { console.error("Game: Need 2 players to setup."); return false; }
        this.#state = 'starting'; console.log("Game: Setting up...");
        this.#players.forEach(player => { player.resetStats(); player.shuffleDeck(); });
        this.#currentPlayerIndex = Math.floor(Math.random() * 2);
        console.log(`Game: ${this.getCurrentPlayer()?.name} will start.`);
        return true;
    }
    startGame() {
        if (this.#state !== 'starting') { console.error("Game: Not ready to start."); return; }
        if (!this.getCurrentPlayer()) { console.error("Game: Starting player not set."); return; }
        console.log("Game: Starting match!"); this.#state = 'playing';
        const initialHandSize = 5;
        this.#players.forEach(player => { for (let i = 0; i < initialHandSize; i++) this._drawCard(player); });
        this._startTurn(this.getCurrentPlayer()); // Start the first turn
        this.emitEvent('gameStarted', { startingPlayerId: this.getCurrentPlayer().id });
    }

    passPhase() {
        if (!['playing', 'discarding'].includes(this.#state)) { console.warn(`Game: Can't pass phase in state ${this.#state}`); return; }
        // Allow passing phase even if discarding to let the turn proceed if player is stuck? Or force discard first?
        // Let's assume discard must be resolved first.
        if (this.#state === 'discarding') {
             this.emitEvent('gameLog', { message: `Você precisa descartar ${this.#pendingDiscard.count} carta(s) primeiro.` });
             return;
        }

        const player = this.getCurrentPlayer(); if (!player) return;
        const oldPhase = this.getCurrentPhase();

        // Resolve combat if passing priority during specific combat substates
        if (oldPhase === 'attack') {
            if (this.#combatManager.state === 'declare_blockers') {
                 console.log("Game: Defending player passed blocker declaration. Resolving combat.");
                 this.#combatManager.resolveCombat(); // Resolve with no blockers
            } else if (this.#combatManager.state === 'declare_attackers') {
                 console.log("Game: Attacking player passed after declaring. Waiting for blockers.");
                 // Don't resolve yet, just let phase logic proceed (which should be handled by UI/opponent action)
            }
        }

        const { newPhase, turnEnded } = this.#turnManager.nextPhase();
        this.emitEvent('phaseChange', { playerId: player.id, oldPhase: oldPhase, newPhase: newPhase });
        if (turnEnded) { this.nextTurn(); }
        else { this._onPhaseEnter(newPhase, player); }
    }

    _onPhaseEnter(phase, player) {
        console.log(`Game: Entering ${phase} phase for ${player.name}.`);
        // Only reset combat state at the VERY START of the attack phase
        if (phase === 'attack') { this.#combatManager.reset(); this.emitEvent('attackPhaseStart', { playerId: player.id }); }
        else if (phase === 'end') { player.endTurnCleanup(this); } // Cleanup & Hand size check happens here
        else if (phase === 'draw') { this._drawCard(player); }
        // Set state to 'playing' unless a specific state like 'discarding' was triggered
        if (this.#state !== 'discarding') this.#state = 'playing';
    }

    endTurn() {
        if (this.#state !== 'playing') { console.warn(`Game: Can't end turn in state ${this.#state}`); return; }
        const player = this.getCurrentPlayer(); if (!player) return;
        console.log(`Game: ${player.name} ending turn from phase ${this.getCurrentPhase()}.`);
        let safety = 0;
        while(this.#state === 'playing' && safety < 10) { // Only loop if playing
             const currentPhase = this.getCurrentPhase();
             // If in attack phase, ensure combat resolves before proceeding fully
             if (currentPhase === 'attack' && this.#combatManager.state !== 'none') {
                 if (this.#combatManager.state === 'declare_blockers') { this.#combatManager.resolveCombat(); } // Assume no blocks if ending turn here
                 else if (this.#combatManager.state === 'resolving') { /* let it finish if already resolving */ }
                 else { this.#combatManager.reset(); } // Reset if only attackers declared
             }

             const { newPhase, turnEnded } = this.#turnManager.nextPhase();
             this.emitEvent('phaseChange', { playerId: player.id, oldPhase: currentPhase, newPhase: newPhase });
             if (newPhase === 'end') { player.endTurnCleanup(this); if(this.#state === 'discarding') break; } // Stop loop if discard starts
             if (turnEnded) { this.nextTurn(); break; }
             safety++;
        }
         if(safety >= 10) console.error("Game: Potential infinite loop in endTurn!");
         // If loop ended due to 'discarding' state, don't proceed to next turn yet
         if (this.#state === 'discarding') { console.log("Game: Turn end paused for discarding."); }
    }

    nextTurn() {
        if (!['playing', 'discarding'].includes(this.#state)) { console.warn("Game: Cannot start next turn in state", this.#state); return; }
        this.#combatManager.reset(); // Ensure combat is reset
        const previousPlayer = this.getCurrentPlayer();
        this.#currentPlayerIndex = (this.#currentPlayerIndex + 1) % this.#players.length;
        const newPlayer = this.getCurrentPlayer();
        console.log(`Game: Starting Turn ${this.#turnManager.turnNumber + 1} for ${newPlayer.name}.`);
        this.emitEvent('turnChange', { previousPlayerId: previousPlayer?.id, currentPlayerId: newPlayer.id, playerName: newPlayer.name, turnNumber: this.#turnManager.turnNumber + 1 });
        this._startTurn(newPlayer); // Sets state back to playing
    }

    _startTurn(player) {
        if (!player) return;
        this.#state = 'playing'; this.#pendingDiscard = null; // Reset state/discard
        const startingPhase = this.#turnManager.startNewTurn();
        player.prepareForTurn();
        this.emitEvent('playerStatsChanged', { playerId: player.id, updates: { mana: player.mana, maxMana: player.maxMana } });
        player.battlefield.getAllCards().forEach(c => { // Emit untap events
            if (c.type === 'Creature' && !c.isTapped) this.emitEvent('creatureUpdate', { cardUniqueId: c.uniqueId, updates: { isTapped: false } });
        });
        console.log(`Game: Turn ${this.#turnManager.turnNumber} started for ${player.name}.`);
        this._onPhaseEnter(startingPhase, player);
    }

    _drawCard(player) { if(!player||this.#state!=='playing')return null; const c=player.drawCard(); if(c){this.emitEvent('cardDrawn',{playerId:player.id,card:c.getRenderData()});return c;}else{console.log(`Game:${player.name} deck empty!`);this.emitEvent('deckEmpty',{playerId:player.id});this.gameOver(this.getOpponent(player.id));return null;} }
    moveCardToZone(cardUniqueId, playerId, fromZone, toZone) { const p=this.getPlayer(playerId); if(!p){console.error(`Game:P${playerId} not found`);return false;} const c=p.moveCardBetweenZones(cardUniqueId,fromZone,toZone); if(c){this.emitEvent('cardMoved',{cardUniqueId,cardData:c.getRenderData(),fromZone,toZone,ownerId:playerId}); return true;} return false; }
    requestPlayerDiscard(playerId, count) { if(this.#state==='playing'){this.#state='discarding'; this.#pendingDiscard={playerId,count}; console.log(`Game: State->discarding for ${playerId}, count ${count}`); this.emitEvent('discardRequired',{playerId,count}); this.emitEvent('gameLog',{message:`${this.getPlayer(playerId)?.name} precisa descartar ${count} carta(s).`});} }
    resolvePlayerDiscard(playerId, cardUniqueId) { if(this.#state!=='discarding'||!this.#pendingDiscard||this.#pendingDiscard.playerId!==playerId){console.warn(`Game: Invalid resolve discard`);return false;} const p=this.getPlayer(playerId); const c=p?.hand.getCard(cardUniqueId); if(!c){console.warn(`Game: Card ${cardUniqueId} not in hand`);return false;} const m=this.moveCardToZone(cardUniqueId,playerId,'hand','graveyard'); if(m){this.#pendingDiscard.count--; this.emitEvent('gameLog',{message:`${p.name} descartou ${c.name}.`}); if(this.#pendingDiscard.count<=0){console.log(`Game: Discard req met for ${playerId}.`); this.#pendingDiscard=null; this.#state='playing'; this.nextTurn();} else {this.emitEvent('discardRequired',{playerId,count:this.#pendingDiscard.count});}} return m; }

    // --- Combat Actions ---
    confirmAttackDeclaration(playerId, attackerIds) {
        const p=this.getPlayer(playerId); if(!p||this.#state!=='playing'||this.getCurrentPhase()!=='attack'||this.getCurrentPlayer()?.id!==playerId){this.emitEvent('gameLog',{message:"Não pode declarar ataque agora."}); return;}
        const success = this.#combatManager.declareAttackers(p, attackerIds);
        if(this.#combatManager.state==='declare_blockers'){this.emitEvent('gameLog',{message:`${this.getOpponent(playerId)?.name}, declare bloqueadores.`});}
        // State implicitly changes via CombatManager events
    }
    confirmBlockDeclaration(playerId, rawAssignments) {
        const p=this.getPlayer(playerId), ap=this.getCurrentPlayer();
        if(!p||this.#combatManager.state!=='declare_blockers'||this.getCurrentPhase()!=='attack'||ap?.id===playerId){this.emitEvent('gameLog',{message:"Não pode declarar bloqueadores agora."}); return;}
        const assignmentsMap = new Map(Object.entries(rawAssignments));
        const success = this.#combatManager.declareBlockers(p, assignmentsMap); // This now resolves and resets combat state
        this.#state = 'playing'; // Return game state to normal playing after combat resolves
        this.emitEvent('gameLog',{message:`Bloqueadores declarados. Resolvendo...`});
        // combatResolved event signals end
    }

    // --- Game Over / Events ---
    gameOver(winner) { if(this.#state==='game_over')return; this.#state='game_over'; const l=this.getOpponent(winner?.id); console.log(`Game Over! Winner:${winner?.name||'N/A'}`); this.emitEvent('gameOver',{winnerId:winner?.id,winnerName:winner?.name,loserId:l?.id,loserName:l?.name}); }
    get state() { return this.#state; }
    getCurrentPhase() { return this.#turnManager.currentPhase; }
    addEventListener(eventName, callback) { this.#eventDispatcher.addEventListener(eventName, callback); }
    removeEventListener(eventName, callback) { this.#eventDispatcher.removeEventListener(eventName, callback); }
    emitEvent(eventName, detail) { console.log(`Game Event: ${eventName}`, detail); this.#eventDispatcher.dispatchEvent(new CustomEvent(eventName, { detail })); }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Game.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Graveyard.js ---
// js/core/Graveyard.js
/**
 * Represents the player's graveyard (discard pile).
 * Stores cards in an array, maintaining order might be relevant.
 */
export class Graveyard { // Using export class
    #cards = []; // Array<Card> - Order might matter

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        // Optional: Check if already in graveyard? Unlikely needed.
        this.#cards.push(cardInstance);
        return true;
    }

    // Remove is less common, but could be needed for "return from graveyard" effects
    removeCard(cardUniqueId) {
        const index = this.#cards.findIndex(card => card.uniqueId === cardUniqueId);
        if (index !== -1) {
            const [removedCard] = this.#cards.splice(index, 1);
            return removedCard;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.find(card => card.uniqueId === cardUniqueId) || null;
    }

    getCards() {
        return [...this.#cards]; // Return copy
    }

    getSize() {
        return this.#cards.length;
    }

    clear() {
        this.#cards = [];
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Graveyard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Hand.js ---
// js/core/Hand.js
/**
 * Represents the player's hand of cards.
 */
export class Hand { // Using export class
    #cards = new Map(); // Map<string, Card> (uniqueId -> CardInstance)
    #maxSize = 7; // As per GDD End Phase rule

    constructor(maxSize = 7) {
        this.#cards = new Map();
        this.#maxSize = maxSize;
    }

    addCard(cardInstance) {
        if (!cardInstance?.uniqueId) return false;
        if (this.#cards.has(cardInstance.uniqueId)) return false; // Avoid duplicates
        this.#cards.set(cardInstance.uniqueId, cardInstance);
        return true;
    }

    removeCard(cardUniqueId) {
        const card = this.#cards.get(cardUniqueId);
        if (card) {
            this.#cards.delete(cardUniqueId);
            return card;
        }
        return null;
    }

    getCard(cardUniqueId) {
        return this.#cards.get(cardUniqueId) || null;
    }

    getCards() {
        return [...this.#cards.values()];
    }

    getSize() {
        return this.#cards.size;
    }

    getMaxSize() {
        return this.#maxSize;
    }

    isOverLimit() {
        return this.getSize() > this.#maxSize;
    }

    clear() {
        this.#cards.clear();
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Hand.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\InstantCard.js ---
// js/core/InstantCard.js

import Card from './Card.js';

/**
 * Represents an Instant Spell card, which has an immediate effect
 * and then typically goes to the graveyard.
 */
export class InstantCard extends Card {
    #effectText;
    #targetType;

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId); // Call base class constructor

        if (cardDefinition.type !== 'Instant') {
            throw new Error(`Card definition "${cardDefinition.name}" is not of type Instant.`);
        }

        this.#effectText = cardDefinition.effect || 'No effect description.';
        // Determine target type (similar logic as Runebinding)
        this.#targetType = this.#determineTargetType(cardDefinition.effect);

        // Instants don't usually have duration
    }

    // --- Getters ---
    get effectText() { return this.#effectText; }
    get targetType() { return this.#targetType; }

    // --- Card Specific Methods ---

     /** Basic heuristic for target type */
    #determineTargetType(effectText = "") {
        const text = effectText.toLowerCase();
        if (text.includes('target creature')) return 'creature';
        if (text.includes('target player')) return 'player';
        if (text.includes('target runebinding')) return 'runebinding';
        if (text.includes('draw') && !text.includes('target')) return 'player_self';
        if (text.includes('restore') && !text.includes('target')) return 'player_self'; // Heal self
        // Add more rules
        return 'none'; // No target needed
    }

    /** Checks if this card requires a target. */
    requiresTarget() {
        return this.#targetType !== 'none' && this.#targetType !== 'player_self';
    }

    /**
     * Overrides base canPlay for Instants.
     * Instants might be playable during more phases (e.g., opponent's turn, attack phase).
     * This depends heavily on your game rules - adjust accordingly!
     * @param {Player} player
     * @param {Game} game
     * @returns {boolean}
     */
    canPlay(player, game) {
        // Base checks (mana, hand)
        if (!super.canPlay(player, game)) return false;

        // --- Timing Restrictions (EXAMPLE - NEEDS YOUR RULES) ---
        const currentPhase = game.getCurrentPhase();
        const isActivePlayer = game.getCurrentPlayer()?.id === player.id;

        // Simple rule: Allow anytime if it's your turn, or during opponent's attack phase?
        // if (isActivePlayer) return true; // Allow anytime on your turn
        // if (!isActivePlayer && currentPhase === 'attack') return true; // Allow during opponent's attack

        // More restrictive rule (like Sorcery speed): Only on your main phase
        if (!isActivePlayer || currentPhase !== 'main') {
             console.log(`Instant ${this.name}: Cannot play during phase ${currentPhase}.`);
             // return false; // Uncomment for Sorcery speed
        }
         // For now, let's allow on player's main phase only for simplicity
         if (!isActivePlayer || currentPhase !== 'main') return false;


        // TODO: Check if target is required and available (similar to Runebinding)
        // if (this.requiresTarget() && !game.hasValidTargets(this.#targetType, player)) return false;

        return true;
    }

    /**
     * Overrides base play method for Instants.
     * Resolves the effect and moves the card to the graveyard.
     * @param {Player} player
     * @param {Game} game
     * @param {string | null} targetId - The uniqueId of the target or null.
     */
    play(player, game, targetId = null) {
        if (!super.play(player, game, targetId)) { // Handles cost, base checks
            return false;
        }

        console.log(`Instant: ${player.name} playing ${this.name} ${targetId ? `on target ${targetId}` : ''}`);

        // Resolve the effect immediately
        const success = this.resolveEffect(targetId, game, player);

        // Regardless of success (usually), move Instant to graveyard after resolving/attempting
        console.log(`Instant: ${this.name} moving to graveyard.`);
        game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'graveyard');

        // If effect failed, maybe log it, but card is usually still spent
        if (!success) {
            console.warn(`Instant: Effect of ${this.name} may have failed to resolve fully.`);
            // Don't refund mana here, it was spent on the attempt
        }

        return success; // Return success status of the *effect*
    }

    /**
     * Executes the instant spell's effect.
     * Needs specific logic for each Instant card.
     * @param {string | null} targetId
     * @param {Game} game
     * @param {Player} castingPlayer
     * @returns {boolean} True if the effect resolved successfully.
     */
    resolveEffect(targetId, game, castingPlayer) {
        console.log(`Instant: Resolving effect of ${this.name} (Target: ${targetId || 'N/A'})`);

        // --- !!! Requires specific logic for EACH Instant card !!! ---
        try {
            let target = null;
            if (targetId) {
                target = game.getPlayer(targetId) || game.findCardInstance(targetId);
                if (!target) {
                     console.warn(`Instant ResolveEffect: Target ${targetId} not found.`);
                     return false; // Target disappeared
                }
            }

            // Example effects based on provided JSON
            switch (this.id) {
                case 'IS001': // Heal
                    castingPlayer.gainLife(4, game); // Assumes Player has gainLife(amount, game)
                    break;
                case 'IS002': // Fireball
                     if (target && target.type === 'Creature') { // Or target instanceof CreatureCard
                         target.takeDamage(3, this, game); // Assumes CreatureCard has takeDamage(amount, source, game)
                     } else return false; // Invalid target
                     break;
                case 'IS003': // Draw (Assuming ID, effect "Draw 2 cards")
                     castingPlayer.drawCards(2, game);
                     break;
                 case 'IS004': // Shield
                     if (target && target.type === 'Creature') {
                         // TODO: Implement damage prevention effect
                         target.applyStatusEffect('shielded', 1); // Prevent damage for 1 tick (this turn)
                         console.log(`${target.name} is shielded from damage this turn.`);
                     } else return false;
                     break;
                 case 'IS005': // Bounce
                      if (target && target.type === 'Creature') {
                           const owner = game.getPlayer(target.ownerId); // Find the owner
                           if (owner) {
                                game.moveCardToZone(target.uniqueId, target.ownerId, 'battlefield', 'hand');
                                console.log(`${target.name} returned to ${owner.name}'s hand.`);
                           } else return false; // Owner not found?
                      } else return false;
                      break;
                 case 'IS006': // Destroy Binding
                      if (target && target.type === 'Runebinding') { // Check if target is a Runebinding instance
                           // How to destroy? If it's on battlefield, move to graveyard
                           if (target.location === 'battlefield') {
                               target.removeEffect(game); // Let the Runebinding clean itself up
                           } else {
                               // If it's somehow targeted elsewhere? Maybe just log error.
                               console.warn(`Cannot destroy Runebinding ${target.name} not on battlefield.`);
                               return false;
                           }
                      } else return false;
                      break;
                 case 'IS007': // Weaken
                      if (target && target.type === 'Creature') {
                          target.applyTemporaryBoost({ attack: -2 }, 1); // Apply negative boost
                          console.log(`${target.name} gets -2 attack this turn.`);
                      } else return false;
                      break;

                // Add cases for all other Instant cards...

                default:
                    console.warn(`Instant ResolveEffect: No specific effect logic for ${this.name} (ID: ${this.id})`);
                    break;
            }
            return true;
        } catch (error) {
            console.error(`Instant ResolveEffect: Error resolving effect for ${this.name}:`, error);
            return false;
        }
    }

    // Override getRenderData if needed
     getRenderData() {
        return {
            ...super.getRenderData(),
            effectText: this.effectText,
            // Instants usually don't have much other state to show
        };
    }
}

// Ensure Player.js has: gainLife(amount, game), drawCards(count, game)
// Ensure CreatureCard.js has: takeDamage(amount, source, game), applyStatusEffect(name, duration), applyTemporaryBoost(boost, duration)
// Ensure RunebindingCard.js has: removeEffect(game)
// Ensure Game.js has: findCardInstance(uniqueId)
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\InstantCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Player.js ---
// js/core/Player.js
import { Deck } from './Deck.js'; // Named import
import { Hand } from './Hand.js'; // Named import
import { Battlefield } from './Battlefield.js'; // Named import
import { Graveyard } from './Graveyard.js'; // Named import
import { generateUniqueId } from '../utils.js'; // Named import
// Card base/subclasses might be needed for instanceof checks later
import Card from './Card.js';
import CreatureCard from './CreatureCard.js';
import { RunebindingCard } from './RunebindingCard.js';
import { InstantCard } from './InstantCard.js';


export default class Player { // Using export default
    #id;
    #name;
    #life = 20;
    #mana = 0;
    #maxMana = 0;
    #deck;
    #hand;
    #battlefield;
    #graveyard;
    #hasDiscardedForMana = false;
    isActivePlayer = false; // Track if it's currently this player's turn (managed by Game)

    constructor(name, deckCardIds, cardDatabase) {
        this.#id = generateUniqueId('player');
        this.#name = name;
        // Instantiate zones with error handling
        try { this.#deck = new Deck(deckCardIds, cardDatabase, this.#id); } catch (e) { throw new Error(`Player ${name} deck init failed: ${e.message}`); }
        this.#hand = new Hand();
        this.#battlefield = new Battlefield();
        this.#graveyard = new Graveyard();
        this.resetStats();
        console.log(`Player: ${this.#name} (ID: ${this.#id}) created.`);
    }

    // --- Getters ---
    get id() { return this.#id; }
    get name() { return this.#name; }
    get life() { return this.#life; }
    get mana() { return this.#mana; }
    get maxMana() { return this.#maxMana; }
    get deck() { return this.#deck; }
    get hand() { return this.#hand; }
    get battlefield() { return this.#battlefield; }
    get graveyard() { return this.#graveyard; }
    get hasDiscardedForMana() { return this.#hasDiscardedForMana; }


    // --- Methods Called by Game ---
    shuffleDeck() { this.#deck.shuffle(); }
    drawCard() { const c = this.#deck.draw(); if(c) { this.#hand.addCard(c); } return c; }
    drawCards(count, game) { let d=[]; for(let i=0;i<count;i++){const c=game?._drawCard(this); if(c)d.push(c); else break;} return d; } // Game handles events
    prepareForTurn() { this.isActivePlayer = true; this.#mana = this.#maxMana; this.#battlefield.untapAll(); this.#hasDiscardedForMana = false; console.log(`Player ${this.#name}: Prepared. Mana: ${this.#mana}/${this.#maxMana}.`); }
    endTurnCleanup(game) { this.isActivePlayer = false; this.#battlefield.getAllCards().forEach(c => { if (typeof c.tickDown === 'function') c.tickDown(game); if (typeof c.endTurnCleanup === 'function') c.endTurnCleanup(true); }); console.log(`Player ${this.#name}: End cleanup.`); this.checkHandSize(game); }
    moveCardBetweenZones(cardUniqueId, fromZone, toZone) { let c=null, o=this.#getZoneObject(fromZone), d=this.#getZoneObject(toZone); if(!o||!d) return null; c=o.removeCard(cardUniqueId); if(c){d.addCard(c); c.location=toZone; return c;} return null; }
    #getZoneObject(zoneName) { switch(zoneName?.toLowerCase()){ case 'deck': return this.#deck; case 'hand': return this.#hand; case 'battlefield': return this.#battlefield; case 'graveyard': return this.#graveyard; default: console.error(`Player ${this.#name}: Invalid zone: ${zoneName}`); return null; } }

    // --- Player Actions ---
    playCard(cardUniqueId, targetId = null, game) {
        if (!game) { console.error("Player.playCard needs game!"); return false; }
        const card = this.#hand.getCard(cardUniqueId);
        if (!card) { console.warn(`${this.name}: Card ${cardUniqueId} not in hand.`); return false; }

        // Use the card's specific canPlay method
        if (!card.canPlay(this, game)) {
             console.log(`Player ${this.name}: Cannot play ${card.name} now.`);
             game.emitEvent('gameLog', { message: `Não pode jogar ${card.name} agora.` });
             return false;
        }
        // TODO: Validate targetId if provided, BEFORE spending mana
        // if(targetId && card.requiresTarget() && !game.isValidTarget(targetId, card.targetType(), this)) {
        //      game.emitEvent('gameLog', { message: `Alvo inválido para ${card.name}.` });
        //      return false;
        // }


        // Spend Mana FIRST
        if (!this.spendMana(card.cost)) { console.error(`${this.name}: Mana spend failed?`); return false; } // Should not fail if canPlay passed
        game.emitEvent('playerStatsChanged', { playerId: this.id, updates: { mana: this.mana }}); // Notify UI mana changed


        // --- Let the CARD instance handle its play logic ---
        // The card's play method should call game.moveCardToZone and apply effects
        const playSuccess = card.play(this, game, targetId);

        if (!playSuccess) {
            // If card.play itself failed AFTER mana was spent (e.g., target invalid at resolution)
            console.warn(`Player ${this.name}: Card ${card.name}'s play method reported failure.`);
            // Card should have moved itself to graveyard in its play() method on failure.
        } else {
             // Emit base cardPlayed event from Player/Game AFTER card.play tries to resolve
             // Card.play can emit more specific events (e.g., 'creatureEntered', 'spellResolved')
             game.emitEvent('cardPlayed', { player: this.getRenderData(), card: card.getRenderData(), targetId });
        }

        return playSuccess;
    }

    discardCardForMana(cardUniqueId, game) {
        if (!game) { console.error("Player.discardCardForMana needs game!"); return false; }
        if (this.#hasDiscardedForMana) { game.emitEvent('gameLog', { message: `Já descartou por mana.` }); return false; }
        if (this.#maxMana >= 10) { game.emitEvent('gameLog', { message: `Mana máxima (10) atingida.` }); return false; }
        const card = this.#hand.getCard(cardUniqueId); if(!card) return false; // Get name before move
        const moved = game.moveCardToZone(cardUniqueId, this.id, 'hand', 'graveyard'); // Game handles event
        if (moved) { this.#maxMana++; this.#mana++; this.#hasDiscardedForMana = true; game.emitEvent('playerStatsChanged', { playerId: this.id, updates: { mana: this.mana, maxMana: this.maxMana }}); console.log(`${this.name} discarded ${card.name}. Mana: ${this.#mana}/${this.#maxMana}.`); return true; }
        return false;
    }
    checkHandSize(game) { // Called during end phase cleanup
        const excess = this.#hand.getSize() - this.#hand.getMaxSize();
        if (excess > 0) {
             console.log(`Player ${this.name}: Must discard ${excess} cards.`);
             game.requestPlayerDiscard(this.id, excess); // Game changes state and emits event
        }
    }

    spendMana(amount) { if(amount<0)return false; if(amount<=this.#mana){this.#mana-=amount; return true;} return false; }
    gainLife(amount, game) { if(amount<=0)return; this.#life+=amount; game?.emitEvent('playerStatsChanged', { playerId: this.id, updates: { life: this.#life }}); game?.emitEvent('gameLog', { message: `${this.name} ganhou ${amount} vida.` }); }
    takeDamage(amount, source, game) { if(amount<=0)return; this.#life-=amount; game?.emitEvent('playerStatsChanged', { playerId: this.id, updates: { life: this.#life }}); game?.emitEvent('gameLog', { message: `${this.name} levou ${amount} dano.` }); if(this.#life<=0){ game?.gameOver(game.getOpponent(this.id)); } }
    resetStats() { this.#life=20; this.#mana=0; this.#maxMana=0; this.#hasDiscardedForMana=false; this.isActivePlayer=false; }

    // --- Combat Related Helpers ---
    canDeclareAttackers() { return this.battlefield.getCreatures().some(c => c.canAttack()); }
    canDeclareBlockers(attacker) { return this.battlefield.getCreatures().some(c => c.canBlock()); } // Basic check

     // --- Rendering Helper ---
     getRenderData() {
        // Provides a safe snapshot for UI/Events, excluding sensitive info or complex objects
        return {
            id: this.id,
            name: this.name,
            life: this.life,
            mana: this.mana,
            maxMana: this.maxMana,
            handSize: this.hand.getSize(),
            deckSize: this.deck.getSize(),
            graveyardSize: this.graveyard.getSize()
        };
     }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\Player.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\RunebindingCard.js ---
// js/core/RunebindingCard.js
import Card from './Card.js'; // Correct: Card uses export default

/**
 * Represents a Runebinding card, which can be an enchantment
 * (permanent or temporary) applied to targets or the field.
 */
export class RunebindingCard extends Card { // Using export class
    #effectText;
    #targetType;
    #isTemporary;
    #durationCounters;
    #appliedTo = null; // uniqueId of target or 'field'/'player'

    constructor(cardDefinition, ownerId) {
        super(cardDefinition, ownerId);
        if (cardDefinition.type !== 'Runebinding') throw new Error(`Definition "${cardDefinition.name}" is not type Runebinding.`);
        this.#effectText = cardDefinition.effect || 'No effect description.';
        this.#targetType = this.#determineTargetType(cardDefinition.effect);
        this.#isTemporary = cardDefinition.isTemporary || this.#effectText.toLowerCase().includes('this turn') || this.#effectText.toLowerCase().includes('next turn');
        this.#durationCounters = this.#isTemporary ? (cardDefinition.duration || 1) : -1;
    }

    // --- Getters ---
    get effectText() { return this.#effectText; }
    get targetType() { return this.#targetType; }
    get isTemporary() { return this.#isTemporary; }
    get durationCounters() { return this.#durationCounters; }
    get appliedTo() { return this.#appliedTo; }

    // --- Card Specific Methods ---
    #determineTargetType(effectText = "") {
        const text = effectText.toLowerCase();
        if (text.includes('target creature')) return 'creature';
        if (text.includes('target player')) return 'player';
        if (text.includes('draw 2 cards')) return 'player_self'; // Specific case for RB_DRAW2
        if (text.includes('destroy target runebinding')) return 'runebinding';
        // Add more rules
        return 'field'; // Default
    }
    requiresTarget() { return this.#targetType !== 'field' && this.#targetType !== 'player_self'; }

    canPlay(player, game) {
        if (!super.canPlay(player, game)) return false;
        if (game.getCurrentPhase() !== 'main') return false; // Usually main phase
        // TODO: Check if valid target exists (requires Game method)
        // if (this.requiresTarget() && !game.hasValidTargets(this.#targetType, player)) return false;
        return true;
    }

    play(player, game, targetId = null) {
        // Called after Player verifies canPlay and spends mana
        console.log(`Runebinding: ${player.name} playing ${this.name} ${targetId ? `on target ${targetId}` : ''}`);
        const success = this.applyEffect(targetId, game, player);

        if (success) {
            // Determine where it goes (battlefield or graveyard)
            const goesToGraveyard = this.#isTemporary && this.#durationCounters <= 0;
            const destination = goesToGraveyard ? 'graveyard' : 'battlefield';
            const moved = game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', destination);

            if (moved && destination === 'battlefield') {
                // Track attachment if it went to field
                if (this.#targetType === 'creature' || this.#targetType === 'player') this.#appliedTo = targetId;
                else if (this.#targetType === 'field') this.#appliedTo = 'field';
                console.log(`Runebinding: ${this.name} now on ${destination} ${this.#appliedTo ? `(applied to ${this.#appliedTo})` : ''}.`);
                // TODO: If attached to creature, update creature state/visuals
            } else if (moved && destination === 'graveyard'){
                console.log(`Runebinding: ${this.name} went directly to graveyard.`);
            } else if (!moved) {
                 console.error(`Runebinding: Failed to move ${this.name} from hand to ${destination}.`);
                 return false; // Movement failed, major issue
            }
        } else {
            // Effect failed (e.g., target invalid), move to graveyard
            console.log(`Runebinding: Effect failed for ${this.name}, moving to graveyard.`);
            game.moveCardToZone(this.uniqueId, this.ownerId, 'hand', 'graveyard');
        }
        return success; // Return success of the effect application
    }

    applyEffect(targetId, game, castingPlayer) {
        console.log(`Runebinding: Applying effect of ${this.name}`);
        try {
            let target = null;
            if (targetId) {
                target = game.getPlayer(targetId) || game.findCardInstance(targetId);
                if (!target) { console.warn(`ApplyEffect: Target ${targetId} not found.`); return false; }
            }

            switch (this.id) {
                case 'RB001': // Destroy
                    if (target && target instanceof CreatureCard) { target.die(game); this.#durationCounters = 0; } else return false; break;
                case 'RB_DRAW2': // Draw Rune
                    castingPlayer.drawCards(2, game); this.#durationCounters = 0; break;
                case 'RB_SILENCE': // Silence
                    if (target && target instanceof CreatureCard) { target.applyStatusEffect('cant_attack', 2); console.log(`${target.name} silenced.`); } else return false; break; // Duration 2 ticks (opponent's turn + your next)
                case 'RB_POWER': // Power Boost
                    if (target && target instanceof CreatureCard) { target.applyTemporaryBoost({ attack: 2 }, 1); console.log(`${target.name} +2 Atk.`); } else return false; break;
                case 'RB_TOUGH': // Toughness Boost
                    if (target && target instanceof CreatureCard) { target.applyTemporaryBoost({ toughness: 2 }, 1); console.log(`${target.name} +2 Tough.`); } else return false; break;
                default: console.warn(`ApplyEffect: No logic for Runebinding ${this.name}`); break;
            }
            return true;
        } catch (error) { console.error(`ApplyEffect Error for ${this.name}:`, error); return false; }
    }

    removeEffect(game) {
        console.log(`Runebinding: Removing effect of ${this.name}`);
        // TODO: Revert specific effects based on this.id if needed
        // e.g., if it was a static +1/+1 aura, find target and remove boost

        // If the card is still marked as on the battlefield, move it to graveyard
        if (this.location === 'battlefield') {
            game.moveCardToZone(this.uniqueId, this.ownerId, 'battlefield', 'graveyard');
        }
        this.#appliedTo = null;
    }

    tickDown(game) {
        if (!this.#isTemporary || this.#durationCounters <= 0) return false;
        this.#durationCounters--;
        console.log(`Runebinding: ${this.name} ticks left: ${this.#durationCounters}`);
        if (this.#durationCounters <= 0) {
            this.removeEffect(game);
            return true; // Expired
        }
        return false; // Still active
    }

    getRenderData() {
        return { ...super.getRenderData(), effectText: this.effectText, isTemporary: this.isTemporary, duration: this.durationCounters, appliedTo: this.appliedTo };
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\RunebindingCard.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\TurnManager.js ---
// js/core/TurnManager.js
const TURN_PHASES = ['mana', 'draw', 'main', 'attack', 'end'];

export default class TurnManager { // Using export default
    #currentPhaseIndex = 0;
    #turnNumber = 0;

    constructor() { this.#currentPhaseIndex = 0; this.#turnNumber = 0; }
    get currentPhase() { return TURN_PHASES[this.#currentPhaseIndex]; }
    get turnNumber() { return this.#turnNumber; }

    nextPhase() {
        this.#currentPhaseIndex++;
        if (this.#currentPhaseIndex >= TURN_PHASES.length) {
            this.#currentPhaseIndex = 0;
            return { newPhase: this.currentPhase, turnEnded: true };
        }
        return { newPhase: this.currentPhase, turnEnded: false };
    }
    startNewTurn() {
        this.#turnNumber++;
        this.#currentPhaseIndex = 0; // Start at Mana phase
        return this.currentPhase;
    }
    setPhase(phaseName) { const i = TURN_PHASES.indexOf(phaseName); if (i !== -1) this.#currentPhaseIndex = i; }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\core\TurnManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\network\NetworkManager.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\network\NetworkManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\ScreenManager.js ---
// js/ui/ScreenManager.js

/**
 * Manages the visibility and transitions of different application screens
 * represented by divs with the '.screen' class.
 */
export default class ScreenManager {
    #activeScreenId = null;
    #previousScreenId = null; // Track the previously active screen
    #isTransitioning = false; // Flag to prevent rapid transitions
    #transitionDuration = 300; // Duration of the fade transition in ms

    constructor(transitionDuration = 300) {
        this.#transitionDuration = transitionDuration;
        // Ensure initial state on load (hide all except potentially pre-marked active one)
        // This might conflict if HTML has 'active' pre-set, adjust as needed.
        // $('.screen').not('.active').hide(); // Alternative initial setup
        console.log("ScreenManager initialized.");
    }

    /**
     * Shows the screen with the specified ID, hiding the previously active one.
     * Includes basic fade transitions.
     * @param {string} screenId The ID of the HTML element (div) for the screen to show.
     * @param {boolean} [force=false] - If true, bypass the 'already active' check.
     */
    showScreen(screenId, force = false) {
        if (!force && screenId === this.#activeScreenId) {
            // console.log(`ScreenManager: Screen '${screenId}' is already active.`);
            return; // Don't transition if already the active screen
        }
        if (this.#isTransitioning) {
             console.warn(`ScreenManager: Transition already in progress. Request for '${screenId}' ignored.`);
             return; // Prevent overlapping transitions
        }

        const $currentScreen = this.#activeScreenId ? $(`#${this.#activeScreenId}`) : null;
        const $nextScreen = $(`#${screenId}`);

        if (!$nextScreen.length) {
            console.error(`ScreenManager Error: Screen with ID '${screenId}' not found!`);
            // Fallback: Maybe show the title screen?
            if (this.#activeScreenId !== 'title-screen') {
                console.warn("ScreenManager Fallback: Showing 'title-screen'.");
                this.showScreen('title-screen', true); // Force show title
            }
            return;
        }

        console.log(`ScreenManager: Transitioning from '${this.#activeScreenId || 'none'}' to '${screenId}'`);
        this.#isTransitioning = true;

        // --- Transition Logic ---

        // 1. Fade out the current screen (if one exists)
        if ($currentScreen && $currentScreen.length) {
            $currentScreen.addClass('screen-fade-out'); // Add fade-out class
            setTimeout(() => {
                $currentScreen.removeClass('active screen-fade-out'); // Hide after fade
            }, this.#transitionDuration);
        }

        // 2. Prepare and fade in the next screen
        // Ensure it's ready but invisible initially for the fade-in effect
        $nextScreen.addClass('active screen-prepare-fade-in');

        // Use a tiny delay before starting fade-in to allow browser to apply initial styles
        setTimeout(() => {
            $nextScreen.removeClass('screen-prepare-fade-in').addClass('screen-fade-in'); // Start fade-in
        }, 20); // Small delay (adjust if needed)


        // 3. Clean up after the transition
        setTimeout(() => {
            $nextScreen.removeClass('screen-fade-in'); // Remove fade-in class after duration
            this.#previousScreenId = this.#activeScreenId; // Update previous screen tracker
            this.#activeScreenId = screenId; // Set the new active screen ID
            this.#isTransitioning = false; // Allow new transitions
            console.log(`ScreenManager: Screen '${screenId}' is now active.`);
        }, this.#transitionDuration + 50); // Add a small buffer after duration
    }

    /**
     * Returns the ID of the currently active screen.
     * @returns {string | null}
     */
    getActiveScreenId() {
        return this.#activeScreenId;
    }

    /**
     * Returns the ID of the previously shown screen.
     * Useful for implementing a generic "Back" button.
     * @returns {string | null}
     */
    getPreviousScreenId() {
        return this.#previousScreenId;
    }

    /**
     * Navigates back to the previously shown screen.
     * Optional: Provide a fallback screen ID if no previous screen is recorded.
     * @param {string} [fallbackScreenId='title-screen'] - Screen to go to if no previous screen exists.
     */
    goBack(fallbackScreenId = 'title-screen') {
        if (this.#previousScreenId && this.#previousScreenId !== this.#activeScreenId) {
            console.log(`ScreenManager: Going back to '${this.#previousScreenId}'`);
            this.showScreen(this.#previousScreenId);
        } else {
            console.log(`ScreenManager: No previous screen or cannot go back, going to fallback '${fallbackScreenId}'`);
            this.showScreen(fallbackScreenId);
        }
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\ScreenManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\templates.js ---

--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\templates.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\UIManager.js ---
// js/ui/UIManager.js - Refatorado (Esqueleto)

// Importar os novos módulos
import ProfileScreenUI from './screens/ProfileScreenUI.js'; // CORRIGIDO
import DeckBuilderUI from './screens/DeckBuilderUI.js';   // CORRIGIDO
import BattleScreenUI from './screens/BattleScreenUI.js'; // CORRIGIDO
import OptionsUI from './screens/OptionsUI.js';         // CORRIGIDO
import CardRenderer from './helpers/CardRenderer.js'; // OK
import ZoomHandler from './helpers/ZoomHandler.js';   // OK

export default class UIManager {
    // --- Core References ---
    #screenManager;
    #accountManager;
    #cardDatabase;
    #gameInstance = null;
    #localPlayerId = null;

    // --- UI Module Instances ---
    #profileUI;
    #deckBuilderUI;
    #battleUI;
    #optionsUI;
    #cardRenderer;
    #zoomHandler;

    constructor(screenManager, accountManager, cardDatabase) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;

        // Instanciar helpers primeiro se outros dependerem deles
        this.#cardRenderer = new CardRenderer();
        this.#zoomHandler = new ZoomHandler(this.#cardDatabase); // Passa dependência

        // Instanciar módulos de UI específicos, injetando dependências
        // (Certifique-se de que as classes que você está instanciando
        // são as importadas corretamente acima)
        this.#optionsUI = new OptionsUI(); // Pode não precisar de nada
        this.#profileUI = new ProfileScreenUI(
            this.#screenManager,
            this.#accountManager,
            this.#cardDatabase,
            this.#cardRenderer,
            this.#zoomHandler,
            this // Passa o próprio UIManager se precisar chamar renderDeckBuilderScreen
        );
        this.#deckBuilderUI = new DeckBuilderUI(
            this.#screenManager,
            this.#accountManager,
            this.#cardDatabase,
            this.#cardRenderer,
            this.#zoomHandler
        );
        this.#battleUI = new BattleScreenUI(
             this.#screenManager,
             this.#accountManager, // <--- Adicionei accountManager aqui, pois BattleScreenUI o usa
             this.#cardDatabase,
             this.#cardRenderer,
             this.#zoomHandler
         );

        this._bindPermanentUIActions(); // Bind global/top bar actions
        console.log("UIManager (Coordinator) inicializado.");
    }

    // --- Setup ---
    setGameInstance(gameInstance) {
        this.#gameInstance = gameInstance;
        console.log("UI Coordinator: Game instance set.");
        // Passar a instância para os módulos que precisam dela
        this.#battleUI.setGameInstance(gameInstance);
    }
    setLocalPlayer(playerId) {
        this.#localPlayerId = playerId;
        console.log(`UI Coordinator: Local player set: ${playerId}`);
        this.#battleUI.setLocalPlayer(playerId);
    }

    // --- Top Bar Control --- (Pode permanecer aqui)
    showTopBar(userData) {
        const $topBar = $('#top-bar');
        if (userData) {
            $topBar.find('#top-bar-username').text(userData.username);
            $topBar.addClass('active'); // Make it visible
            console.log("UIManager: Top Bar shown for", userData.username);
        } else {
            console.warn("UIManager: showTopBar called without user data.");
        }
    }
    hideTopBar() {
        $('#top-bar').removeClass('active');
        console.log("UIManager: Top Bar hidden.");
    }


    // --- Delegação de Renderização ---
    renderProfileScreen() {
        console.log("UI Coordinator: Delegating profile screen rendering.");
        this.#profileUI.render(); // Chama o método render do módulo específico
        // ProfileUI.bindEvents() deve ser chamado dentro do seu próprio render ou construtor
    }
    renderDeckBuilderScreen(deckIdToEdit = null) {
        console.log("UI Coordinator: Delegating deck builder rendering.");
        this.#deckBuilderUI.render(deckIdToEdit);
    }
    renderOptionsScreen() {
         console.log("UI Coordinator: Delegating options screen rendering.");
         this.#optionsUI.render();
    }
    renderInitialGameState() {
        console.log("UI Coordinator: Delegating initial game state rendering.");
         if (!this.#gameInstance || !this.#localPlayerId) {
             console.error("UI Coordinator: Cannot render game state - game/player not set.");
             return;
         }
        this.#battleUI.renderInitialState(); // BattleUI agora lida com isso
        // Os bindings de jogo e UI são feitos dentro do BattleScreenUI
    }

    // --- Bindings Globais/Top Bar ---
    _bindPermanentUIActions() {
        // Vincula apenas ações que são realmente globais ou da Top Bar
        // Exemplo: Botões da Top Bar que NAVEGAM entre telas principais
         $('#top-bar-btn-profile').off('click').on('click', () => {
            if(this.#screenManager.getActiveScreenId() !== 'profile-screen'){
                this.renderProfileScreen(); // Delega renderização
                this.#screenManager.showScreen('profile-screen');
            }
         });
         $('#top-bar-btn-connect').off('click').on('click', () => {
              // Renderização da tela Connect é feita pelo template
              $('#connect-message').text(''); // Resetar estado se necessário
              this.#screenManager.showScreen('connect-screen');
         });
         $('#top-bar-btn-options').off('click').on('click', () => {
              this.renderOptionsScreen(); // Delega renderização
              this.#screenManager.showScreen('options-screen');
         });
         $('#top-bar-btn-logout').off('click').on('click', () => {
             this.#accountManager.logout();
             this.hideTopBar();
             $('#screens-container').removeClass('with-top-bar');
             this.#screenManager.showScreen('title-screen');
         });

         // Talvez o listener global de ESC para fechar overlays fique aqui
         $(document).off('keydown.uimclose').on('keydown.uimclose', (e) => {
             if (e.key === "Escape") {
                 this.#zoomHandler?.closeZoom(); // Delega ao zoom handler
                 // Fechar outros modais/popups se houver
             }
         });
    }

    // Métodos específicos de cada tela foram MOVIDOS para seus respectivos módulos

} // End class UIManager (Coordinator)
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\UIManager.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\CardRenderer.js ---
// js/ui/helpers/CardRenderer.js

/**
 * Módulo Helper para renderizar o HTML das cartas.
 */
export default class CardRenderer {

    /**
     * Gera o HTML para uma carta no tamanho de batalha.
     * @param {object} cardData - Os dados da carta (resultado de getRenderData() ou definição).
     * @param {string} [location='hand'] - A localização atual (afeta classes/atributos).
     * @returns {jQuery|null} Objeto jQuery representando a carta ou null.
     */
    renderCard(cardData, location = 'hand') {
        if (!cardData) return null;
        const cardClass = 'card'; // Sempre .card para batalha
        const uniqueIdAttr = `data-card-unique-id="${cardData.uniqueId}"`; // Sempre adicionar uniqueId para instâncias de jogo
        const baseIdAttr = `data-card-id="${cardData.id}"`;
        const cardName = cardData.name || 'Unknown Card';
        const imageSrc = cardData.imageSrc || 'assets/images/cards/default.png';

        // Tooltip (mais detalhado para batalha)
        const tooltipParts = [
            `${cardName} [${cardData.cost ?? '?'}]`,
            `${cardData.type}${cardData.tribe ? ` - ${cardData.tribe}` : ''}`,
        ];
        if (cardData.attack !== undefined) { // Base Attack/Toughness da Definição para tooltip
             const baseAttack = cardData.baseAttack ?? cardData.attack ?? '?';
             const baseToughness = cardData.baseToughness ?? cardData.toughness ?? '?';
             tooltipParts.push(` ${baseAttack}/${baseToughness}`);
        }
        tooltipParts.push(cardData.description || cardData.effectText || '');
        const tooltip = tooltipParts.join('\n');

        // Estrutura HTML
        let cardHtml = `<div class="${cardClass} ${cardData.type?.toLowerCase() || ''}"
                           ${uniqueIdAttr} ${baseIdAttr}
                           title="${tooltip}"
                           style="background-image: url('${imageSrc}')">`;

        // Overlays (Cost, Name, Stats)
        cardHtml += `<div class="card-overlay card-cost">${cardData.cost ?? '?'}</div>`;
        cardHtml += `<div class="card-overlay card-name">${cardName}</div>`;
        if (cardData.type === 'Creature') {
            // Mostra stats ATUAIS (calculados) vindos de cardData.getRenderData()
            const displayAttack = cardData.attack ?? '?';
            const displayToughness = cardData.currentToughness ?? cardData.toughness ?? '?'; // Prefere currentToughness
            cardHtml += `<div class="card-overlay card-stats">
                            <span class="card-attack">${displayAttack}</span>/<span class="card-toughness">${displayToughness}</span>
                         </div>`;
        }
        // Adicionar indicadores visuais para status (tapped, sickness, etc.)
        // if (cardData.isTapped) cardHtml += `<div class="card-status-icon tapped-icon">↷</div>`;
        // if (cardData.hasSummoningSickness) cardHtml += `<div class="card-status-icon sickness-icon">🌀</div>`;

        cardHtml += `</div>`; // Fecha card div
        const $card = $(cardHtml);
        $card.data('card-name', cardName); // Armazena nome para fácil acesso
        // Aplicar classes de estado visual baseadas nos dados recebidos
        $card.toggleClass('tapped', !!cardData.isTapped);
        $card.toggleClass('has-summoning-sickness', !!cardData.hasSummoningSickness);
        $card.toggleClass('cannot-act', !(cardData.canAttack ?? true)); // Exemplo
        if(cardData.statusEffects) { $card.toggleClass('shielded', !!cardData.statusEffects['shielded']); $card.toggleClass('silenced', !!cardData.statusEffects['silenced'] || !!cardData.statusEffects['cant_attack']); }

        return $card;
    }

    /**
     * Gera o HTML para uma mini-carta (Coleção, Deck Builder).
     * @param {object} cardDefinition - A definição da carta do cardDatabase.
     * @param {string} [location='collection'] - 'collection' ou 'deck'.
     * @returns {jQuery|null} Objeto jQuery representando a mini-carta ou null.
     */
    renderMiniCard(cardDefinition, location = 'collection') {
        if (!cardDefinition) return null;
        const cardClass = 'mini-card';
        const locationClass = location === 'deck' ? 'in-deck' : 'in-collection';
        const baseIdAttr = `data-card-id="${cardDefinition.id}"`; // Mini cards só precisam do ID base
        const cardName = cardDefinition.name || 'Unknown Card';
        const imageSrc = cardDefinition.image_src || 'assets/images/cards/default.png';

        // Tooltip (pode ser igual ao renderCard ou simplificado)
        const tooltipParts = [
            `${cardName} [${cardDefinition.cost ?? '?'}]`,
            `${cardDefinition.type}${cardDefinition.tribe ? ` - ${cardDefinition.tribe}` : ''}`,
        ];
        if (cardDefinition.attack !== undefined) {
            tooltipParts.push(` ${cardDefinition.attack}/${cardDefinition.toughness}`);
        }
        tooltipParts.push(cardDefinition.description || cardDefinition.effect || '');
        const tooltip = tooltipParts.join('\n');

        // Estrutura HTML (background na div principal)
        const $card = $(`
            <div class="${cardClass} ${locationClass}"
                 ${baseIdAttr}
                 title="${tooltip}"
                 style="background-image: url('${imageSrc}')">
                 <div class="card-name-overlay">${cardName}</div>
                 <!-- Mini-cards geralmente não mostram stats diretamente -->
             </div>`);

        $card.data('card-name', cardName);
        return $card;
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\CardRenderer.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\ZoomHandler.js ---
// js/ui/helpers/ZoomHandler.js

export default class ZoomHandler {
    #cardDatabase;
    #activeOverlayId = null; // Controla qual overlay está ativo

    // Mapeamento dos overlays e suas imagens correspondentes
    #overlayMap = {
        'profile-screen': { overlay: '#image-zoom-overlay', image: '#zoomed-image' },
        'deck-builder-screen': { overlay: '#deckbuilder-image-zoom-overlay', image: '#deckbuilder-zoomed-image' },
        'battle-screen': { overlay: '#battle-image-zoom-overlay', image: '#battle-zoomed-image' }
        // Adicione mais mapeamentos se criar overlays para outras telas
    };

    constructor(cardDatabase) {
        if (!cardDatabase) {
            throw new Error("ZoomHandler requires cardDatabase.");
        }
        this.#cardDatabase = cardDatabase;
        this._bindGlobalClose(); // Bind ESC key globally
        console.log("ZoomHandler initialized.");
    }

    /**
     * Manipula o evento de clique (ou contextmenu) para exibir o zoom.
     * Determina o contexto (tela) e mostra o overlay correto.
     * @param {Event} event - O evento de clique/contextmenu.
     * @param {Game | null} [gameInstance=null] - Instância do jogo (opcional, para buscar dados de cartas em jogo).
     */
    handleZoomClick(event, gameInstance = null) {
        event.preventDefault(); // Previne menu de contexto padrão
        event.stopPropagation(); // Impede propagação

        const $card = $(event.currentTarget);
        const cardUniqueId = $card.data('card-unique-id'); // Para cartas em jogo
        const cardBaseId = $card.data('card-id');       // Para cartas na coleção/DB

        let cardData = null;
        let imageSrc = null;
        let cardName = 'Carta Desconhecida';

        // 1. Tenta obter dados da instância do jogo (se houver e for carta em jogo)
        if (cardUniqueId && gameInstance) {
            const gameCard = gameInstance.findCardInstance(cardUniqueId);
            if (gameCard) {
                cardData = gameCard.getRenderData(); // Pega os dados atuais da instância
                imageSrc = cardData.imageSrc;
                cardName = cardData.name;
            }
        }

        // 2. Se não encontrou no jogo ou não era carta de jogo, busca na database pelo ID base
        if (!imageSrc && cardBaseId) {
            cardData = this.#cardDatabase[cardBaseId];
            if (cardData) {
                imageSrc = cardData.image_src;
                cardName = cardData.name;
            }
        }

        // 3. Se encontrou uma imagem, determina o overlay e mostra
        if (imageSrc) {
            console.log(`Zooming card: ${cardName}`);
            const $screen = $card.closest('.screen'); // Encontra a tela pai
            const screenId = $screen.attr('id');
            const mapping = this.#overlayMap[screenId]; // Pega o mapeamento para essa tela

            if (mapping) {
                const $overlay = $(mapping.overlay);
                const $image = $(mapping.image);

                if ($overlay.length && $image.length) {
                    // --- CORREÇÃO APLICADA AQUI ---
                    this.closeZoom(); // Fecha qualquer zoom anterior (chama método público)
                    // -------------------------------
                    $image.attr('src', imageSrc).attr('alt', cardName);
                    $overlay.addClass('active');
                    this.#activeOverlayId = mapping.overlay; // Guarda qual overlay está ativo
                } else {
                    console.error(`Zoom overlay ('${mapping.overlay}') or image ('${mapping.image}') not found!`);
                }
            } else {
                console.warn(`Zoom mapping not found for screen: ${screenId}`);
            }
        } else {
            console.log(`No image source found for card ${cardUniqueId || cardBaseId}`);
        }
    }

    /**
     * Fecha o overlay de zoom atualmente ativo.
     * Este é um método PÚBLICO.
     */
    closeZoom() {
        if (this.#activeOverlayId) {
            $(this.#activeOverlayId).removeClass('active');
            // Limpa a imagem para evitar flash
            $(`${this.#activeOverlayId} img`).attr('src', '');
            console.log(`Closed zoom overlay: ${this.#activeOverlayId}`);
            this.#activeOverlayId = null;
        }
        // Fallback para fechar todos, caso o estado se perca
        else if ($('.image-zoom-overlay.active').length > 0) {
            console.warn("Closing zoom overlay without activeOverlayId set. Closing all.");
            $('.image-zoom-overlay').removeClass('active');
            $('.image-zoom-overlay img').attr('src', '');
        }
    }

    /**
     * Vincula o fechamento global (ESC).
     * O fechamento por clique fora é melhor vinculado no módulo que usa o handler.
     */
    _bindGlobalClose() {
        // Fechar com ESC
        $(document).off('keydown.zoomhandler').on('keydown.zoomhandler', (e) => {
            if (e.key === "Escape") {
                this.closeZoom(); // Chama o método público
            }
        });
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\helpers\ZoomHandler.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\battleScreenTemplate.js ---
// js/ui/html-templates/battleScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Batalha principal.
 * @returns {string} HTML da tela de batalha.
 */
export function generateBattleScreenHTML() {
    // --- CAMINHO DAS IMAGENS ---
    const deckCoverImage = 'assets/images/cards/card_cover.png';
    const graveyardPlaceholderImage = 'assets/images/ui/graveyard.png'; // Certifique-se que esta imagem existe no caminho

    return `
        <div id="battle-screen" class="screen battle-screen-layout">

            <!-- Área do Oponente (Topo) -->
            <div class="player-area opponent">
                <div class="player-info">
                    <div class="player-avatar">
                         <img id="opponent-avatar-img" src="assets/images/avatars/default.png" alt="Opponent Avatar">
                    </div>
                    <div class="player-stats">
                        <span id="opponent-name">Oponente</span>
                        <div class="resource life">❤️ <span id="opponent-life">20</span></div>
                        <div class="resource mana">💧 <span id="opponent-mana">0</span>/<span id="opponent-max-mana">0</span></div>
                    </div>
                </div>
                <div class="hand opponent-hand-area">
                    <span>Mão Oponente: <span id="opponent-hand-count">0</span> cartas</span>
                    <div id="opponent-hand" class="card-zone">
                        <!-- Cartas escondidas ou contagem -->
                    </div>
                </div>
                 <div class="player-zones">
                     
                     <div class="deck-zone" title="Deck do Oponente">
                         <img id="opponent-deck-img" src="${deckCoverImage}" alt="Deck Oponente" class="zone-image deck-image"> {/* <-- Imagem do Deck Adicionada */}
                         <div class="deck-count" id="opponent-deck-count">0</div>
                         <span>Deck</span>
                     </div>
                    
                     <div class="graveyard-zone" title="Cemitério do Oponente">
                         <img id="opponent-graveyard-img" src="${graveyardPlaceholderImage}" alt="Cemitério Oponente" class="zone-image graveyard-image"> {/* <-- Imagem do Cemitério Adicionada */}
                         <div class="graveyard-count" id="opponent-graveyard-count">0</div>
                         <span>Cemitério</span>
                     </div>
                 </div>
                <div id="opponent-battlefield" class="battlefield card-zone">
                    <!-- Criaturas e Runebindings do oponente -->
                </div>
            </div>

            <!-- Área Central (Controles, Log) -->
            <div class="center-area">
                <div class="game-log-container scrollable-list">
                    <ul id="game-log" class="game-log">
                        <li>Log da Partida:</li>
                        <!-- Mensagens serão adicionadas aqui -->
                    </ul>
                </div>
                <div class="turn-info">
                    Turno <span id="turn-number">1</span> - Fase: <span id="phase-indicator">Mana</span>
                    (<span id="current-player-indicator">Jogador</span>)
                </div>
                 <div class="turn-controls">
                    <button id="btn-pass-phase">Passar Fase</button>
                    <button id="btn-end-turn">Finalizar Turno</button>
                    <button id="btn-discard-mana" title="Descartar 1 carta para ganhar +1 Mana Máx (1x por turno)">Descartar p/ Mana</button>
                    <!-- Botões de combate serão adicionados/mostrados pelo UIManager -->
                    <button id="btn-confirm-attack" style="display: none;">Confirmar Ataque</button>
                    <button id="btn-confirm-blocks" style="display: none;">Confirmar Bloqueios</button>
                </div>
                <div id="action-feedback" class="action-feedback-area">
                    <!-- Mensagens como "Selecione um alvo", "Descartar X", etc. -->
                </div>
            </div>

            <!-- Área do Jogador (Baixo) -->
            <div class="player-area local-player">
                 <div id="player-battlefield" class="battlefield card-zone">
                    <!-- Criaturas e Runebindings do jogador -->
                </div>
                 <div class="player-zones">
                     
                      <div class="deck-zone" title="Seu Deck">
                          <img id="player-deck-img" src="${deckCoverImage}" alt="Seu Deck" class="zone-image deck-image"> {/* <-- Imagem do Deck Adicionada */}
                          <div class="deck-count" id="player-deck-count">0</div>
                          <span>Deck</span>
                      </div>
                      
                      <div class="graveyard-zone" title="Seu Cemitério">
                           <img id="player-graveyard-img" src="${graveyardPlaceholderImage}" alt="Seu Cemitério" class="zone-image graveyard-image"> {/* <-- Imagem do Cemitério Adicionada */}
                           <div class="graveyard-count" id="player-graveyard-count">0</div>
                           <span>Cemitério</span>
                      </div>
                 </div>
                <div id="player-hand" class="hand card-zone">
                    <!-- Suas cartas na mão -->
                </div>
                 <div class="player-info">
                     <div class="player-avatar">
                         <img id="player-avatar-img" src="assets/images/avatars/default.png" alt="Player Avatar">
                     </div>
                     <div class="player-stats">
                        <span id="player-name">Você</span>
                        <div class="resource life">❤️ <span id="player-life">20</span></div>
                        <div class="resource mana">💧 <span id="player-mana">0</span>/<span id="player-max-mana">0</span></div>
                    </div>
                </div>
            </div>

            <!-- Overlay para Zoom da Imagem de Carta -->
            <div id="battle-image-zoom-overlay" class="image-zoom-overlay">
                 <img id="battle-zoomed-image" src="" alt="Zoomed Card">
             </div>

             <!-- Overlay para Confirmação/Resultado do Jogo -->
             <div id="game-over-overlay" class="game-over-overlay">
                 <div id="game-over-message">Fim de Jogo!</div>
                 <button id="btn-back-to-profile">Voltar ao Perfil</button>
             </div>

        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\battleScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\connectScreenTemplate.js ---
// js/ui/html-templates/connectScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Conexão/Criação de Partida.
 * Contém lógica simulada para criar/entrar em jogos.
 * @returns {string} HTML da tela de conexão.
 */
export function generateConnectScreenHTML() {
    // A lógica real de rede não está aqui, apenas a estrutura da UI
    return `
        <div id="connect-screen" class="screen connect-layout">
        <img class="connect-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>Conectar e Jogar</h2>
            

            <div class="connect-options">
                <!-- Opção 1: Criar um Jogo (Simulado) -->
                <div class="connect-section">
                    <h3>Criar Partida</h3>
                    <img class="connect-host" src="assets/images/ui/host.png" alt="Runebound Clash Logo" class="title-logo">
                    <button id="btn-create-server">Criar Jogo (Host)</button>

                    <div id="server-status-section" style="display: none; margin-top: 15px; padding: 10px; border: 1px solid #ccc;">
                        <p>Status: <strong id="server-ip-code">Aguardando conexão...</strong></p>
                        <p>(Aguardando oponente...)</p>
                        <button id="btn-cancel-hosting">Cancelar Criação</button>
                    </div>
                </div>

                <!-- Opção 2: Entrar em um Jogo (Simulado) -->
                <div class="connect-section">
                    <h3>Entrar em Partida</h3>
                    <img class="connect-join" src="assets/images/ui/join.png" alt="Runebound Clash Logo" class="title-logo">
                    <button id="btn-show-join-options">Procurar Jogo (Join)</button>

                    <div id="join-game-section" style="display: none; margin-top: 15px;" class="form-container">
                         <div class="form-group">
                            <label for="opponent-ip">Código/IP do Host:</label>
                            <input type="text" id="opponent-ip" placeholder="Insira o código">
                        </div>
                         <div class="form-actions">
                            <button id="btn-connect-to-server">Conectar</button>
                            <!-- Poderia ter um botão para cancelar/voltar -->
                        </div>
                    </div>
                </div>
            </div>

            <p id="connect-message" class="message" style="margin-top: 20px;"></p>

            <div class="connect-actions">
                <button id="btn-connect-back-to-main">Voltar ao Perfil</button>
            </div>

            <!-- Futuro: Lista de Jogos Abertos/Amigos Online -->

        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\connectScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\createAccountScreenTemplate.js ---
// js/ui/html-templates/createAccountScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Criação de Conta.
 * @returns {string} HTML da tela de criação de conta.
 */
export function generateCreateAccountScreenHTML() {
    return `
        <div id="create-account-screen" class="screen">
        <img class="create-account-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>CRIAR CONTA NOVA</h2>
            <form id="create-account-form" class="form-container">
                <div class="form-group">
                    <label for="create-username">Nome de Usuário (min 3):</label>
                    <input type="text" id="create-username" name="username" required minlength="3">
                </div>
                <div class="form-group">
                    <label for="create-password">Senha:</label>
                    <input type="password" id="create-password" name="password" required>
                    <!-- Poderia adicionar confirmação de senha se desejado -->
                    <!--
                    <label for="create-confirm-password">Confirmar Senha:</label>
                    <input type="password" id="create-confirm-password" name="confirm_password" required>
                    -->
                </div>
                <div class="form-actions">
                    <button type="submit">Criar Conta</button>
                    <button type="button" id="btn-create-back-to-title">Voltar</button>
                </div>
            </form>
            <p id="create-account-message" class="message"></p>
            <p class="disclaimer">Lembrete: Este é um protótipo. Senhas são salvas localmente de forma insegura.</p>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\createAccountScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckBuilderScreenTemplate.js ---
// js/ui/html-templates/deckBuilderScreenTemplate.js

/**
 * Gera a string HTML para a Tela do Construtor de Decks.
 * Requer a biblioteca SortableJS para a funcionalidade de arrastar e soltar.
 * @returns {string} HTML da tela do construtor de decks.
 */
export function generateDeckBuilderScreenHTML() {
    return `
        <div id="deck-builder-screen" class="screen deck-builder-layout">
            <h2 id="deck-builder-title">Construtor de Decks</h2>

            <!-- Área Superior: Nome do Deck e Controles Principais -->
            <div class="deck-builder-top-bar">
                <div class="form-group">
                    <label for="db-deck-name">Nome do Deck:</label>
                    <input type="text" id="db-deck-name" placeholder="Meu Novo Deck" maxlength="30">
                </div>
                <div class="deck-info">
                     <span id="db-deck-count">0</span>/40 cartas
                     <span id="db-deck-validity">(Inválido)</span>
                </div>
                <div class="deck-actions">
                    <button id="btn-save-deck" disabled>Salvar Deck</button>
                    <button id="btn-clear-deck">Limpar Deck</button>
                    <button id="btn-deck-builder-back">Voltar ao Perfil</button>
                </div>
            </div>
            <p id="deck-builder-message" class="message"></p> <!-- Mensagens de feedback -->

            <!-- Área Principal: Coleção e Deck Atual -->
            <div class="deck-builder-main-area">

                <!-- Painel Esquerdo: Coleção Disponível e Filtros -->
                <div class="deck-builder-panel collection-panel">
                    <h3>Coleção Disponível (<span id="db-collection-count">0</span>)</h3>
                    <div class="filters">
                        <input type="text" id="db-filter-name" placeholder="Filtrar por nome...">
                        <select id="db-filter-type">
                            <option value="">Tipo</option>
                            <option value="Creature">Criatura</option>
                            <option value="Runebinding">Runebinding</option>
                            <option value="Instant">Instantânea</option>
                        </select>
                        <select id="db-filter-cost">
                            <option value="">Custo</option>
                            <!-- Opções de custo podem ser preenchidas dinamicamente ou ter valores fixos -->
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7+</option> <!-- Ou tratar 7+ no JS -->
                        </select>
                        <select id="db-filter-tribe">
                            <option value="">Tribo</option>
                            <!-- Preencher com tribos existentes -->
                            <option value="Elf">Elfo</option>
                            <option value="Dwarf">Anão</option>
                            <option value="Beast">Besta</option>
                            <option value="Dragon">Dragão</option>
                            <option value="Undead">Morto-vivo</option>
                            <option value="Elemental">Elemental</option>
                            <option value="Human">Humano</option>
                            <option value="Construct">Construto</option>
                            <option value="Spirit">Espírito</option>
                            <option value="None">Nenhuma</option>
                        </select>
                    </div>
                    <div id="db-available-cards" class="card-list scrollable-list">
                        <!-- Mini-cards da coleção filtrada são renderizados aqui -->
                        <p class="placeholder-message">(Carregando coleção...)</p>
                    </div>
                </div>

                <!-- Painel Direito: Deck Atual Sendo Construído -->
                <div class="deck-builder-panel deck-panel">
                    <h3>Deck Atual (<span id="db-deck-count-display">0</span>/40)</h3>
                    <p class="subtle-text">Arraste cartas aqui ou para fora.</p>
                     <div id="db-current-deck" class="card-list scrollable-list">
                        <!-- Mini-cards no deck atual são renderizados aqui -->
                         <p class="placeholder-message">(Arraste cartas da coleção para cá)</p>
                    </div>
                </div>

            </div>
             <!-- Overlay para Zoom da Imagem (pode ser o mesmo do perfil ou específico) -->
             <div id="deckbuilder-image-zoom-overlay" class="image-zoom-overlay">
                 <img id="deckbuilder-zoomed-image" src="" alt="Zoomed Card">
             </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\deckBuilderScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\loginScreenTemplate.js ---
// js/ui/html-templates/loginScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Login.
 * @returns {string} HTML da tela de login.
 */
export function generateLoginScreenHTML() {
    return `
        <div id="login-screen" class="screen">
            <img class="login-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">
            <h2>LOGIN</h2>
            
            <form id="login-form" class="form-container">
                <div class="form-group">
                    <label for="login-username">Nome de Usuário:</label>
                    <input type="text" id="login-username" name="username" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Senha:</label>
                    <input type="password" id="login-password" name="password" required>
                </div>
                <div class="form-actions">
                    <button type="submit">Entrar</button>
                    <button type="button" id="btn-login-back-to-title">Voltar</button>
                </div>
            </form>
            <p id="login-message" class="message"></p>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\loginScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\optionsScreenTemplate.js ---
// js/ui/html-templates/optionsScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Opções.
 * @returns {string} HTML da tela de opções.
 */
export function generateOptionsScreenHTML() {
    return `
        <div id="options-screen" class="screen options-layout">
            <h2>Opções do Jogo</h2>

            <div class="options-container scrollable-list">

                <fieldset class="options-group">
                    <legend>Áudio</legend>
                    <div class="option-item">
                        <label for="opt-music-volume">Volume da Música:</label>
                        <input type="range" id="opt-music-volume" min="0" max="100" step="1" value="80">
                        <span class="volume-value">80%</span>
                    </div>
                    <div class="option-item">
                        <label for="opt-sfx-volume">Volume dos Efeitos:</label>
                        <input type="range" id="opt-sfx-volume" min="0" max="100" step="1" value="100">
                        <span class="volume-value">100%</span>
                    </div>
                </fieldset>

                <fieldset class="options-group">
                    <legend>Gráficos</legend>
                    <div class="option-item">
                        <label for="opt-graphics-quality">Qualidade Gráfica:</label>
                        <select id="opt-graphics-quality">
                            <option value="low">Baixa</option>
                            <option value="medium" selected>Média</option>
                            <option value="high">Alta</option>
                        </select>
                    </div>
                    <div class="option-item">
                        <label for="opt-card-animations">Animações das Cartas:</label>
                        <input type="checkbox" id="opt-card-animations" checked>
                    </div>
                    <!-- Adicionar mais opções gráficas se necessário (resolução, etc.) -->
                </fieldset>

                <fieldset class="options-group">
                    <legend>Interface</legend>
                    <div class="option-item">
                        <label for="opt-language">Idioma:</label>
                        <select id="opt-language">
                            <option value="pt-BR" selected>Português (BR)</option>
                            <option value="en-US">English (US)</option>
                            <!-- Adicionar mais idiomas -->
                        </select>
                    </div>
                     <div class="option-item">
                        <label for="opt-text-size">Tamanho do Texto:</label>
                        <select id="opt-text-size">
                            <option value="small">Pequeno</option>
                            <option value="normal" selected>Normal</option>
                            <option value="large">Grande</option>
                        </select>
                    </div>
                     <div class="option-item">
                        <label for="opt-high-contrast">Alto Contraste:</label>
                        <input type="checkbox" id="opt-high-contrast">
                    </div>
                    <!-- Adicionar mais opções de interface -->
                </fieldset>

                <!-- Adicionar mais grupos de opções (Controles, Rede, Conta, etc.) -->

            </div>

            <div class="options-actions form-actions">
                <button id="btn-save-options">Salvar Opções</button>
                <button id="btn-options-back-to-main">Voltar</button> <!-- O ID no main.js era btn-options-back-to-main -->
            </div>
             <p id="options-save-message" class="message" style="text-align: center; margin-top: 10px;"></p>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\optionsScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\profileScreenTemplate.js ---
// js/ui/html-templates/profileScreenTemplate.js

/**
 * Gera a string HTML para a Tela de Perfil do Jogador.
 * @returns {string} HTML da tela de perfil.
 */
export function generateProfileScreenHTML() {
    // Inclui placeholders para os avatares baseados na sua estrutura de arquivos
    const avatarPath = 'assets/images/avatars/';
    const availableAvatars = ['default.png', 'avatar1.png', 'avatar2.png', 'avatar3.png']; // Adicione mais se tiver

    let avatarChoicesHTML = availableAvatars.map(filename => `
        <img src="${avatarPath}${filename}"
             class="avatar-choice ${filename === 'default.png' ? 'selected-avatar' : ''}"
             data-avatar="${filename}"
             alt="Avatar ${filename.split('.')[0]}"
             title="Selecionar ${filename.split('.')[0]}">
    `).join('');

    return `
        <div id="profile-screen" class="screen profile-layout">
            <h2>Perfil do Jogador</h2>

            <div class="profile-main-area">
                <div class="profile-left-column">
                    <!-- Informações Básicas -->
                    <div class="profile-section profile-info">
                        <h3>Informações</h3>
                        <p>Nome: <strong id="profile-username">(Carregando...)</strong></p>
                        <p>Rank: <span id="profile-rank">N/A</span></p>
                        <p>Vitórias/Derrotas: <span id="profile-wins">0</span> / <span id="profile-losses">0</span></p>
                    </div>

                    <!-- Seleção de Avatar -->
                    <div class="profile-section profile-avatar-section">
                        <h3>Avatar</h3>
                        <div class="profile-avatar-display">
                            <img id="profile-avatar-img" src="${avatarPath}default.png" alt="Avatar do Jogador">
                        </div>
                        <div id="profile-avatar-choices" class="avatar-choices-container">
                            ${avatarChoicesHTML}
                        </div>
                    </div>

                    <!-- Histórico de Partidas -->
                    <div class="profile-section profile-history">
                         <h3>Histórico de Partidas (Últimas 10)</h3>
                         <ul id="profile-match-history">
                             <li>(Nenhum histórico ainda)</li>
                             <!-- O histórico será preenchido pelo UIManager -->
                         </ul>
                    </div>
                </div>

                <div class="profile-right-column">
                     <!-- Coleção de Cartas -->
                    <div class="profile-section profile-collection">
                        <h3>Coleção (<span id="profile-card-count">0</span> cartas)</h3>
                        <p class="subtle-text">Clique com o botão direito do mouse para ampliar a carta</p>
                        <div id="profile-unlocked-cards" class="card-grid scrollable-list">
                            <p>(Carregando coleção...)</p>
                            <!-- Mini-cards são renderizados aqui pelo UIManager -->
                        </div>
                    </div>

                    <!-- Lista de Decks -->
                    <div class="profile-section profile-decks">
                        <h3>Meus Decks</h3>
                         <ul id="profile-deck-list" class="scrollable-list deck-list-profile">
                             <li>(Carregando decks...)</li>
                             <!-- Decks são renderizados aqui pelo UIManager -->
                         </ul>
                         <button id="btn-goto-deck-builder-new" class="button-primary">Gerenciar Decks</button>
                    </div>
                </div>
            </div>

             <!-- Overlay para Zoom da Imagem (pode ser global se preferir) -->
             <div id="image-zoom-overlay" class="image-zoom-overlay">
                 <img id="zoomed-image" src="" alt="Zoomed Card">
             </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\profileScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\splashScreenTemplate.js ---
// js/ui/html-templates/splashScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela de Splash (Carregamento Inicial).
 * A imagem é definida como background no CSS.
 * A mensagem funciona como barra de progresso.
 * @returns {string} HTML da tela de splash.
 */
export function generateSplashScreenHTML() {
    return `
        <div id="splash-screen" class="screen active"> <!-- Começa ativa -->
            <!-- A imagem de fundo é aplicada via CSS -->
            <div class="splash-content"> <!-- Container para posicionar a mensagem -->
                 <p class="splash-message">Carregando Runebound...</p>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\splashScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\titleScreenTemplate.js ---
// js/ui/html-templates/titleScreenTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Tela de Título.
 * Inclui logo acima dos botões.
 * @returns {string} HTML da tela de título.
 */
export function generateTitleScreenHTML() {
    return `
        <div id="title-screen" class="screen active">
            <!-- Título Principal -->
            

            <!-- Logo Adicionado -->
            <img class="title-logo" src="assets/images/ui/runebound_logo.png" alt="Runebound Clash Logo" class="title-logo">

            <!-- Menu de Botões -->
            <div class="title-menu">
                <button id="btn-goto-login">Login</button>
                <button id="btn-goto-create-account">Criar Conta</button>
                <button id="btn-goto-options-icon" class="icon-button" title="Opções">⚙️</button>
            </div>

            <!-- Você pode adicionar mais elementos aqui, como links para créditos, patch notes, etc. -->
            <div class="title-footer">
                <a href="#">Créditos</a> | <a href="#">Versão 0.1.0</a>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\titleScreenTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\topBarTemplate.js ---
// js/ui/html-templates/topBarTemplate.js - ATUALIZADO

/**
 * Gera a string HTML para a Barra Superior (Top Bar).
 * Contém logo, nome do jogo, nome do usuário (direita) e botões de navegação.
 * @returns {string} HTML da Top Bar.
 */
export function generateTopBarHTML() {
    // Logo e Nome do Jogo adicionados à esquerda.
    // Nome do Usuário movido para a direita.
    return `
        <div id="top-bar" class=""> <!-- Começa sem a classe 'active' -->
            <div class="top-bar-left">
                <img src="assets/images/ui/logo_small_placeholder.png" alt="Runebound Clash Logo" class="top-bar-logo">
                <span class="top-bar-game-name">Runebound Clash</span>
            </div>
            <div class="top-bar-right">
                <!-- Nome do usuário vem ANTES dos botões na direita -->
                <span id="top-bar-username">Carregando...</span>

                <button id="top-bar-btn-profile" title="Perfil / Coleção">
                    <span role="img" aria-label="Perfil">👤</span>
                </button>
                <button id="top-bar-btn-connect" title="Conectar / Jogar Online">
                     <span role="img" aria-label="Jogar">⚔️</span>
                </button>
                 <button id="top-bar-btn-options" title="Opções do Jogo">
                     <span role="img" aria-label="Opções">⚙️</span>
                 </button>
                 <button id="top-bar-btn-logout" title="Sair da Conta">
                     <span role="img" aria-label="Sair">🚪</span>
                 </button>
            </div>
        </div>
    `;
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\html-templates\topBarTemplate.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\BattleScreenUI.js ---
// js/ui/screens/BattleScreenUI.js

// Importar dependências
import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';
import CreatureCard from '../../core/CreatureCard.js'; // Default import - OK
import { RunebindingCard } from '../../core/RunebindingCard.js'; // Named import - CORRIGIDO
import { Graveyard } from '../../core/Graveyard.js'; // Named import - CORRIGIDO

export default class BattleScreenUI {
    // --- Referências Injetadas ---
    #screenManager;
    #accountManager; // Adicionado para buscar avatar local
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;

    // --- Estado do Jogo (Recebido) ---
    #gameInstance = null;
    #localPlayerId = null;

    // --- Elementos da UI (Cache) ---
    #battleScreenElement;
    #playerHandElement;
    #playerBattlefieldElement;
    #opponentHandElement;
    #opponentBattlefieldElement;
    #playerDeckCountElement;
    #playerGraveyardCountElement;
    #opponentDeckCountElement;
    #opponentGraveyardCountElement;
    #playerLifeElement;
    #playerManaElement;
    #playerMaxManaElement;
    #playerNameElement;
    #playerAvatarElement;
    #opponentLifeElement;
    #opponentManaElement;
    #opponentMaxManaElement;
    #opponentNameElement;
    #opponentAvatarElement;
    #opponentHandCountElement;
    #gameLogElement;
    #gameLogContainerElement;
    #turnNumberElement;
    #phaseIndicatorElement;
    #currentPlayerIndicatorElement;
    #actionFeedbackElement;
    #gameOverOverlayElement;
    #gameOverMessageElement;
    #btnEndTurn;
    #btnPassPhase;
    #btnDiscardMana;
    #btnConfirmAttack;
    #btnConfirmBlocks;
    #btnBackToProfile; // Botão do overlay de fim de jogo
    #playerDeckImgElement; // NOVO
    #playerGraveyardImgElement; // NOVO
    #opponentDeckImgElement; // NOVO
    #opponentGraveyardImgElement; // NOVO


    // --- Estado Interno da UI da Batalha ---
    #isSelectingDiscard = false;
    #isSelectingTarget = false;
    #actionPendingTarget = null; // { type: 'playCard', cardUniqueId: '...', targetType: '...' }
    #isDeclaringAttackers = false;
    #selectedAttackerIds = new Set();
    #isAssigningBlockers = false;
    #blockerAssignmentsUI = {}; // { attackerId: [blockerId1, ...] }
    #selectedBlockerId = null;
    #pendingDiscardCount = 0; // Para descarte obrigatório
    #graveyardPlaceholderSrc = 'assets/images/ui/graveyard.png'; // Armazena o caminho


    // --- Construtor ---
    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager; // Armazena AccountManager
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer;
        this.#zoomHandler = zoomHandler;

        // --- CORREÇÃO: Certifique-se que o caminho do placeholder está correto ---
        this.#graveyardPlaceholderSrc = 'assets/images/ui/graveyard.png'; // Confirme este caminho!

        this._cacheSelectors(); // Busca e armazena seletores jQuery
        if (!this.#battleScreenElement || !this.#battleScreenElement.length) {
            console.error("BattleScreenUI Error: #battle-screen element not found!");
            return;
        }
        this._bindPermanentEvents();
        console.log("BattleScreenUI initialized.");
    }

    // --- Métodos de Setup ---
    setGameInstance(gameInstance) {
        this.#gameInstance = gameInstance;
        if (this.#gameInstance) {
            this._bindGameEventListeners(); // Ouve os eventos do jogo
        }
    }
    setLocalPlayer(playerId) {
        this.#localPlayerId = playerId;
    }

    // --- Método Principal de Renderização ---
    renderInitialState() {
        if (!this.#gameInstance || !this.#localPlayerId) {
            console.error("BattleScreenUI Error: Game Instance or Local Player ID not set.");
            this.#screenManager.showScreen('profile-screen'); return;
        }
        console.log("BattleScreenUI: Rendering initial game state...");

        // Limpeza e Reset
        this._clearUI();
        this._resetUIState();

        const localPlayer = this.#gameInstance.getPlayer(this.#localPlayerId);
        const opponent = this.#gameInstance.getOpponent(this.#localPlayerId);
        if (!localPlayer || !opponent) { console.error("BattleScreenUI Error: Players not found."); return; }

        // Render Jogadores
        this._renderPlayerInfo(localPlayer, true); // Renderiza info local (inclui avatar)
        this._renderPlayerInfo(opponent, false); // Renderiza info oponente
        this._renderPlayerHand(localPlayer);
        this._renderOpponentHand(opponent);

        // --- ATUALIZAR RENDERIZAÇÃO INICIAL DE DECK/CEMITÉRIO ---
        this._updateDeckDisplay(localPlayer); // Atualiza deck (imagem já no HTML, só conta)
        this._updateDeckDisplay(opponent);
        this._updateGraveyardDisplay(localPlayer); // Atualiza cemitério (conta E imagem)
        this._updateGraveyardDisplay(opponent);
        // --- FIM DA ATUALIZAÇÃO ---

        // Render Info Turno/Fase
        this.#turnNumberElement.text(this.#gameInstance.turnNumber || 1);
        this._updatePhaseIndicator();
        this._updateCurrentPlayerIndicator();

        // Configurar Botões
        this.#btnConfirmAttack.hide().prop('disabled', true);
        this.#btnConfirmBlocks.hide().prop('disabled', true);
        this._updateTurnControls();

        // Vincular Ações da UI (após elementos existirem)
        this.bindGameActions();

        this.#screenManager.showScreen('battle-screen');
        console.log("BattleScreenUI: Initial game state render complete.");
    }

    // --- Bindings de Eventos ---
    _bindPermanentEvents() {
        $('#battle-image-zoom-overlay').off('click.battlezoom').on('click.battlezoom', (event) => {
            if (event.target === event.currentTarget) this.#zoomHandler.closeZoom();
        });
        this.#gameOverOverlayElement.off('click.gameover').on('click.gameover', (event) => {
            if (event.target === event.currentTarget) { /* Não fecha clicando fora */ }
        });
        $(document).off('keydown.battlescreen').on('keydown.battlescreen', (e) => {
            if (!this.#battleScreenElement.hasClass('active')) return;
            if (e.key === "Escape") {
                this.#zoomHandler.closeZoom();
                if (this.#isSelectingTarget) this._exitTargetSelectionMode();
                if (this.#isSelectingDiscard) this._exitDiscardSelectionMode();
                if (this.#isDeclaringAttackers) this._exitAttackerDeclarationMode();
                if (this.#isAssigningBlockers) this._exitBlockerAssignmentMode();
            }
        });
    }
    _bindGameEventListeners() {
         if (!this.#gameInstance) return;
         console.log("BattleScreenUI: Binding game event listeners...");
         // Adiciona todos os listeners necessários para eventos do Game
         this.#gameInstance.addEventListener('turnChange', this._handleTurnChange.bind(this));
         this.#gameInstance.addEventListener('phaseChange', this._handlePhaseChange.bind(this));
         this.#gameInstance.addEventListener('playerStatsChanged', this._handlePlayerStatsChanged.bind(this));
         this.#gameInstance.addEventListener('cardDrawn', this._handleCardDrawn.bind(this));
         this.#gameInstance.addEventListener('cardPlayed', this._handleCardPlayed.bind(this));
         this.#gameInstance.addEventListener('cardMoved', this._handleCardMoved.bind(this));
         this.#gameInstance.addEventListener('gameLog', this._handleGameLog.bind(this));
         this.#gameInstance.addEventListener('creatureUpdate', this._handleCreatureUpdate.bind(this));
         this.#gameInstance.addEventListener('damagePrevented', this._handleDamagePrevented.bind(this));
         this.#gameInstance.addEventListener('creatureTookDamage', this._handleCreatureTookDamage.bind(this));
         this.#gameInstance.addEventListener('creatureHealed', this._handleCreatureHealed.bind(this));
         this.#gameInstance.addEventListener('gameOver', this._handleGameOver.bind(this));
         this.#gameInstance.addEventListener('deckEmpty', this._handleDeckEmpty.bind(this));
         this.#gameInstance.addEventListener('discardRequired', this._handleDiscardRequired.bind(this));
         this.#gameInstance.addEventListener('attackPhaseStart', this._handleAttackPhaseStart.bind(this));
         this.#gameInstance.addEventListener('attackersDeclared', this._handleAttackersDeclared.bind(this));
         this.#gameInstance.addEventListener('blockersDeclared', this._handleBlockersDeclared.bind(this));
         this.#gameInstance.addEventListener('combatResolved', this._handleCombatResolved.bind(this));
    }
    bindGameActions() {
        console.log("BattleScreenUI: Binding game action interactions...");
        this.#btnEndTurn.off('click').on('click', this._handleEndTurnClick.bind(this));
        this.#btnPassPhase.off('click').on('click', this._handlePassPhaseClick.bind(this));
        this.#btnDiscardMana.off('click').on('click', this._handleDiscardForManaClick.bind(this));
        this.#btnConfirmAttack.off('click').on('click', this._handleConfirmAttackersClick.bind(this));
        this.#btnConfirmBlocks.off('click').on('click', this._handleConfirmBlockersClick.bind(this));
        this.#playerHandElement.off('click', '.card').on('click', '.card', this._handleHandCardClick.bind(this));
        this.#playerBattlefieldElement.off('click', '.card').on('click', '.card', this._handleBattlefieldCardClick.bind(this));
        this.#opponentBattlefieldElement.off('click', '.card').on('click', '.card', this._handleBattlefieldCardClick.bind(this));
        this.#playerHandElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        this.#playerBattlefieldElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        this.#opponentBattlefieldElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => this.#zoomHandler.handleZoomClick(e, this.#gameInstance));
        // Previne menu de contexto default em qualquer carta na tela
        this.#battleScreenElement.off('contextmenu', '.card').on('contextmenu', '.card', (e) => e.preventDefault());
        // Zoom também pode ser aplicado em deck/cemitério (opcional)
        // $('.deck-zone, .graveyard-zone').off('contextmenu').on('contextmenu', this._handleZoneZoom.bind(this));
        this.#btnBackToProfile.off('click').on('click', () => {
            this.#gameOverOverlayElement.removeClass('active');
            this.#gameInstance = null; // Desvincula a instância do jogo
            // Idealmente, UIManager ou main.js lidaria com a renderização da próxima tela
            // this.#uiManager.renderProfileScreen(); // Exemplo se UIManager fosse passado
            this.#screenManager.showScreen('profile-screen');
        });
    }

    // --- Handlers de Eventos do Jogo ---
    _handleTurnChange(e) { this._updateCurrentPlayerIndicator(); this._updateTurnControls(); }
    _handlePhaseChange(e) { this._updatePhaseIndicator(); this._updateTurnControls(); this._exitCombatModes(); /* Sai dos modos de combate ao mudar de fase */ }
    _handlePlayerStatsChanged(e) { const p = this.#gameInstance?.getPlayer(e.detail.playerId); if (p) this._updatePlayerStats(p); }
    _handleCardDrawn(e) { const { playerId, card } = e.detail; if (playerId === this.#localPlayerId) this._addCardToHandUI(card); else this._updateOpponentHandCount(this.#gameInstance?.getPlayer(playerId)); const player = this.#gameInstance?.getPlayer(playerId); if (player) this._updateDeckDisplay(player); /* Atualiza contagem deck */ }
    _handleCardPlayed(e) { /* Tratado por _handleCardMoved */ }
    _handleCardMoved(e) {
        const { cardUniqueId, cardData, fromZone, toZone, ownerId } = e.detail;
        const isLocal = ownerId === this.#localPlayerId;
        const player = this.#gameInstance?.getPlayer(ownerId); if (!player) return;
        // Remove do DOM antigo
        if (fromZone === 'hand' && isLocal) this.#playerHandElement.find(`.card[data-card-unique-id="${cardUniqueId}"]`).remove();
        else if (fromZone === 'battlefield') $(`#${isLocal ? 'player' : 'opponent'}-battlefield .card[data-card-unique-id="${cardUniqueId}"]`).remove();
        // Adiciona ao DOM novo
        if (toZone === 'hand' && isLocal) this._addCardToHandUI(cardData);
        else if (toZone === 'battlefield') this._addCardToBattlefieldUI(cardData, ownerId);

        // Atualiza contagens E DISPLAYS
        if (['deck'].includes(fromZone) || ['deck'].includes(toZone)) {
            this._updateDeckDisplay(player);
        }
        if (['graveyard'].includes(fromZone) || ['graveyard'].includes(toZone)) {
            this._updateGraveyardDisplay(player); // USA A NOVA FUNÇÃO
        }
        // Atualiza contagem da mão do oponente (se aplicável)
        if ((fromZone === 'hand' || toZone === 'hand') && !isLocal) {
            this._updateOpponentHandCount(player);
        }

        // Atualiza feedback de descarte
        if (fromZone === 'hand' && this.#pendingDiscardCount > 0 && ownerId === this.#localPlayerId) {
            this.#pendingDiscardCount--; // Diminui contador aqui
            if (this.#pendingDiscardCount <= 0) this._exitDiscardRequiredMode();
            else this.#actionFeedbackElement.text(`Mão cheia! Descarte ${this.#pendingDiscardCount} carta(s).`);
        }
    }
    _handleGameLog(e) { this._addLogMessage(e.detail.message, e.detail.type || 'system'); }
    _handleCreatureUpdate(e) { const {cardUniqueId,updates}=e.detail, $c=this.#battleScreenElement.find(`.card[data-card-unique-id="${cardUniqueId}"]`); if(!$c.length)return; if(updates.isTapped!==undefined)$c.toggleClass('tapped',updates.isTapped); if(updates.currentToughness!==undefined)$c.find('.card-toughness').text(updates.currentToughness); if(updates.attack!==undefined)$c.find('.card-attack').text(updates.attack); if(updates.hasSummoningSickness!==undefined)$c.toggleClass('has-summoning-sickness',updates.hasSummoningSickness); if(updates.statusEffects){$c.toggleClass('shielded',!!updates.statusEffects['shielded']);$c.toggleClass('silenced',!!updates.statusEffects['silenced']||!!updates.statusEffects['cant_attack']);} if(updates.canAttack!==undefined)$c.toggleClass('cannot-act',!updates.canAttack); }
    _handleDamagePrevented(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.target.uniqueId}"]`), 'damage-prevented'); }
    _handleCreatureTookDamage(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.creature.uniqueId}"]`), 'damage', e.detail.amount); }
    _handleCreatureHealed(e) { this._showCardFeedback(this.#battleScreenElement.find(`.card[data-card-unique-id="${e.detail.creature.uniqueId}"]`), 'heal', e.detail.amount); }
    _handleCombatResolved(e) { this._clearCombatVisuals(); this._updateTurnControls(); this._exitCombatModes(); this.#actionFeedbackElement.text('Combate resolvido.'); }
    _handleGameOver(e) { const{winnerId,winnerName,loserName}=e.detail, msg=(winnerId===this.#localPlayerId)?`Vitória! Você derrotou ${loserName||'o oponente'}!`:`Derrota! ${winnerName||'O oponente'} venceu!`; this.#gameOverMessageElement.text(msg); this.#gameOverOverlayElement.addClass('active'); this._disableAllGameActions(); }
    _handleDeckEmpty(e) { this._addLogMessage(`${this.#gameInstance?.getPlayer(e.detail.playerId)?.name||'Jogador'} não pode comprar!`, 'warning'); }
    _handleDiscardRequired(e) { const{playerId,count}=e.detail; this.#pendingDiscardCount=count; if(playerId===this.#localPlayerId)this._enterDiscardRequiredMode(count);else this.#actionFeedbackElement.text(`${this.#gameInstance?.getPlayer(playerId)?.name||'Oponente'} precisa descartar ${count}...`); }
    _handleAttackPhaseStart(e) { this._updateTurnControls(); }
    _handleAttackersDeclared(e) { this._clearCombatVisuals(); e.detail.attackers.forEach(a => this.#battleScreenElement.find(`.card[data-card-unique-id="${a.uniqueId}"]`).addClass('attacking')); const aN=e.detail.attackers.map(a=>a.name).join(', ')||'Ninguém'; if(this.#gameInstance?.getCurrentPlayer()?.id!==this.#localPlayerId){this._enterBlockerAssignmentMode();this.#actionFeedbackElement.text(`Declare bloqueadores contra: ${aN}.`);this._addLogMessage(`Oponente ataca com: ${aN}. Bloqueie.`, 'combat');}else{this.#actionFeedbackElement.text('Aguardando bloqueadores...');this._addLogMessage(`Ataque declarado com ${aN}. Aguardando...`,'info');} this._updateTurnControls(); }
    _handleBlockersDeclared(e) { this._clearCombatVisuals(); const att=this.#gameInstance?.getCombatManager()?.getAttackers()||[]; att.forEach(a => this.#battleScreenElement.find(`.card[data-card-unique-id="${a.uniqueId}"]`).addClass('attacking')); e.detail.declaredBlockers?.forEach(b => this.#battleScreenElement.find(`.card[data-card-unique-id="${b.blockerId}"]`).addClass('blocking')); this.#actionFeedbackElement.text('Bloqueadores declarados. Resolvendo...'); this._addLogMessage('Bloqueadores declarados. Resolvendo...', 'combat'); this._updateTurnControls(); }

    // --- Handlers de Ações da UI ---
    _handleEndTurnClick() { if (this._canInteract(true)) this.#gameInstance?.endTurn(); }
    _handlePassPhaseClick() { if (this._canInteract(true)) this.#gameInstance?.passPhase(); }
    _handleDiscardForManaClick() { if (this._canInteract(true) && !this.#btnDiscardMana.prop('disabled')) this._enterDiscardSelectionMode(); }
    _handleHandCardClick(event) {
        const $card = $(event.currentTarget);
        const cId = $card.data('card-unique-id');
        const p = this.#gameInstance?.getPlayer(this.#localPlayerId);
        const cI = p?.hand.getCard(cId);

        if (!cI) return; // Sai se a carta não for encontrada

        if (this.#isSelectingDiscard) {
            p?.discardCardForMana(cId, this.#gameInstance);
            this._exitDiscardSelectionMode();
        } else if (this.#pendingDiscardCount > 0) {
            // ResolvePlayerDiscard já move a carta e emite evento, que vai decrementar o contador
            this.#gameInstance?.resolvePlayerDiscard(this.#localPlayerId, cId);
            // Não chama exitDiscardRequiredMode aqui, espera o evento cardMoved
        } else if (this.#isSelectingTarget) {
            // Cancelar seleção de alvo clicando na carta novamente
             if (this.#actionPendingTarget && this.#actionPendingTarget.cardUniqueId === cId) {
                 this._showCardFeedback($card, 'cancel');
                 this._exitTargetSelectionMode();
            } else {
                this._addLogMessage('Clique em um alvo válido ou ESC para cancelar.', 'warning');
            }
        } else if (this._canInteract(true)) {
            if (cI.canPlay(p, this.#gameInstance)) { // Verifica se pode jogar *antes* de entrar no modo alvo
                if (cI.requiresTarget()) {
                    this._enterTargetSelectionMode({ type: 'playCard', cardUniqueId: cId, targetType: cI.targetType() });
                } else {
                    p?.playCard(cId, null, this.#gameInstance); // Joga carta sem alvo
                }
            } else {
                this._addLogMessage(`Não pode jogar ${cI.name} agora.`, 'warning');
                // Opcional: Mostrar feedback visual na carta
                this._showCardFeedback($card, 'cannot-act');
            }
        }
    }
    _handleBattlefieldCardClick(event) {
        if (!this.#gameInstance) return;
        const $card = $(event.currentTarget);
        const cId = $card.data('card-unique-id');
        const lP = this.#gameInstance.getPlayer(this.#localPlayerId);
        const oP = this.#gameInstance.getOpponent(this.#localPlayerId);
        const cI = lP?.battlefield.getCard(cId) || oP?.battlefield.getCard(cId);

        if (!cI) return; // Sai se a carta não foi encontrada

        const ownerId = cI.ownerId;

        if (this.#isSelectingTarget) {
            if (this._checkIfValidTarget(cI, ownerId, this.#actionPendingTarget)) {
                if (this.#actionPendingTarget?.type === 'playCard') {
                    lP?.playCard(this.#actionPendingTarget.cardUniqueId, cId, this.#gameInstance);
                }
                // Adicione outras ações que precisam de alvo aqui (e.g., habilidades de criaturas)
                this._exitTargetSelectionMode();
            } else {
                this._showCardFeedback($card, 'invalid-target');
                this._addLogMessage('Alvo inválido.', 'warning');
            }
        } else if (this.#isDeclaringAttackers) {
            if (ownerId === this.#localPlayerId && cI instanceof CreatureCard) {
                if (this.#selectedAttackerIds.has(cId)) {
                    this.#selectedAttackerIds.delete(cId);
                    $card.removeClass('selected-attacker');
                } else if (cI.canAttack()) {
                    this.#selectedAttackerIds.add(cId);
                    $card.addClass('selected-attacker');
                } else {
                    this._showCardFeedback($card, 'cannot-act');
                    this._addLogMessage(`${cI.name} não pode atacar.`, 'info');
                }
                this.#btnConfirmAttack.prop('disabled', this.#selectedAttackerIds.size === 0);
            }
        } else if (this.#isAssigningBlockers) {
            // Clicou numa criatura sua (potencial bloqueador)?
            if (ownerId === this.#localPlayerId && cI instanceof CreatureCard && cI.canBlock()) {
                 this.#battleScreenElement.find('.card.selected-blocker').removeClass('selected-blocker');
                 $card.addClass('selected-blocker');
                 this.#selectedBlockerId = cId;
                 this.#actionFeedbackElement.text(`Selecionado: ${cI.name}. Clique no atacante para bloquear.`);
            }
            // Clicou numa criatura oponente (atacante) E um bloqueador seu já está selecionado?
            else if (ownerId !== this.#localPlayerId && this.#selectedBlockerId && this.#gameInstance.getCombatManager().getAttackers().some(att => att.uniqueId === cId)) {
                 this._assignBlocker(cId, this.#selectedBlockerId);
                 this.#battleScreenElement.find('.card.selected-blocker').removeClass('selected-blocker');
                 this.#selectedBlockerId = null; // Limpa seleção do bloqueador
                 this.#actionFeedbackElement.text('Selecione bloqueador, depois atacante.'); // Volta instrução padrão
            }
             // Clicou numa criatura sua que NÃO pode bloquear?
            else if (ownerId === this.#localPlayerId && cI instanceof CreatureCard && !cI.canBlock()) {
                 this._showCardFeedback($card, 'cannot-act');
                 this._addLogMessage(`${cI.name} não pode bloquear.`, 'info');
            }
            // Clicou em outra coisa? Ignora ou limpa seleção do bloqueador
            else if (ownerId === this.#localPlayerId && !(cI instanceof CreatureCard)) {
                // Clicou numa runebinding sua, não faz nada
            } else {
                // Clicou em algo não relevante, talvez limpar seleção?
                // this.#battleScreenElement.find('.card.selected-blocker').removeClass('selected-blocker');
                // this.#selectedBlockerId = null;
                // this.#actionFeedbackElement.text('Selecione bloqueador, depois atacante.');
            }
        }
        // Adicione outras interações (e.g., clicar para ativar habilidade) aqui se necessário
    }
    _handleConfirmAttackersClick() { if (this.#isDeclaringAttackers) { this.#gameInstance?.confirmAttackDeclaration(this.#localPlayerId, [...this.#selectedAttackerIds]); this._exitAttackerDeclarationMode(); } }
    _handleConfirmBlockersClick() { if (this.#isAssigningBlockers) { this.#gameInstance?.confirmBlockDeclaration(this.#localPlayerId, { ...this.#blockerAssignmentsUI }); this._exitBlockerAssignmentMode(); } }

    // --- Métodos de Estado da UI ---
    _resetUIState() { this.#isSelectingDiscard = false; this.#isSelectingTarget = false; this.#actionPendingTarget = null; this.#isDeclaringAttackers = false; this.#selectedAttackerIds.clear(); this.#isAssigningBlockers = false; this.#blockerAssignmentsUI = {}; this.#selectedBlockerId = null; this.#pendingDiscardCount = 0; this._clearCombatVisuals(); this._closeZoomedImage(); this.#actionFeedbackElement.text(''); this.#btnDiscardMana.removeClass('active-selection'); this.#battleScreenElement.find('.card.targetable, .card.selected-attacker, .card.selected-blocker, .card.is-selecting, .card.cannot-act, .card.disabled-interaction').removeClass('targetable selected-attacker selected-blocker is-selecting cannot-act disabled-interaction'); this.#gameOverOverlayElement.removeClass('active'); }
    _canInteract(needsActiveTurn=true){if(!this.#gameInstance||this.#gameInstance.state==='game_over')return false; /* Permitir interação se declarando/bloqueando mesmo fora do turno? Depende das regras */ if(this.#isDeclaringAttackers || this.#isAssigningBlockers) return true; if(this.#isSelectingTarget||this.#isSelectingDiscard||this.#pendingDiscardCount>0)return true; if(needsActiveTurn&&this.#gameInstance.getCurrentPlayer()?.id!==this.#localPlayerId)return false; return true;}
    _enterDiscardRequiredMode(c){this.#pendingDiscardCount=c;this.#actionFeedbackElement.text(`Mão cheia! Descarte ${c} carta(s). Clique na(s) carta(s) a descartar.`);this._disableAllGameActions(true);this.#playerHandElement.find('.card').addClass('targetable');}
    _exitDiscardRequiredMode(){this.#pendingDiscardCount=0;this.#actionFeedbackElement.text('');this.#playerHandElement.find('.card').removeClass('targetable');this._updateTurnControls();}
    _enterDiscardSelectionMode(){this.#isSelectingDiscard=true;this.#actionFeedbackElement.text('Clique na carta para descartar por Mana.');this.#playerHandElement.find('.card').addClass('targetable');this._disableAllGameActions(true);this.#btnDiscardMana.addClass('active-selection');}
    _exitDiscardSelectionMode(){this.#isSelectingDiscard=false;this.#actionFeedbackElement.text('');this.#playerHandElement.find('.card').removeClass('targetable');this.#btnDiscardMana.removeClass('active-selection');this._updateTurnControls();}
    _enterTargetSelectionMode(aI){this.#isSelectingTarget=true;this.#actionPendingTarget=aI;const sC=this.#gameInstance?.findCardInstance(aI.cardUniqueId),cN=sC?.name||'?';this.#actionFeedbackElement.text(`Selecione alvo para ${cN} (ESC cancela)`);this._highlightValidTargets(aI.targetType);this._disableAllGameActions(true);this.#playerHandElement.find(`.card[data-card-unique-id="${aI.cardUniqueId}"]`).addClass('is-selecting');}
    _exitTargetSelectionMode(){this.#isSelectingTarget=false;this.#actionPendingTarget=null;this.#actionFeedbackElement.text('');this.#battleScreenElement.find('.targetable, .is-selecting').removeClass('targetable is-selecting');this._updateTurnControls();}
    _enterAttackerDeclarationMode(){if(!this._canInteract(true))return;this.#isDeclaringAttackers=true;this.#selectedAttackerIds.clear();this.#actionFeedbackElement.text('Selecione atacantes (ESC cancela)');this.#playerBattlefieldElement.find('.card').each((i,el)=>{const $c=$(el),cI=this.#gameInstance?.getPlayer(this.#localPlayerId)?.battlefield.getCard($c.data('card-unique-id'));if(cI instanceof CreatureCard&&cI.canAttack())$c.addClass('targetable');else $c.addClass('cannot-act');});this.#btnConfirmAttack.text('Confirmar Ataque').off('click').on('click',this._handleConfirmAttackersClick.bind(this)).show().prop('disabled',true);this.#btnPassPhase.prop('disabled',true);this.#btnEndTurn.prop('disabled',true);this.#btnDiscardMana.prop('disabled',true);}
    _exitAttackerDeclarationMode(){this.#isDeclaringAttackers=false;this.#selectedAttackerIds.clear();this.#actionFeedbackElement.text('');this.#battleScreenElement.find('.targetable, .selected-attacker, .cannot-act').removeClass('targetable selected-attacker cannot-act');this.#btnConfirmAttack.hide().prop('disabled',true);this._updateTurnControls();}
    _enterBlockerAssignmentMode(){if(this.#gameInstance?.getCurrentPlayer()?.id===this.#localPlayerId)return;this.#isAssigningBlockers=true;this.#blockerAssignmentsUI={};this.#selectedBlockerId=null;this.#actionFeedbackElement.text('Selecione bloqueador, depois o atacante (ESC cancela)');this.#playerBattlefieldElement.find('.card').each((i,el)=>{const $c=$(el),cI=this.#gameInstance?.getPlayer(this.#localPlayerId)?.battlefield.getCard($c.data('card-unique-id'));if(cI instanceof CreatureCard&&cI.canBlock())$c.addClass('targetable');else $c.addClass('cannot-act');});const att=this.#gameInstance?.getCombatManager()?.getAttackers()||[];att.forEach(a => this.#battleScreenElement.find(`.card[data-card-unique-id="${a.uniqueId}"]`).addClass('targetable-attacker')); /* Highlight attackers */ this.#btnConfirmBlocks.show().prop('disabled',false);this.#btnPassPhase.prop('disabled',true);this.#btnEndTurn.prop('disabled',true);this.#btnDiscardMana.prop('disabled',true);}
    _exitBlockerAssignmentMode(){this.#isAssigningBlockers=false;this.#blockerAssignmentsUI={};this.#selectedBlockerId=null;this.#actionFeedbackElement.text('');this.#battleScreenElement.find('.targetable, .selected-blocker, .blocking, .cannot-act, .targetable-attacker').removeClass('targetable selected-blocker blocking cannot-act targetable-attacker');this.#btnConfirmBlocks.hide().prop('disabled',true);this._updateTurnControls();}
    _exitCombatModes(){if(this.#isDeclaringAttackers)this._exitAttackerDeclarationMode();if(this.#isAssigningBlockers)this._exitBlockerAssignmentMode();}
    _clearCombatVisuals(){this.#battleScreenElement.find('.card.attacking, .card.blocking, .card.selected-attacker, .card.selected-blocker').removeClass('attacking blocking selected-attacker selected-blocker');}
    _assignBlocker(aId,bId){if(!this.#blockerAssignmentsUI[aId])this.#blockerAssignmentsUI[aId]=[];if(!this.#blockerAssignmentsUI[aId].includes(bId)){this.#blockerAssignmentsUI[aId].push(bId);this._updateBlockerAssignmentVisuals();const bN=this.#battleScreenElement.find(`.card[data-card-unique-id="${bId}"]`).data('card-name')||'?';const aN=this.#battleScreenElement.find(`.card[data-card-unique-id="${aId}"]`).data('card-name')||'?';this._addLogMessage(`${bN} bloqueando ${aN}`, 'info');} else { /* Opcional: Desatribuir se clicar novamente? */ }}
    _updateBlockerAssignmentVisuals(){this.#battleScreenElement.find('.card.blocking').removeClass('blocking');for(const aId in this.#blockerAssignmentsUI){this.#blockerAssignmentsUI[aId].forEach(bId=>{this.#battleScreenElement.find(`.card[data-card-unique-id="${bId}"]`).addClass('blocking');});}}
    _highlightValidTargets(tT){this.#battleScreenElement.find('.targetable').removeClass('targetable');if(!this.#gameInstance||!this.#localPlayerId)return;const lP=this.#gameInstance.getPlayer(this.#localPlayerId),oP=this.#gameInstance.getOpponent(this.#localPlayerId);let sel='';switch(tT){case'creature':sel='#player-battlefield .card, #opponent-battlefield .card';break;case'opponent_creature':sel='#opponent-battlefield .card';break;case'own_creature':sel='#player-battlefield .card';break;case'player':this.#playerAvatarElement.closest('.player-info').add(this.#opponentAvatarElement.closest('.player-info')).addClass('targetable');return;case'opponent_player':this.#opponentAvatarElement.closest('.player-info').addClass('targetable');return;case'runebinding':sel='#player-battlefield .card, #opponent-battlefield .card';break; /* Precisa refinar */ default:return;} $(sel).each((i,el)=>{const $c=$(el),cUId=$c.data('card-unique-id'); if (!cUId) return; const cI=lP?.battlefield.getCard(cUId)||oP?.battlefield.getCard(cUId); if (!cI) return; if(tT.includes('creature')&&!(cI instanceof CreatureCard)) return; if(tT.includes('runebinding')&&!(cI instanceof RunebindingCard)) return; /* Adicione mais checks se necessário */ $c.addClass('targetable');});}
    _checkIfValidTarget(tI, tOId, aI) {
        if (!tI || !aI) return false;
        const rT = aI.targetType;
    
        /* Check for Player target */
        if (rT === 'player' || rT === 'opponent_player') {
          const targetInfoDiv = $(event.target).closest('.player-info');
          if (!targetInfoDiv.length) return false;
          const isOpponentTarget = targetInfoDiv.parent().hasClass('opponent');
          if (rT === 'opponent_player' && !isOpponentTarget) return false;
          if (rT === 'player') {
            // Need to determine how to reliably check if 'tI' is NOT a player object.
            // Assuming you have a 'Player' class or a specific property to identify players.
    
            // Example using instanceof (if 'Player' is a class):
            if (tI instanceof Player) {
              // 'tI' is a Player object, which might not be the intended target.
              return true; // Or potentially false based on your game logic.
            }
            // Example using a property (if player objects have a specific property, e.g., 'isPlayer'):
            if (tI && tI.isPlayer) {
              return true; // Or potentially false.
            }
            // If you want to ensure it's *not* a player, you would adjust the condition:
            // if (!(tI instanceof Player)) { ... }
    
            // For now, if 'rT' is 'player' and we reach here, it implies a click in the player area
            // but 'tI' is not explicitly identified as a player object. Depending on your game,
            // you might want to refine this check further.
            return true; // Assume valid for now if player area clicked and 'tI' check is inconclusive.
          }
          return true; // Assume valid for now if player area clicked and is opponent if needed.
        }
    
        /* Check Card types */
        if (rT.includes('creature') && !(tI instanceof CreatureCard)) return false;
        if (rT.includes('runebinding') && !(tI instanceof RunebindingCard)) return false;
    
        /* Check Ownership */
        if (rT === 'opponent_creature' && tOId === this.#localPlayerId) return false;
        if (rT === 'own_creature' && tOId !== this.#localPlayerId) return false;
    
        return true;
      }
    
      _showCardFeedback($cE, fT, v = '') {
        if (!$cE || !$cE.length) return;
        $cE.find('.card-feedback').remove();
        let fC = '',
          cC = '';
        switch (fT) {
          case 'damage':
            fC = `-${v}`;
            cC = 'feedback-damage';
            break;
          case 'heal':
            fC = `+${v}`;
            cC = 'feedback-heal';
            break;
          case 'buff':
            fC = `+${v}`;
            cC = 'feedback-buff';
            break;
          case 'debuff':
            fC = `-${v}`;
            cC = 'feedback-debuff';
            break;
          case 'damage-prevented':
            fC = '🛡️';
            cC = 'feedback-shield';
            break;
          case 'invalid-target':
            fC = '❌';
            cC = 'feedback-invalid';
            break;
          case 'cannot-act':
            fC = '🚫';
            cC = 'feedback-invalid';
            break;
          case 'cancel':
            fC = '↩️';
            cC = 'feedback-cancel';
            break;
          default:
            return;
        }
        const $f = $(`<div class="card-feedback ${cC}">${fC}</div>`);
        $cE.append($f);
        $f.fadeIn(100)
          .delay(800)
          .fadeOut(400, function() {
            $(this).remove();
          });
      }
    _showCardFeedback($cE, fT, v = ''){if(!$cE||!$cE.length)return;$cE.find('.card-feedback').remove();let fC='',cC='';switch(fT){case'damage':fC=`-${v}`;cC='feedback-damage';break;case'heal':fC=`+${v}`;cC='feedback-heal';break;case'buff':fC=`+${v}`;cC='feedback-buff';break;case'debuff':fC=`-${v}`;cC='feedback-debuff';break;case'damage-prevented':fC='🛡️';cC='feedback-shield';break;case'invalid-target':fC='❌';cC='feedback-invalid';break;case'cannot-act':fC='🚫';cC='feedback-invalid';break;case'cancel':fC='↩️';cC='feedback-cancel';break;default:return;}const $f=$(`<div class="card-feedback ${cC}">${fC}</div>`);$cE.append($f);$f.fadeIn(100).delay(800).fadeOut(400,function(){$(this).remove();});}
    _disableAllGameActions(allowTargetables=false){this.#btnEndTurn.add(this.#btnPassPhase).add(this.#btnDiscardMana).add(this.#btnConfirmAttack).add(this.#btnConfirmBlocks).prop('disabled',true); if (!allowTargetables) { this.#battleScreenElement.find('.card').addClass('disabled-interaction'); } else { this.#battleScreenElement.find('.card:not(.targetable)').addClass('disabled-interaction'); this.#battleScreenElement.find('.card.targetable').removeClass('disabled-interaction'); } }
    _closeZoomedImage() { this.#zoomHandler.closeZoom(); }

    // --- Métodos de Renderização da UI ---
    _clearUI() { this.#playerHandElement.empty(); this.#playerBattlefieldElement.empty(); this.#opponentHandElement.empty(); this.#opponentBattlefieldElement.empty(); this.#gameLogElement.empty().append('<li>Partida Iniciada!</li>'); this.#actionFeedbackElement.text(''); this.#gameOverOverlayElement.removeClass('active'); }
    _renderPlayerInfo(player, isLocal) { const prefix = isLocal ? '#player' : '#opponent'; const data = player.getRenderData(); $(`${prefix}-name`).text(data.name); $(`${prefix}-life`).text(data.life); $(`${prefix}-mana`).text(data.mana); $(`${prefix}-max-mana`).text(data.maxMana); const avatarEl = isLocal ? this.#playerAvatarElement : this.#opponentAvatarElement; let avatarFile = 'default.png'; if (isLocal) { avatarFile = this.#accountManager?.getCurrentUser()?.avatar || 'default.png'; } /* else { // TODO: Get opponent avatar from network/game data if available } */ avatarEl.attr('src', `assets/images/avatars/${avatarFile}`); }
    _addCardToHandUI(cD) { const $c = this.#cardRenderer.renderCard(cD, 'hand'); if ($c) { this.#playerHandElement.append($c); $c.addClass('animate-add-hand'); setTimeout(() => $c.removeClass('animate-add-hand'), 500); } }
    _renderPlayerHand(p) { this.#playerHandElement.empty(); p.hand.getCards().forEach(c => { const $c = this.#cardRenderer.renderCard(c.getRenderData(), 'hand'); if ($c) this.#playerHandElement.append($c); }); }
    _renderOpponentHand(o) { const $h = this.#opponentHandElement.empty(), hS = o.hand.getSize(); this.#opponentHandCountElement.text(hS); for (let i = 0; i < hS; i++) $h.append('<div class="card-back"></div>'); }
    _updateOpponentHandCount(o) { this._renderOpponentHand(o); }
    _addCardToBattlefieldUI(cD, oId) { const $c = this.#cardRenderer.renderCard(cD, 'battlefield'); if ($c) { const tF = (oId === this.#localPlayerId) ? this.#playerBattlefieldElement : this.#opponentBattlefieldElement; tF.append($c); $c.addClass('animate-enter-battlefield'); setTimeout(() => $c.removeClass('animate-enter-battlefield'), 500); } }
    _updatePlayerStats(p) { this._renderPlayerInfo(p, p.id === this.#localPlayerId); } // Reusa render info
    _updatePhaseIndicator() { const phase = this.#gameInstance?.getCurrentPhase() || ''; this.#phaseIndicatorElement.text(phase.charAt(0).toUpperCase() + phase.slice(1)); }
    _updateCurrentPlayerIndicator() { const name = this.#gameInstance?.getCurrentPlayer()?.name || '...?'; this.#currentPlayerIndicatorElement.text(name); $('body').toggleClass('player-turn', this.#gameInstance?.getCurrentPlayer()?.id === this.#localPlayerId).toggleClass('opponent-turn', this.#gameInstance?.getCurrentPlayer()?.id !== this.#localPlayerId); }
    _updateTurnControls() {
        if (!this.#gameInstance || this.#gameInstance.state === 'game_over') { this._disableAllGameActions(); this.#btnConfirmAttack.hide(); this.#btnConfirmBlocks.hide(); return; }
        const isMyTurn = this.#gameInstance.getCurrentPlayer()?.id === this.#localPlayerId;
        const currentPhase = this.#gameInstance.getCurrentPhase();
        const player = this.#gameInstance.getPlayer(this.#localPlayerId);
        const canAttackThisTurn = player?.battlefield.getCreatures().some(c => c.canAttack()); // Verifica se HÁ alguma criatura que PODE atacar
        const baseDisabled = !isMyTurn || this.#isSelectingTarget || this.#isSelectingDiscard || this.#pendingDiscardCount > 0 || this.#isDeclaringAttackers || this.#isAssigningBlockers;
        const canDiscard = player && !player.hasDiscardedForMana && currentPhase === 'main' && player.maxMana < 10;

        this.#btnEndTurn.prop('disabled', baseDisabled);
        this.#btnPassPhase.prop('disabled', baseDisabled);
        this.#btnDiscardMana.prop('disabled', baseDisabled || !canDiscard);

        // Reset buttons visibility/state initially
        this.#btnConfirmAttack.hide().prop('disabled', true);
        this.#btnConfirmBlocks.hide().prop('disabled', true);
        this.#btnConfirmAttack.text('Confirmar Ataque'); // Default text

        // Show specific buttons based on state/phase
        if (isMyTurn && currentPhase === 'attack' && !this.#isDeclaringAttackers && !this.#isAssigningBlockers) {
            this.#btnConfirmAttack.text('Declarar Atacantes').off('click').on('click', this._enterAttackerDeclarationMode.bind(this)).show().prop('disabled', !canAttackThisTurn);
        } else if (this.#isDeclaringAttackers) {
             this.#btnConfirmAttack.text('Confirmar Ataque').off('click').on('click', this._handleConfirmAttackersClick.bind(this)).show().prop('disabled', this.#selectedAttackerIds.size === 0);
        } else if (this.#isAssigningBlockers) { // This state is usually for the opponent, but maybe UI shows button for local player too?
             // Assuming the button is for the local player when it's OPPONENT'S attack phase
             if (!isMyTurn && this.#gameInstance.getCombatManager().state === 'declare_blockers') {
                 this.#btnConfirmBlocks.show().prop('disabled', false); // Enable confirm blocks button
             }
        }

        // Re-evaluate card interactability
        if (!this.#isSelectingTarget && !this.#isSelectingDiscard && this.#pendingDiscardCount === 0 && !this.#isDeclaringAttackers && !this.#isAssigningBlockers) {
            this.#battleScreenElement.find('.disabled-interaction').removeClass('disabled-interaction');
        } else {
            // If in a selection mode, disable non-targetable cards
            this.#battleScreenElement.find('.card:not(.targetable, .targetable-attacker)').addClass('disabled-interaction');
            this.#battleScreenElement.find('.targetable, .targetable-attacker').removeClass('disabled-interaction');
        }
    }
    _addLogMessage(m, t = 'info') { if (!m) return; const $l = this.#gameLogElement, $li = $(`<li></li>`).addClass(`log-${t}`).text(m); $l.append($li); if (this.#gameLogContainerElement.length) this.#gameLogContainerElement.scrollTop(this.#gameLogContainerElement[0].scrollHeight); }
    _updateDeckDisplay(player) { if (!player) return; const isLocal = player.id === this.#localPlayerId; const deckSize = player.deck.getSize(); const countElement = isLocal ? this.#playerDeckCountElement : this.#opponentDeckCountElement; const imgElement = isLocal ? this.#playerDeckImgElement : this.#opponentDeckImgElement; countElement.text(deckSize); /* imgElement.toggle(deckSize > 0); // Optional: hide image if 0 */ }
    _updateGraveyardDisplay(player) { if (!player) return; const isLocal = player.id === this.#localPlayerId; const graveyard = player.graveyard; const graveyardSize = graveyard.getSize(); const countElement = isLocal ? this.#playerGraveyardCountElement : this.#opponentGraveyardCountElement; const imgElement = isLocal ? this.#playerGraveyardImgElement : this.#opponentGraveyardImgElement; countElement.text(graveyardSize); if (graveyardSize === 0) { imgElement.attr('src', this.#graveyardPlaceholderSrc).attr('alt', isLocal ? 'Seu Cemitério (Vazio)' : 'Cemitério Oponente (Vazio)').addClass('is-placeholder'); } else { const graveyardCards = graveyard.getCards(); const topCard = graveyardCards[graveyardCards.length - 1]; if (topCard) { const topCardData = topCard.getRenderData(); const imageSrc = topCardData.imageSrc || 'assets/images/cards/default.png'; imgElement.attr('src', imageSrc).attr('alt', `Topo Cemitério: ${topCardData.name}`).removeClass('is-placeholder'); } else { imgElement.attr('src', this.#graveyardPlaceholderSrc).attr('alt', isLocal ? 'Seu Cemitério (Erro)' : 'Cemitério Oponente (Erro)').addClass('is-placeholder'); console.warn(`_updateGraveyardDisplay: Graveyard size ${graveyardSize} but failed to get top card for player ${player.id}`); } } }

    _cacheSelectors() {
        this.#battleScreenElement = $('#battle-screen');
        if (!this.#battleScreenElement.length) { console.error("BattleScreenUI CacheSelectors Error: #battle-screen not found during caching."); return; }
        this.#playerHandElement = this.#battleScreenElement.find('#player-hand');
        this.#playerBattlefieldElement = this.#battleScreenElement.find('#player-battlefield');
        this.#playerDeckCountElement = this.#battleScreenElement.find('#player-deck-count');
        this.#playerGraveyardCountElement = this.#battleScreenElement.find('#player-graveyard-count');
        this.#playerLifeElement = this.#battleScreenElement.find('#player-life');
        this.#playerManaElement = this.#battleScreenElement.find('#player-mana');
        this.#playerMaxManaElement = this.#battleScreenElement.find('#player-max-mana');
        this.#playerNameElement = this.#battleScreenElement.find('#player-name');
        this.#playerAvatarElement = this.#battleScreenElement.find('#player-avatar-img');
        this.#playerDeckImgElement = this.#battleScreenElement.find('#player-deck-img');
        this.#playerGraveyardImgElement = this.#battleScreenElement.find('#player-graveyard-img');
        this.#opponentHandElement = this.#battleScreenElement.find('#opponent-hand');
        this.#opponentBattlefieldElement = this.#battleScreenElement.find('#opponent-battlefield');
        this.#opponentDeckCountElement = this.#battleScreenElement.find('#opponent-deck-count');
        this.#opponentGraveyardCountElement = this.#battleScreenElement.find('#opponent-graveyard-count');
        this.#opponentLifeElement = this.#battleScreenElement.find('#opponent-life');
        this.#opponentManaElement = this.#battleScreenElement.find('#opponent-mana');
        this.#opponentMaxManaElement = this.#battleScreenElement.find('#opponent-max-mana');
        this.#opponentNameElement = this.#battleScreenElement.find('#opponent-name');
        this.#opponentAvatarElement = this.#battleScreenElement.find('#opponent-avatar-img');
        this.#opponentHandCountElement = this.#battleScreenElement.find('#opponent-hand-count');
        this.#opponentDeckImgElement = this.#battleScreenElement.find('#opponent-deck-img');
        this.#opponentGraveyardImgElement = this.#battleScreenElement.find('#opponent-graveyard-img');
        this.#gameLogElement = this.#battleScreenElement.find('#game-log');
        this.#gameLogContainerElement = this.#battleScreenElement.find('.game-log-container');
        this.#turnNumberElement = this.#battleScreenElement.find('#turn-number');
        this.#phaseIndicatorElement = this.#battleScreenElement.find('#phase-indicator');
        this.#currentPlayerIndicatorElement = this.#battleScreenElement.find('#current-player-indicator');
        this.#actionFeedbackElement = this.#battleScreenElement.find('#action-feedback');
        this.#gameOverOverlayElement = this.#battleScreenElement.find('#game-over-overlay');
        this.#gameOverMessageElement = this.#battleScreenElement.find('#game-over-message');
        this.#btnBackToProfile = this.#battleScreenElement.find('#btn-back-to-profile');
        this.#btnEndTurn = this.#battleScreenElement.find('#btn-end-turn');
        this.#btnPassPhase = this.#battleScreenElement.find('#btn-pass-phase');
        this.#btnDiscardMana = this.#battleScreenElement.find('#btn-discard-mana');
        this.#btnConfirmAttack = this.#battleScreenElement.find('#btn-confirm-attack');
        this.#btnConfirmBlocks = this.#battleScreenElement.find('#btn-confirm-blocks');
        console.log("BattleScreenUI: Selectors cached.");
    }

} // End class BattleScreenUI
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\BattleScreenUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckBuilderUI.js ---
// js/ui/screens/DeckBuilderUI.js

// Importar dependências (presumindo que CardRenderer e ZoomHandler estão em ../helpers/)
import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';
// Assume que SortableJS está disponível globalmente (via CDN) ou importado

export default class DeckBuilderUI {
    // --- Referências Injetadas ---
    #screenManager;
    #accountManager;
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;

    // --- Elementos da UI (Cache) ---
    #deckBuilderScreenElement;
    #collectionListElement;
    #deckListElement;
    #deckNameInput;
    #deckCountDisplay; // Para o contador no painel direito
    #deckCountTop;     // Para o contador na barra superior
    #deckValiditySpan;
    #saveButton;
    #messageParagraph;
    #titleElement;
    #collectionCountSpan;

    // --- Estado Interno ---
    #dbState = {
        currentDeckId: null,
        currentDeckName: '',
        currentDeckCards: [],
        isEditing: false,
        MAX_COPIES_PER_CARD: 4
    };

    // --- SortableJS Instances ---
    #collectionSortable = null;
    #deckSortable = null;

    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer;
        this.#zoomHandler = zoomHandler;

        // Cache dos seletores principais
        this.#deckBuilderScreenElement = $('#deck-builder-screen');
        if (!this.#deckBuilderScreenElement.length) {
            console.error("DeckBuilderUI Error: Element #deck-builder-screen not found!");
            return;
        }
        this.#collectionListElement = this.#deckBuilderScreenElement.find('#db-available-cards')[0]; // Precisa do elemento DOM para Sortable
        this.#deckListElement = this.#deckBuilderScreenElement.find('#db-current-deck')[0];     // Precisa do elemento DOM para Sortable
        this.#deckNameInput = this.#deckBuilderScreenElement.find('#db-deck-name');
        this.#deckCountDisplay = this.#deckBuilderScreenElement.find('#db-deck-count-display'); // No painel direito
        this.#deckCountTop = this.#deckBuilderScreenElement.find('#db-deck-count'); // Na barra superior
        this.#deckValiditySpan = this.#deckBuilderScreenElement.find('#db-deck-validity');
        this.#saveButton = this.#deckBuilderScreenElement.find('#btn-save-deck');
        this.#messageParagraph = this.#deckBuilderScreenElement.find('#deck-builder-message');
        this.#titleElement = this.#deckBuilderScreenElement.find('#deck-builder-title');
        this.#collectionCountSpan = this.#deckBuilderScreenElement.find('#db-collection-count');


        this._bindEvents(); // Vincula eventos da tela uma vez
        console.log("DeckBuilderUI initialized.");
    }

    /**
     * Renderiza a tela do Deck Builder, carregando um deck existente ou preparando para um novo.
     * @param {string | null} [deckIdToEdit=null] - O ID do deck a ser editado, ou null para criar um novo.
     */
    render(deckIdToEdit = null) {
        console.log(`DeckBuilderUI: Rendering screen. Edit ID: ${deckIdToEdit}`);
        this._resetState(); // Limpa o estado anterior

        const currentUser = this.#accountManager.getCurrentUser();
        const collection = this.#accountManager.getCollection();

        if (!currentUser || !Array.isArray(collection)) {
            console.error("DeckBuilderUI Error: Cannot render - User/collection invalid.");
            this.#screenManager.showScreen('profile-screen');
            alert("Erro ao carregar coleção do usuário para o Deck Builder.");
            return;
        }

        if (deckIdToEdit) {
            this._loadDeckForEditing(deckIdToEdit, collection);
        } else {
            this.#titleElement.text('Criar Novo Deck');
            this.#deckNameInput.val('');
        }

        this._populateFilters(collection);
        this._renderCollectionPanel(collection); // Renderiza coleção e inicializa Sortable
        this._renderDeckPanel();                 // Renderiza o painel do deck (vazio ou carregado)
        this._updateDeckValidity();              // Atualiza a validade inicial

        console.log("DeckBuilderUI: Render complete.");
    }

    /** Vincula eventos específicos da tela do Deck Builder */
    _bindEvents() {
        console.log("DeckBuilderUI: Binding events...");

        // Botões
        this.#deckBuilderScreenElement.on('click', '#btn-save-deck', this._handleSaveDeck.bind(this));
        this.#deckBuilderScreenElement.on('click', '#btn-clear-deck', this._handleClearDeck.bind(this));
        this.#deckBuilderScreenElement.on('click', '#btn-deck-builder-back', this._handleBackButton.bind(this));

        // Filtros
        this.#deckBuilderScreenElement.on('input', '#db-filter-name', this._handleFilterChange.bind(this));
        this.#deckBuilderScreenElement.on('change', '#db-filter-type, #db-filter-cost, #db-filter-tribe', this._handleFilterChange.bind(this));

        // Input Nome do Deck
        this.#deckBuilderScreenElement.on('input', '#db-deck-name', this._handleDeckNameInput.bind(this));

        // Zoom de Cartas (usando o ZoomHandler injetado)
        this.#deckBuilderScreenElement.on('contextmenu', '#db-available-cards .mini-card', (event) => {
            this.#zoomHandler.handleZoomClick(event); // Delega ao handler
        });
         this.#deckBuilderScreenElement.on('contextmenu', '#db-current-deck .mini-card', (event) => {
            this.#zoomHandler.handleZoomClick(event); // Delega ao handler
        });
        // Prevenir menu contexto default
        this.#deckBuilderScreenElement.on('contextmenu', '.mini-card', (e) => e.preventDefault());

        // Fechar overlay de zoom específico do Deck Builder
        $('#deckbuilder-image-zoom-overlay').off('click.dbzoom').on('click.dbzoom', (event) => {
            if (event.target === event.currentTarget) {
                this.#zoomHandler.closeZoom(); // Delega ao handler
            }
        });
    }

    // --- Métodos de Lógica e Estado Interno ---

    _resetState() {
        this.#dbState = {
            currentDeckId: null,
            currentDeckName: '',
            currentDeckCards: [],
            isEditing: false,
            MAX_COPIES_PER_CARD: 4
        };
        this.#messageParagraph.text(''); // Limpa mensagens
        console.log("DeckBuilderUI: State reset.");
    }

    _loadDeckForEditing(deckId, collection) {
        const decks = this.#accountManager.loadDecks();
        const deckToLoad = decks?.[deckId];
        if (deckToLoad) {
            this.#dbState.currentDeckId = deckId;
            this.#dbState.currentDeckName = deckToLoad.name;
            this.#dbState.currentDeckCards = deckToLoad.cards.filter(cardId => collection.includes(cardId));
            if (this.#dbState.currentDeckCards.length !== deckToLoad.cards.length) {
                 this.#messageParagraph.text('Algumas cartas salvas não estão na sua coleção e foram removidas.').css('color', 'orange');
            }
            this.#dbState.isEditing = true;
            this.#titleElement.text(`Editando: ${deckToLoad.name}`);
            this.#deckNameInput.val(deckToLoad.name);
            console.log(`DeckBuilderUI: Loaded deck '${deckToLoad.name}' for editing.`);
        } else {
            console.warn(`DeckBuilderUI: Deck ID ${deckId} not found for editing.`);
            this.#titleElement.text('Criar Novo Deck');
            this.#deckNameInput.val('');
        }
    }

    _addCardToDeck(cardId) {
        if (!cardId) return false;
        const currentCountInDeck = this.#dbState.currentDeckCards.filter(id => id === cardId).length;
        const cardName = this.#cardDatabase[cardId]?.name || cardId;

        if (currentCountInDeck >= this.#dbState.MAX_COPIES_PER_CARD) {
            this._showMessage(`Máx ${this.#dbState.MAX_COPIES_PER_CARD} de "${cardName}".`, 'orange');
            return false;
        }
        if (this.#dbState.currentDeckCards.length >= 40) {
            this._showMessage('Máx 40 cartas.', 'orange');
            return false;
        }

        this.#dbState.currentDeckCards.push(cardId);
        console.log(`DeckBuilderUI State: Added ${cardId}. New count: ${this.#dbState.currentDeckCards.length}`);
        this._updateDeckValidity();
        this._showMessage(''); // Clear message
        return true;
    }

    _removeCardFromDeck(cardId) {
        if (!cardId) return false;
        const initialLength = this.#dbState.currentDeckCards.length;
        const index = this.#dbState.currentDeckCards.indexOf(cardId);
        console.log(`_removeCardFromDeck: Trying to remove ${cardId}. Index: ${index}`);
    
        if (index > -1) {
            this.#dbState.currentDeckCards.splice(index, 1);
             if (this.#dbState.currentDeckCards.length < initialLength) {
                  console.log(`DeckBuilderUI State: OK removed ${cardId}. New count: ${this.#dbState.currentDeckCards.length}`);
                  this._updateDeckValidity(); // Atualiza a UI após remover do estado
                  return true;
             } else { console.error(`DeckBuilderUI State: Error splicing ${cardId}?`); return false; }
        }
        console.warn("DeckBuilderUI State: ID not found, cannot remove:", cardId);
        return false;
    }
    
    _updateDeckValidity() {
        const count = this.#dbState.currentDeckCards.length;
        const min = 30; const max = 40;
        const isValid = count >= min && count <= max;
        const deckName = this.#deckNameInput.val().trim();

        // Atualiza ambos os contadores
        this.#deckCountDisplay.text(count);
        this.#deckCountTop.text(count);

        if (isValid) {
            this.#deckValiditySpan.text('(Válido)').css('color', 'var(--valid-color)');
        } else if (count < min) {
            this.#deckValiditySpan.text(`(Mín ${min})`).css('color', 'var(--invalid-color)');
        } else {
            this.#deckValiditySpan.text(`(Máx ${max})`).css('color', 'var(--invalid-color)');
        }
        this.#saveButton.prop('disabled', !isValid || !deckName);
    }

    _showMessage(text, color = 'lightblue', duration = 3000) {
         this.#messageParagraph.text(text).css('color', `var(--${color}-color, ${color})`); // Usa variável CSS ou cor direta
         if (duration > 0) {
             setTimeout(() => {
                 if (this.#messageParagraph.text() === text) { // Só limpa se a mensagem ainda for a mesma
                     this.#messageParagraph.text('');
                 }
             }, duration);
         }
     }

    // --- Handlers de Eventos ---

    _handleSaveDeck() {
        const deckName = this.#deckNameInput.val().trim();
        if (!deckName) { this._showMessage('Dê um nome ao deck.', 'orange'); return; }
        const cardIds = this.#dbState.currentDeckCards;
        if (!this.#saveButton.prop('disabled')) { // Verifica se o botão está habilitado (indica validade)
            const deckId = this.#dbState.isEditing && this.#dbState.currentDeckId ? this.#dbState.currentDeckId : `deck_${Date.now()}`;
            const result = this.#accountManager.saveDeck(deckId, deckName, cardIds);
            this._showMessage(result.message, result.success ? 'success' : 'error');
            if (result.success) {
                 this.#dbState.isEditing = true; this.#dbState.currentDeckId = deckId;
                 this.#titleElement.text(`Editando: ${deckName}`);
                 // Não volta automaticamente, permite continuar editando
            }
        } else {
             this._showMessage('Deck inválido ou sem nome.', 'orange');
        }
     }

    _handleClearDeck() {
        if (confirm('Limpar deck atual? Isso removerá todas as cartas.')) {
            this.#dbState.currentDeckCards = [];
            this._renderDeckPanel(); // Re-renderiza o painel do deck (vazio)
            this._initializeSortables(); // Re-inicializa para garantir que o alvo de drop funcione
            this._showMessage('Deck limpo.', 'lightblue');
        }
    }

    _handleFilterChange() {
        this._renderCollectionPanel(this.#accountManager.getCollection() || []);
        // Sortable é re-inicializado dentro de _renderCollectionPanel
    }

    _handleDeckNameInput() {
        this.#dbState.currentDeckName = this.#deckNameInput.val();
        this._updateDeckValidity(); // Valida se o botão save deve ser habilitado
    }

    _handleBackButton() {
         this.#screenManager.showScreen('profile-screen');
         // O ProfileScreenUI.render() será chamado pelo UIManager ou main.js ao navegar para lá
    }

    // --- Métodos de Renderização Privados ---

    _populateFilters(collectionIds) {
        const $costFilter = this.#deckBuilderScreenElement.find('#db-filter-cost');
        const $tribeFilter = this.#deckBuilderScreenElement.find('#db-filter-tribe');
        $costFilter.children('option:not(:first-child)').remove();
        $tribeFilter.children('option:not(:first-child)').remove();
        const costs = new Set(), tribes = new Set();
        collectionIds.forEach(id => { const cd = this.#cardDatabase[id]; if(cd) { costs.add(cd.cost >= 7 ? '7+' : cd.cost.toString()); if (cd.tribe && cd.tribe !== 'None') tribes.add(cd.tribe); }});
        [...costs].sort((a, b) => (a === '7+' ? Infinity : parseInt(a)) - (b === '7+' ? Infinity : parseInt(b))).forEach(c => $costFilter.append(`<option value="${c}">${c}</option>`));
        [...tribes].sort().forEach(t => $tribeFilter.append(`<option value="${t}">${t}</option>`));
    }

    _renderCollectionPanel(collectionIds) {
        const $container = $(this.#collectionListElement).empty(); // Usa o elemento DOM cacheado
        this.#collectionCountSpan.text(collectionIds?.length || 0);

        if (!Array.isArray(collectionIds)) { $container.append('<p class="placeholder-message">Erro coleção.</p>'); return; }

        const fN = this.#deckBuilderScreenElement.find('#db-filter-name').val().toLowerCase();
        const fT = this.#deckBuilderScreenElement.find('#db-filter-type').val();
        const fC = this.#deckBuilderScreenElement.find('#db-filter-cost').val();
        const fR = this.#deckBuilderScreenElement.find('#db-filter-tribe').val();
        let cardsRendered = 0;

        collectionIds.forEach(id => {
            const cd = this.#cardDatabase[id];
            if (cd) {
                if (fN && !cd.name.toLowerCase().includes(fN)) return;
                if (fT && cd.type !== fT) return;
                if (fC) { if (fC === '7+' && cd.cost < 7) return; if (fC !== '7+' && cd.cost != fC) return; }
                if (fR && (cd.tribe || 'None') !== fR) return;
                const $mc = this.#cardRenderer.renderMiniCard(cd, 'collection'); // Usa o helper
                if ($mc) { $container.append($mc); cardsRendered++; }
            }
        });

        if (cardsRendered === 0 && collectionIds.length > 0) $container.append('<p class="placeholder-message">(Nenhuma carta corresponde)</p>');
        else if (collectionIds.length === 0) $container.append('<p class="placeholder-message">(Coleção vazia)</p>');

        console.log(`DeckBuilderUI: Rendered ${cardsRendered} collection cards.`);
        this._initializeSortables(); // Re-inicializa após renderizar
    }

    _renderDeckPanel() {
        const $container = $(this.#deckListElement).empty(); // Usa o elemento DOM cacheado
        console.log("DeckBuilderUI: Rendering Deck Panel. Current cards:", this.#dbState.currentDeckCards);

        this.#dbState.currentDeckCards.forEach(id => {
            if (this.#cardDatabase[id]) {
                const $mc = this.#cardRenderer.renderMiniCard(this.#cardDatabase[id], 'deck'); // Usa o helper
                if ($mc) $container.append($mc);
            } else {
                console.warn(`DeckBuilderUI: Card ID '${id}' in deck state not found in database.`);
            }
        });

        if (this.#dbState.currentDeckCards.length === 0) {
             $container.append('<p class="placeholder-message">(Arraste cartas da coleção para cá)</p>');
        }
        // Não chama _updateDeckValidity aqui, é chamado por quem chama _renderDeckPanel
        // Não chama _initializeSortables aqui, é chamado por _renderCollectionPanel
    }


    // --- SortableJS Initialization & Re-initialization ---
    _initializeSortables() {
        if (this.#collectionSortable) this.#collectionSortable.destroy();
        if (this.#deckSortable) this.#deckSortable.destroy();
    
        if (!this.#collectionListElement || !this.#deckListElement) {
            console.error("DeckBuilderUI Error: Sortable list DOM elements not found.");
            return;
        }
        console.log("DeckBuilderUI: Initializing/Re-initializing SortableJS...");
        const self = this;
    
        const commonSortableOptions = {
            animation: 150,
            filter: '.placeholder-message',
            preventOnFilter: false,
            onMove: function (evt) {
                $(evt.to).addClass('drag-over');
                const $relatedList = $(evt.related).closest('.card-list');
                if ($relatedList.is(self.#collectionListElement)) {
                    $relatedList.addClass('drag-over');
                }
                if (!$relatedList.length) { $('body').addClass('drag-over-body'); }
                else { $('body').removeClass('drag-over-body'); }
            },
            onUnchoose: function(evt) {
                $('.card-list').removeClass('drag-over');
                $('body').removeClass('drag-over-body');
            }
        };
    
        this.#collectionSortable = new Sortable(this.#collectionListElement, {
            ...commonSortableOptions,
            group: { name: 'deckBuilderShared', pull: 'clone', put: true }, // Adicionado put:true para permitir que cards sejam colocados de volta
            sort: false,
            onStart: () => { $('body').removeClass('dragging-from-deck'); }
        });
    
        this.#deckSortable = new Sortable(this.#deckListElement, {
            ...commonSortableOptions,
            group: { name: 'deckBuilderShared', pull: true, put: true },
            sort: true,
            onAdd: function (evt) {
                const cardId = $(evt.item).data('card-id');
                const added = self._addCardToDeck(cardId);
                if (!added) $(evt.item).remove();
                $(evt.to).removeClass('drag-over');
            },
            onRemove: function (evt) {
                const cardId = $(evt.item).data('card-id');
                console.log(`Removing card from deck: ${cardId}`); // Debug log
                const removed = self._removeCardFromDeck(cardId);
                if (!removed) console.warn(`Failed to remove ${cardId} from state.`);
                
                // Adiciona sinalização vermelha no container da coleção
                $(self.#collectionListElement).addClass('drag-removal');
                
                // Remove a classe após 500ms para limpar o efeito
                setTimeout(() => {
                    $(self.#collectionListElement).removeClass('drag-removal');
                }, 500);
                
                $('body').removeClass('drag-over-body');
                $(evt.from).removeClass('drag-over');
            },
            onUpdate: function (evt) {
                setTimeout(() => {
                    self.#dbState.currentDeckCards = $(self.#deckListElement).children('.mini-card').map((i, el) => $(el).data('card-id')).get();
                    self._updateDeckValidity();
                    console.log("DeckBuilderUI State: Deck reordered", self.#dbState.currentDeckCards);
                }, 0);
            },
            onStart: () => { $('body').addClass('dragging-from-deck'); },
            onEnd: () => { $('body').removeClass('dragging-from-deck'); }
        });
        console.log("DeckBuilderUI: SortableJS initialized/re-initialized.");
    }
}


--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\DeckBuilderUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\OptionsUI.js ---
// js/ui/screens/OptionsUI.js

export default class OptionsUI {
    // --- Elementos da UI (Cache) ---
    #optionsScreenElement;
    #musicVolumeSlider;
    #musicVolumeValueSpan;
    #sfxVolumeSlider;
    #sfxVolumeValueSpan;
    #graphicsQualitySelect;
    #cardAnimationsCheckbox;
    #languageSelect;
    #textSizeSelect;
    #highContrastCheckbox;
    #saveButton;
    #saveMessageParagraph;
    // Adicione seletores para outros botões (ex: Voltar) se forem gerenciados aqui

    // --- Estado Interno ---
    #options = { // Default options
        musicVolume: 80,
        sfxVolume: 100,
        graphicsQuality: 'medium',
        cardAnimations: true,
        language: 'pt-BR',
        textSize: 'normal',
        highContrast: false
    };
    #OPTIONS_STORAGE_KEY = 'runebound_clash_options'; // Chave do localStorage

    constructor() {
        this._cacheSelectors(); // Busca e armazena seletores jQuery
        if (!this.#optionsScreenElement || !this.#optionsScreenElement.length) {
            console.error("OptionsUI Error: #options-screen element not found!");
            return; // Impede erros se a tela não existir
        }
        this._loadOptions();      // Carrega opções salvas ao inicializar
        this._bindEvents();       // Vincula eventos aos controles
        console.log("OptionsUI initialized.");
    }

    /** Cacheia seletores jQuery para elementos da UI de opções */
    _cacheSelectors() {
        this.#optionsScreenElement = $('#options-screen');
        this.#musicVolumeSlider = this.#optionsScreenElement.find('#opt-music-volume');
        this.#musicVolumeValueSpan = this.#musicVolumeSlider.siblings('.volume-value');
        this.#sfxVolumeSlider = this.#optionsScreenElement.find('#opt-sfx-volume');
        this.#sfxVolumeValueSpan = this.#sfxVolumeSlider.siblings('.volume-value');
        this.#graphicsQualitySelect = this.#optionsScreenElement.find('#opt-graphics-quality');
        this.#cardAnimationsCheckbox = this.#optionsScreenElement.find('#opt-card-animations');
        this.#languageSelect = this.#optionsScreenElement.find('#opt-language');
        this.#textSizeSelect = this.#optionsScreenElement.find('#opt-text-size');
        this.#highContrastCheckbox = this.#optionsScreenElement.find('#opt-high-contrast');
        this.#saveButton = this.#optionsScreenElement.find('#btn-save-options');
        this.#saveMessageParagraph = this.#optionsScreenElement.find('#options-save-message');
    }

    /** Renderiza/Atualiza os controles da UI com os valores atuais das opções */
    render() {
        console.log("OptionsUI: Rendering options screen controls.");
        if (!this.#optionsScreenElement.length) return; // Sai se a tela não foi encontrada

        // Define os valores dos controles com base nas opções carregadas/padrão
        this.#musicVolumeSlider.val(this.#options.musicVolume);
        this.#musicVolumeValueSpan.text(`${this.#options.musicVolume}%`);
        this.#sfxVolumeSlider.val(this.#options.sfxVolume);
        this.#sfxVolumeValueSpan.text(`${this.#options.sfxVolume}%`);
        this.#graphicsQualitySelect.val(this.#options.graphicsQuality);
        this.#cardAnimationsCheckbox.prop('checked', this.#options.cardAnimations);
        this.#languageSelect.val(this.#options.language);
        this.#textSizeSelect.val(this.#options.textSize);
        this.#highContrastCheckbox.prop('checked', this.#options.highContrast);

        this._applyVisualOptions(); // Aplica opções que afetam a aparência geral
        this.#saveMessageParagraph.text(''); // Limpa mensagens anteriores
    }

    /** Vincula eventos aos controles da tela de opções */
    _bindEvents() {
        console.log("OptionsUI: Binding events...");

        // Sliders de Volume (atualiza o span de valor)
        this.#musicVolumeSlider.on('input', () => {
            this.#musicVolumeValueSpan.text(`${this.#musicVolumeSlider.val()}%`);
        });
        this.#sfxVolumeSlider.on('input', () => {
            this.#sfxVolumeValueSpan.text(`${this.#sfxVolumeSlider.val()}%`);
        });

        // Botão Salvar
        this.#saveButton.on('click', this._saveOptions.bind(this));

        // Checkbox Alto Contraste (pode aplicar imediatamente ou apenas ao salvar)
        this.#highContrastCheckbox.on('change', () => {
            // Opcional: Aplicar imediatamente para feedback visual
            // $('body').toggleClass('contrast-high', this.#highContrastCheckbox.is(':checked'));
        });

        // Select Tamanho do Texto (pode aplicar imediatamente ou apenas ao salvar)
        this.#textSizeSelect.on('change', () => {
             // Opcional: Aplicar imediatamente
             // const newSize = this.#textSizeSelect.val();
             // $('body').removeClass('text-small text-large text-normal').addClass(`text-${newSize}`);
        });

        // Botão Voltar (já vinculado no main.js, mas pode ser movido para cá se preferir)
        // this.#optionsScreenElement.find('#btn-options-back-to-main').on('click', () => {
        //     // Precisa da instância do ScreenManager se for fazer aqui
        //     // this.#screenManager.goBack('profile-screen');
        // });
    }

    // --- Métodos Internos ---

    /** Carrega as opções do localStorage para o estado interno */
    _loadOptions() {
        try {
            const storedOptions = localStorage.getItem(this.#OPTIONS_STORAGE_KEY);
            if (storedOptions) {
                const loaded = JSON.parse(storedOptions);
                // Mescla com defaults para garantir que todas as chaves existam
                this.#options = { ...this.#options, ...loaded };
                console.log("OptionsUI: Options loaded from localStorage:", this.#options);
            } else {
                console.log("OptionsUI: No saved options found, using defaults.");
                // Salva os defaults na primeira vez? Opcional.
                // localStorage.setItem(this.#OPTIONS_STORAGE_KEY, JSON.stringify(this.#options));
            }
        } catch (e) {
            console.error("OptionsUI: Error loading options from localStorage:", e);
            // Usa os defaults se o carregamento falhar
        }
        // Aplica imediatamente após carregar (ou usa defaults)
        // this._applyVisualOptions(); // render() já chama isso
    }

    /** Salva as opções atuais (lidas da UI) no localStorage */
    _saveOptions() {
        // Lê os valores atuais dos controles da UI
        this.#options.musicVolume = parseInt(this.#musicVolumeSlider.val(), 10);
        this.#options.sfxVolume = parseInt(this.#sfxVolumeSlider.val(), 10);
        this.#options.graphicsQuality = this.#graphicsQualitySelect.val();
        this.#options.cardAnimations = this.#cardAnimationsCheckbox.is(':checked');
        this.#options.language = this.#languageSelect.val();
        this.#options.textSize = this.#textSizeSelect.val();
        this.#options.highContrast = this.#highContrastCheckbox.is(':checked');

        try {
            localStorage.setItem(this.#OPTIONS_STORAGE_KEY, JSON.stringify(this.#options));
            console.log("OptionsUI: Options saved to localStorage:", this.#options);
            this._showMessage('Opções salvas com sucesso!', 'success');
            this._applyVisualOptions(); // Aplica as opções salvas imediatamente
        } catch (e) {
            console.error("OptionsUI: Error saving options to localStorage:", e);
            this._showMessage('Erro ao salvar opções.', 'error');
        }
    }

    /** Aplica opções que têm efeito visual imediato (tamanho texto, contraste) */
    _applyVisualOptions() {
        console.log("OptionsUI: Applying visual options...");
        $('body')
            .removeClass('text-small text-normal text-large contrast-high') // Limpa classes anteriores
            .addClass(`text-${this.#options.textSize || 'normal'}`) // Adiciona classe de tamanho
            .toggleClass('contrast-high', this.#options.highContrast); // Adiciona/remove classe de contraste

        // TODO: Implementar lógica para aplicar volume (requer interação com player de áudio)
        // TODO: Implementar lógica para qualidade gráfica (pode setar classes CSS, ou parâmetros em engine 3D)
        // TODO: Implementar lógica para animações (pode setar classe CSS para desabilitar transitions/animations)
        $('body').toggleClass('disable-card-animations', !this.#options.cardAnimations); // Exemplo
    }

    /** Exibe uma mensagem de feedback na tela de opções */
    _showMessage(text, type = 'info', duration = 3000) {
        const colorVar = type === 'success' ? '--success-color' : type === 'error' ? '--error-color' : '--text-color';
        this.#saveMessageParagraph.text(text).css('color', `var(${colorVar})`);
        if (duration > 0) {
            setTimeout(() => {
                // Só limpa se a mensagem ainda for a mesma
                if (this.#saveMessageParagraph.text() === text) {
                    this.#saveMessageParagraph.text('');
                }
            }, duration);
        }
    }

} // End class OptionsUI
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\OptionsUI.js ---


--- INÍCIO DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\ProfileScreenUI.js ---
// js/ui/screens/ProfileScreenUI.js

// Assume que CardRenderer e ZoomHandler são importados
import CardRenderer from '../helpers/CardRenderer.js';
import ZoomHandler from '../helpers/ZoomHandler.js';

export default class ProfileScreenUI {
    #screenManager;
    #accountManager;
    #cardDatabase;
    #cardRenderer;
    #zoomHandler;
    #uiManager; // Referência ao UIManager central (para chamar renderDeckBuilder)

    #profileScreenElement; // Cache do elemento da tela

    constructor(screenManager, accountManager, cardDatabase, cardRenderer, zoomHandler, uiManager) {
        this.#screenManager = screenManager;
        this.#accountManager = accountManager;
        this.#cardDatabase = cardDatabase;
        this.#cardRenderer = cardRenderer; // Recebe a instância do renderer
        this.#zoomHandler = zoomHandler;   // Recebe a instância do zoom handler
        this.#uiManager = uiManager;       // Recebe a instância do UIManager

        this.#profileScreenElement = $('#profile-screen'); // Cacheia o seletor da tela
        if (!this.#profileScreenElement.length) {
            console.error("ProfileScreenUI Error: Element #profile-screen not found!");
            return; // Evita erros se o elemento não existir
        }
        this._bindEvents(); // Vincula eventos uma vez na inicialização
        console.log("ProfileScreenUI initialized.");
    }

    /** Renderiza/Atualiza todo o conteúdo da tela de perfil */
    render() {
        console.log("ProfileScreenUI: Rendering...");
        const currentUser = this.#accountManager.getCurrentUser();
        if (!currentUser) {
            console.warn("ProfileScreenUI: Cannot render - user not logged in.");
            this.#screenManager.showScreen('login-screen'); // Redireciona se não logado
            return;
        }

        const collection = currentUser.collection || [];
        const decks = currentUser.decks || {};

        this._renderUserInfo(currentUser);
        this._renderAvatarSection(currentUser.avatar);
        this._renderMatchHistory(currentUser.matchHistory || []);
        this._renderCollection(collection);
        this._renderDeckList(decks);

        console.log("ProfileScreenUI: Render complete.");
    }

    /** Vincula eventos específicos da tela de perfil usando delegação */
    _bindEvents() {
        console.log("ProfileScreenUI: Binding events...");

        // Seleção de Avatar
        this.#profileScreenElement.on('click', '.avatar-choice', (event) => {
            this._handleAvatarClick(event);
        });

        // Zoom na Coleção (delegando ao ZoomHandler)
        this.#profileScreenElement.on('contextmenu', '#profile-unlocked-cards .mini-card', (event) => {
             this.#zoomHandler.handleZoomClick(event); // Passa o evento para o handler
        });
        // Prevenir menu de contexto default nos cards
        this.#profileScreenElement.on('contextmenu', '#profile-unlocked-cards .mini-card', (e) => e.preventDefault());


        // Botões de Deck
        this.#profileScreenElement.on('click', '#profile-deck-list .btn-edit-deck', (event) => {
            this._handleEditDeck(event);
        });
        this.#profileScreenElement.on('click', '#profile-deck-list .btn-delete-deck', (event) => {
            this._handleDeleteDeck(event);
        });
        this.#profileScreenElement.on('click', '#btn-goto-deck-builder-new', () => {
            this._handleManageDecks();
        });

        // Fechar Zoom Overlay específico do Perfil
        // É importante usar .off().on() se _bindEvents puder ser chamado múltiplas vezes
        $('#image-zoom-overlay').off('click.profilezoom').on('click.profilezoom', (event) => {
            if (event.target === event.currentTarget) {
                this.#zoomHandler.closeZoom(); // Usa o método do handler para fechar
            }
        });
    }

    // --- Handlers de Eventos Internos ---

    _handleAvatarClick(event) {
        const avatarFilename = $(event.currentTarget).data('avatar');
        if (avatarFilename && this.#accountManager.saveAvatarChoice(avatarFilename)) {
            $('#profile-avatar-img').attr('src', `assets/images/avatars/${avatarFilename}`);
            this.#profileScreenElement.find('.avatar-choice').removeClass('selected-avatar');
            $(event.currentTarget).addClass('selected-avatar');
            console.log("ProfileScreenUI: Avatar updated.");
            // Atualiza avatar na top bar também, se necessário (via UIManager?)
            // this.#uiManager.updateTopBarAvatar(avatarFilename); // Exemplo
        }
    }

    _handleEditDeck(event) {
        const deckId = $(event.currentTarget).closest('li').data('deck-id');
        if (deckId) {
            console.log(`ProfileScreenUI: Edit deck requested: ${deckId}`);
            // Chama o método do UIManager central para renderizar a tela correta
            this.#uiManager.renderDeckBuilderScreen(deckId);
            this.#screenManager.showScreen('deck-builder-screen');
        }
    }

    _handleDeleteDeck(event) {
        const $li = $(event.currentTarget).closest('li');
        const deckId = $li.data('deck-id');
        const deckName = $li.find('.deck-name').text().replace(/\(\d+\s*cartas?\)$/, '').trim();
        if (deckId && confirm(`Tem certeza que deseja excluir o deck "${deckName}"?`)) {
            const result = this.#accountManager.deleteDeck(deckId);
            if (result.success) {
                console.log(`ProfileScreenUI: Deck ${deckId} deleted.`);
                this.render(); // Re-renderiza a tela de perfil para atualizar a lista
            } else {
                alert(`Erro ao excluir deck: ${result.message}`);
            }
        }
    }

    _handleManageDecks() {
        console.log("ProfileScreenUI: Navigating to new deck creation.");
        // Chama o método do UIManager central para renderizar a tela correta sem ID
        this.#uiManager.renderDeckBuilderScreen();
        this.#screenManager.showScreen('deck-builder-screen');
    }

    // --- Métodos de Renderização Privados ---

    _renderUserInfo(currentUser) {
        $('#profile-username').text(currentUser.username);
        $('#profile-rank').text(currentUser.rank || 'N/A');
        $('#profile-wins').text(currentUser.stats?.wins ?? 0);
        $('#profile-losses').text(currentUser.stats?.losses ?? 0);
    }

    _renderAvatarSection(currentAvatarFilename) {
        const avatarFile = currentAvatarFilename || 'default.png';
        $('#profile-avatar-img').attr('src', `assets/images/avatars/${avatarFile}`).attr('alt', `Avatar: ${avatarFile}`);
        this.#profileScreenElement.find('.avatar-choice').removeClass('selected-avatar');
        this.#profileScreenElement.find(`.avatar-choice[data-avatar="${avatarFile}"]`).addClass('selected-avatar');
        // O HTML dos choices já é gerado no template, só precisamos marcar o selecionado.
    }

    _renderMatchHistory(history) {
        const $list = $('#profile-match-history').empty();
        if (!history || history.length === 0) {
            $list.append('<li>(Nenhum histórico ainda)</li>');
            return;
        }
        history.slice(0, 10).forEach(match => {
             const dateStr = new Date(match.date).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', hour:'2-digit', minute: '2-digit'});
             const resultClass = match.result === 'win' ? 'history-win' : match.result === 'loss' ? 'history-loss' : 'history-draw';
             const resultText = match.result === 'win' ? 'Vitória' : match.result === 'loss' ? 'Derrota' : 'Empate';
             // Adapte a exibição conforme os dados que você salva em matchData
             $list.append(`<li class="${resultClass}">${dateStr} - ${resultText} vs ${match.opponent || 'Oponente'}</li>`);
        });
    }

    _renderCollection(collectionIds) {
        const $container = $('#profile-unlocked-cards').empty();
        $('#profile-card-count').text(collectionIds?.length || 0);
        if (!Array.isArray(collectionIds) || collectionIds.length === 0) {
            $container.append('<p class="placeholder-message">(Nenhuma carta na coleção)</p>');
            return;
        }
        let cardsRendered = 0;
        collectionIds.forEach(id => {
            const cardDef = this.#cardDatabase[id];
            if (cardDef) {
                const $miniCard = this.#cardRenderer.renderMiniCard(cardDef, 'collection'); // Usa o helper
                if ($miniCard) {
                    $container.append($miniCard);
                    cardsRendered++;
                }
            } else {
                console.warn(`ProfileScreenUI: Card ID '${id}' missing from database.`);
            }
        });
        console.log(`ProfileScreenUI: Rendered ${cardsRendered} collection cards.`);
    }

    _renderDeckList(decks) {
        const $list = $('#profile-deck-list').empty();
        const deckIds = Object.keys(decks || {});
        if (!deckIds.length) {
            $list.append('<li>(Nenhum deck criado)</li>');
            return;
        }
        deckIds.forEach(id => {
            const deck = decks[id];
            if (deck) {
                $list.append(`
                    <li data-deck-id="${id}">
                        <span class="deck-name">${deck.name} (${deck.cards?.length || 0} cartas)</span>
                        <span class="deck-buttons">
                            <button class="btn-edit-deck" title="Editar Deck">✏️</button>
                            <button class="btn-delete-deck" title="Excluir Deck">🗑️</button>
                        </span>
                    </li>`);
            }
        });
        console.log(`ProfileScreenUI: Rendered ${deckIds.length} decks.`);
    }
}
--- FIM DE: C:\Users\Fred\Documents\game-dev\runebound_dccg\js\ui\screens\ProfileScreenUI.js ---
